{"version":3,"sources":["webpack://hexel-art/../glib/src/buffer/color-buffer.ts","webpack://hexel-art/../glib/src/buffer/mat2d-buffer.ts","webpack://hexel-art/../glib/src/buffer/struct-buffer.ts","webpack://hexel-art/../glib/src/buffer/vec2-buffer.ts","webpack://hexel-art/../glib/src/event/pointer-event.ts","webpack://hexel-art/../glib/src/event/wheel-event.ts","webpack://hexel-art/../glib/src/index.ts","webpack://hexel-art/../glib/src/model/ellipse-model.ts","webpack://hexel-art/../glib/src/model/mesh.ts","webpack://hexel-art/../glib/src/model/model.ts","webpack://hexel-art/../glib/src/model/polygon-mesh.ts","webpack://hexel-art/../glib/src/model/polygon-model.ts","webpack://hexel-art/../glib/src/program/ellipse-program.ts","webpack://hexel-art/../glib/src/program/fill-program.ts","webpack://hexel-art/../glib/src/program/program-util.ts","webpack://hexel-art/../glib/src/program/program.ts","webpack://hexel-art/../glib/src/rendering/camera.ts","webpack://hexel-art/../glib/src/rendering/renderer.ts","webpack://hexel-art/../glib/src/rendering/surface.ts","webpack://hexel-art/../glib/src/shader/ellipse.ts","webpack://hexel-art/../glib/src/shader/fill.ts","webpack://hexel-art/../glib/src/struct/color.ts","webpack://hexel-art/../glib/src/struct/colorf.ts","webpack://hexel-art/../glib/src/struct/ellipse.ts","webpack://hexel-art/../glib/src/struct/line-segment.ts","webpack://hexel-art/../glib/src/struct/mat2d.ts","webpack://hexel-art/../glib/src/struct/mat4.ts","webpack://hexel-art/../glib/src/struct/point.ts","webpack://hexel-art/../glib/src/struct/rect.ts","webpack://hexel-art/../glib/src/struct/util.ts","webpack://hexel-art/../glib/src/struct/vec2.ts","webpack://hexel-art/../glib/src/tool/pan-tool.ts","webpack://hexel-art/../glib/src/tool/pinch-zoom-tool.ts","webpack://hexel-art/../glib/src/tool/stroke.ts","webpack://hexel-art/../glib/src/tool/wheel-zoom-tool.ts","webpack://hexel-art/./src/hexel/scene.ts","webpack://hexel-art/./src/index.ts","webpack://hexel-art/webpack/bootstrap","webpack://hexel-art/webpack/startup"],"names":["withLength","n","this","Uint8Array","getComponent","value","setComponent","newStruct","data","ColorBuffer","StructBuffer","Float32Array","Mat2dBuffer","dataPosition","componentLength","index","assertValidIndex","length","at","position","get","getStructData","begin","end","subarray","Rect","empty","measureBounds","p0","bounds","dimensions","x","y","i","unionPoint","Vec2Buffer","containsPoint","p","offset","count","inside","x1","y1","x2","y2","id","status","surface","isPrimary","isDown","activePointers","Pointer","wherePointer","onPointerDown","onPointerMove","onPointerUp","onPointerCancel","PointerEventListener","listeners","e","pointer","addPointer","dispatchEvent","l","removePointer","startListening","canvasEl","addEventListener","stopListening","removeEventListener","addListener","listener","push","invokeFn","filter","forEach","getPointerIndex","pointerId","newPointer","setPointerCapture","mapScreenPointToWorld","releasePointerCapture","splice","PointerEventDetector","deltaY","Wheel","onWheel","preventDefault","wheel","WheelEventDetector","matrix","EllipseProgram","mesh","measureBoundaries","a","b","tx","c","d","ty","a2","b2","c2","d2","m","phi","Math","atan2","cos2","pow","cos","sin2","sin","s1","s2","sqrt","sx2","sy2","copy","left","right","top","bottom","EllipseModel","dst","transform","Mat2d","rectToRect","contains","modelPoint","mapPointToModelSpace","Vec2","length2","PolygonModel","Mesh","vertices","indices","c3r1","c3r2","mapPointToWorldSpace","out","mapPoint","worldPoint","invert","concat","translate","v","scale","pivot","center","stretch","factor","rotate","radians","Model","miters","PolygonMesh","regularPolygon","flatTop","regularVertices","regularIndices","angle","PI","rotation","Uint16Array","rectangle","r","rectangleVertices","topLeft","bottomLeft","bottomRight","topRight","star","ratio","starVertices","starIndices","points","innerIndexCount","outerIndexCount","first","second","third","lastIndex","prev","curr","line1","fromPointToPoint","line2","miter","identity","vertexAt","scaleToFit","stf","stretchAcross","p1","p2","cx","centerX","t","s","stretchRotateToPoint","create","util","program","location","createProgramFromSources","Shader","vertex","fragment","uniforms","getUniformLocationMap","uniformRenaming","attribs","getAttributeLocationMap","attributeRenaming","positionBuffer","createArrayBuffer","matrixBuffer","createBuffer","onAttach","gl","angleExt","c1","model","c3","enable","BLEND","bindBuffer","ARRAY_BUFFER","enableVertexAttribArray","vertexAttribPointer","FLOAT","vertexAttribDivisorANGLE","onDetach","draw","renderer","matrices","camera","useProgram","loadProjection","loadMatrices","loadFillColor","loadStrokeColor","loadLineWidth","drawArraysInstancedANGLE","TRIANGLE_FAN","projection","uniformMatrix4fv","bufferData","DYNAMIC_DRAW","uniform4fv","fillColor","strokeColor","uniform1f","lineWidth","Program","meshes","FillProgram","indexBuffer","createIndexBuffer","createVertexBuffer","dynamicBuffer","column1","column2","column3","ELEMENT_ARRAY_BUFFER","loadColor","loadVertices","drawElementsInstancedANGLE","TRIANGLES","UNSIGNED_SHORT","indexBufferOffset","drawTriangleStrip","loadLineVertices","TRIANGLE_STRIP","color","vertexBufferOffset","size","usage","STATIC_DRAW","buffer","createElementBuffer","sizeOfVertexBuffer","bufferSubData","byteLength","reduce","total","sizeOfIndexBuffer","createMiterBuffer","sizeOfStrokeVertexBuffer","miterBufferOffset","createStrokeIndexBuffer","indexCount","lengthOfStrokeIndexArray","vertexCount","strokeIndexCount","strokeIndexBufferOffset","createStrokeVertexBuffer","strokeVertexBufferOffset","vertexShaderSource","fragmentShaderSource","vs","compileShader","VERTEX_SHADER","fs","FRAGMENT_SHADER","createProgramFromShaders","vertexShader","fragmentShader","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","shaderSource","shaderType","shader","createShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","renamed","getUniformLocation","ACTIVE_UNIFORMS","getActiveUniform","getAttribLocation","ACTIVE_ATTRIBUTES","getActiveAttrib","ProgramUtil","world","minZoom","maxZoom","view","zoom","setViewport","vw","vh","vr","wr","aspect","mapRect","updateMatrix","desiredOffset","target","add","far","rotate180","actualOffset","zoomIn","desiredScaleFactor","actualScaleFactor","targetZoom","zoomToPoint","focus","normX","width","normY","height","aft","Mat4","ortho","Camera","getExtension","onSurfaceChange","viewport","currentProgram","attachProgram","Renderer","scene","clientRect","getBoundingClientRect","hasRenderRequest","checkRender","resize","onAnimationFrame","requestAnimationFrame","startRenderLoop","requestRender","clientWidth","clientHeight","startDetectingPointerEvents","detector","startDetectingWheelEvents","pan","actual","zoomOut","mapScreenPointToCanvas","screenPoint","clientX","clientY","mapScreenPointToNdc","mapCanvasPointToNdc","mapNdcToWorld","canvasPoint","ndc","Surface","fromRgbaInt","rgba","g","rgb","argb","parseInt","substr","pad","toString","randomByte","undefined","src","alpha","invAlpha","isTransparent","abs","random","rx","ry","Point","sx","sy","e1","e2","equals","midpoint","distance","epsilon","len2","dot","closest","multiply","distance2","LineSegment","det","determinant","c1r1","c2r1","c1r2","c2r2","conjugate","conjugator","sinCos","getScaleToFitPoint","start","v1","v2","l1","l2","n1","divide","n2","cross","origin","srcPoint","dstPoint","min","corners","corner","m1","m2","clip","near","depth","w","h","centerY","isEmpty","isValid","union","max","intersects","intersect","inset","offsetX","offsetY","dx","dy","containsX","containsY","sort","vFlipped","hFlipped","randomInt","floor","str","normalize","rotate90","boundX","targetX","side","boundY","targetY","miterLimit","direction","previous","toPrevious","PanTool","line","measureLine","previousSpan","previousFocus","PinchZoomTool","moveTo","thickness","halfThickness","bot","lineTo","nextIndex","prevCen","getPreviousPoint","prevLine","prevPrevCen","subtract","currIndex","prevTop","prevBot","Stroke","scaleFactor","WheelZoomTool","fill","hexagon","clearColor","clear","COLOR_BUFFER_BIT","CULL_FACE","cullFace","BACK","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","Scene","document","getElementById","getContext","hexMesh","matBuf","ColorF","pointerEvents","__webpack_module_cache__","__webpack_require__","moduleId","exports","module","__webpack_modules__","call"],"mappings":"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","file":"index.js","sourcesContent":["import { Color, StructBuffer } from '..';\nimport { TypedArray } from './typed-array';\n\nexport type ColorfBuffer = ColorBuffer<Float32Array>;\n\nexport class ColorBuffer<T extends TypedArray> extends StructBuffer<T, Color.Like> implements Color.Like {\n\n    /** Creates a color buffer large enough to hold the specified number of colors. */\n    static withLength(n: number) {\n        return new this(new Uint8Array(n * 4));\n    }\n\n    get componentLength() {\n        return 4;\n    }\n\n    get r() { \n        return this.getComponent(0);\n    }\n\n    set r(value: number) {\n        this.setComponent(0, value);\n    }\n\n    get g() { \n        return this.getComponent(1);\n    }\n\n    set g(value: number) {\n        this.setComponent(1, value);\n    }\n\n    get b() { \n        return this.getComponent(2);\n    }\n\n    set b(value: number) {\n        this.setComponent(2, value);\n    }\n\n    get a() { \n        return this.getComponent(3);\n    }\n\n    set a(value: number) {\n        this.setComponent(3, value);\n    }\n\n    protected newStruct(data: T): Color.Like {\n        return new ColorBuffer(data);\n    }\n} \n","import { Mat2d, StructBuffer } from '..';\n\nexport class Mat2dBuffer extends StructBuffer<Float32Array, Mat2d.Like> implements Mat2d.Like {\n\n    /** Creates a mat2d buffer large enough to hold the specified number of mat2ds. */\n    static withLength(n: number) {\n        return new this(new Float32Array(n * 6));\n    }\n\n    get componentLength() {\n        return 6;\n    }\n\n    get c1r1() { \n        return this.getComponent(0);\n    }\n\n    set c1r1(value: number) {\n        this.setComponent(0, value);\n    }\n\n    get c1r2() { \n        return this.getComponent(1);\n    }\n\n    set c1r2(value: number) {\n        this.setComponent(1, value);\n    }\n\n    get c2r1() { \n        return this.getComponent(2);\n    }\n\n    set c2r1(value: number) {\n        this.setComponent(2, value);\n    }\n\n    get c2r2() { \n        return this.getComponent(3);\n    }\n\n    set c2r2(value: number) {\n        this.setComponent(3, value);\n    }\n\n    get c3r1() { \n        return this.getComponent(4);\n    }\n\n    set c3r1(value: number) {\n        this.setComponent(4, value);\n    }\n\n    get c3r2() { \n        return this.getComponent(5);\n    }\n\n    set c3r2(value: number) {\n        this.setComponent(5, value);\n    }\n\n    protected newStruct(data: Float32Array): Mat2d.Like {\n        return new Mat2dBuffer(data);\n    }\n} \n","import { TypedArray } from \"..\";\n\n\nexport abstract class StructBuffer<T extends TypedArray, S> {\n\n    private dataPosition = 0;\n\n    constructor(  \n        /** The primitive array data backing the Structs in this buffer.*/\n        public readonly data: T,\n    ) {}\n\n    /** The current position of this buffer */\n    get position() {\n        return this.dataPosition / this.componentLength;\n    }\n\n    set position(index: number) {\n        this.assertValidIndex(index);\n        this.dataPosition = index * this.componentLength;\n    }\n\n    private assertValidIndex(index: number) {\n        if (index < 0 || index >= this.length) {\n            throw \"Index \" + index + \" is out of bounds\";\n        }\n    }\n\n    /** @returns this buffer positioned at the specified index */\n    at(index: number): this {\n        this.position = index;\n        return this;\n    }\n\n    /** The number of structs in this buffer */\n    get length() {\n        return this.data.length / this.componentLength;\n    }\n\n    /** The number of components making up each struct. */\n    abstract get componentLength();\n\n    protected getComponent(index: number) {\n        return this.data[this.dataPosition + index];\n    }\n\n    protected setComponent(index: number, value: number) {\n        return this.data[this.dataPosition + index] = value;\n    }\n\n    /** Gets the struct at the specified index. */\n    get(index: number): S {\n        this.assertValidIndex(index);\n        let data = this.getStructData(index);\n        return this.newStruct(data);\n    }\n\n    protected abstract newStruct(data: T): S\n\n    private getStructData(index: number) {\n        let begin = index * this.componentLength;\n        let end = begin + this.componentLength;\n        return <T> this.data.subarray(begin, end);\n    }\n}","import { Point, Vec2, StructBuffer, Rect } from '..';\n\nexport class Vec2Buffer extends StructBuffer<Float32Array, Vec2.Like> implements Vec2.Like {\n\n    /** Creates a vec2 buffer large enough to hold the specified number of vec2s. */\n    static withLength(n: number) {\n        return new this(new Float32Array(n * 2));\n    }\n\n    get componentLength() {\n        return 2;\n    }\n\n    get x() { \n        return this.getComponent(0);\n    }\n\n    set x(value: number) {\n        this.setComponent(0, value);\n    }\n\n    get y() {\n        return this.getComponent(1);\n    }\n\n    set y(value: number) {\n        this.setComponent(1, value);\n    }\n\n    get bounds(): Rect\n    {\n        return this.length == 0 ? Rect.empty() : this.measureBounds(this.at(0));\n    }\n\n    /** Algorithm used when buffer contains at least one point (p0) */\n    private measureBounds(p0: Point.Like)\n    {\n        let bounds = Rect.dimensions(p0.x, p0.y, 0, 0);\n        for (let i = 1; i < this.length; i++) {\n            bounds.unionPoint(this.at(i));\n        }\n        return bounds;\n    }\n\n    protected newStruct(data: Float32Array): Vec2.Like {\n        return new Vec2Buffer(data);\n    }\n\n    /**\n     * Checks if a polygon (specified by a subset of vertices in this buffer) contains the specified point.\n     * @param x the x coordinate of the point to check.\n     * @param y the y coordinate of the point to check.\n     * @param offset the offset of the first polygon vertex. Defaults to zero.\n     * @param count the number of polygon vertices. Defaults to the number of vertices in this buffer.\n     */\n    containsPoint(p: Point.Like, offset = 0, count = this.length - offset) {\n        // Assume the point is not inside the polygon\n        let inside = false;\n\n        // Check point against each side of the polygon \n        let {x: x1, y: y1} = this.at(offset + count - 1);\n        while(count-- > 0){\n            let {x: x2, y: y2 } = this.at(offset++);\n            if((y1 > p.y) !== (y2 > p.y) && p.x < (x2 - x1) * (p.y - y1) / (y2 - y1) + x1){\n                inside = !inside; \n            }\n            x1 = x2; y1 = y2;\n        }\n\n        return inside;\n    }\n}\n","import { Surface, Point } from '..';\n\nexport const enum PointerStatus {\n    Down, Move, Up, Cancel,\n}\n\nexport class Pointer {\n    constructor(\n        public readonly id: number,\n        public readonly status: PointerStatus,\n        public readonly surface: Surface,\n        public readonly position: Point.Like,\n        public readonly isPrimary: boolean,\n        public readonly isDown: boolean,\n        public readonly activePointers: Pointer[],\n    ) {}\n}\n\nexport class PointerEventListener {\n    wherePointer(p: Pointer) { return true; }\n    onPointerDown(p: Pointer) {}\n    onPointerMove(p: Pointer) {}\n    onPointerUp(p: Pointer) {}\n    onPointerCancel(p: Pointer) {}\n}\n\nexport class PointerEventDetector {\n\n    public readonly activePointers = <Pointer[]> [];\n    private listeners = <PointerEventListener[]> [];\n\n    constructor(\n        private surface: Surface\n    ) {}\n\n    startListening() {\n        let { canvasEl } = this.surface;\n        canvasEl.addEventListener('pointerdown', this.onPointerDown);\n        canvasEl.addEventListener('pointermove', this.onPointerMove);\n        canvasEl.addEventListener('pointerup', this.onPointerUp);\n        canvasEl.addEventListener('pointercancel', this.onPointerCancel);\n    }\n\n    stopListening() {\n        let { canvasEl } = this.surface;\n        canvasEl.removeEventListener('pointerdown', this.onPointerDown);\n        canvasEl.removeEventListener('pointermove', this.onPointerMove);\n        canvasEl.removeEventListener('pointerup', this.onPointerUp);\n        canvasEl.removeEventListener('pointercancel', this.onPointerCancel);\n    }\n\n    addListener(listener: PointerEventListener) {\n        this.listeners.push(listener);\n    }\n\n    private onPointerDown = (e: PointerEvent) => {\n        let pointer = this.addPointer(e, PointerStatus.Down);\n        this.dispatchEvent(pointer, l => l.onPointerDown(pointer));\n    }\n\n    private onPointerMove = (e: PointerEvent) => {\n        let pointer = this.addPointer(e, PointerStatus.Move);\n        this.dispatchEvent(pointer, l => l.onPointerMove(pointer));\n    }\n  \n    private onPointerUp = (e: PointerEvent) => {\n        let pointer = this.addPointer(e, PointerStatus.Up);\n        this.dispatchEvent(pointer, l => l.onPointerUp(pointer));\n        this.removePointer(pointer);\n    }\n\n    private onPointerCancel = (e: PointerEvent) => {\n        let pointer = this.addPointer(e, PointerStatus.Up);\n        this.dispatchEvent(pointer, l => l.onPointerCancel(pointer));\n        this.removePointer(pointer);\n    }\n\n    private dispatchEvent(p: Pointer, invokeFn: (listener: PointerEventListener) => any) {\n        this.listeners.filter(l => l.wherePointer(p)).forEach(invokeFn);\n    }\n\n    private addPointer(e: PointerEvent, status: PointerStatus) {\n        let index = this.getPointerIndex(e.pointerId);\n        let isDown = status == PointerStatus.Down || !!this.activePointers[index]?.isDown;\n        let pointer = this.newPointer(e, status, isDown);\n        this.surface.canvasEl.setPointerCapture(pointer.id);\n        this.activePointers[index] = pointer;\n        return pointer;\n    }\n\n    private newPointer(e: PointerEvent, status: PointerStatus, isDown: boolean) {\n        return new Pointer(\n            e.pointerId, status, this.surface, \n            this.surface.mapScreenPointToWorld(e),\n            e.isPrimary, isDown, this.activePointers\n        );\n    }\n\n    private getPointerIndex(pointerId: number): number {\n        for (let i = 0; i < this.activePointers.length; i++) {\n            if (this.activePointers[i].id == pointerId) {\n                return i;\n            }\n        }\n        return this.activePointers.length;\n    }\n\n    private removePointer(pointer: Pointer) {\n        this.surface.canvasEl.releasePointerCapture(pointer.id);\n        this.activePointers.splice(this.getPointerIndex(pointer.id), 1);\n    }\n}","import { Surface, Point } from '..';\n\nexport const enum WheelStatus {\n    Down, Move, Up, Cancel,\n}\n\nexport class Wheel {\n    constructor(\n        public readonly deltaY,\n        public readonly surface: Surface,\n        public readonly position: Point.Like,\n    ) {}\n}\n\nexport interface WheelEventListener {\n    onWheel(w: Wheel);\n}\n\nexport class WheelEventDetector {\n\n    private listeners = <WheelEventListener[]> [];\n\n    constructor(\n        private surface: Surface\n    ) {}\n\n    startListening() {\n        this.surface.canvasEl.addEventListener('wheel', this.onWheel);\n    }\n\n    stopListening() {\n        this.surface.canvasEl.removeEventListener('wheel', this.onWheel);\n    }\n\n    addListener(listener: WheelEventListener) {\n        this.listeners.push(listener);\n    }\n\n    private onWheel = (e: WheelEvent) => {\n        e.preventDefault(); // TODO: maybe only prevent default if the onWheel function returns true?\n        let wheel = new Wheel(e.deltaY, this.surface, this.surface.mapScreenPointToWorld(e));\n        this.listeners.forEach(l => l.onWheel(wheel));\n    }\n}","export * as Color from './struct/color';\nexport * as ColorF from './struct/colorf';\nexport * as Ellipse from './struct/ellipse';\nexport * from './struct/line-segment';\nexport * as Mat2d from './struct/mat2d';\nexport * as Point from './struct/point';\nexport * from './struct/rect';\nexport * as Vec2 from './struct/vec2';\nexport * as Mat4 from './struct/mat4';\nexport * from './buffer/struct-buffer';\nexport * from './buffer/color-buffer';\nexport * from './buffer/mat2d-buffer';\nexport * from './buffer/typed-array';\nexport * from './buffer/vec2-buffer';\nexport * from './drawable/drawable';\nexport * from './model/mesh';\nexport * from './model/polygon-mesh';\nexport * from './program/program-util';\nexport * from './program/program';\nexport * from './program/fill-program';\nexport * from './model/model';\nexport * from './model/polygon-model';\nexport * from './model/ellipse-model';\nexport * from './event/screen-point';\nexport * from './rendering/camera';\nexport * from './rendering/renderer';\nexport * from './rendering/surface';\nexport * from './event/pointer-event';\nexport * from './event/wheel-event';\nexport * from './tool/stroke';\nexport * from './tool/wheel-zoom-tool';\nexport * from './tool/pan-tool';\nexport * from './tool/pinch-zoom-tool';","import { Mat2d, Rect, Renderer, PolygonModel, Point, Vec2 } from '..';\nimport { EllipseProgram } from '../program/ellipse-program';\n\nexport class EllipseModel extends PolygonModel {\n\n    /**\n     * Measures the boundaries of a unit circle transformed to an ellipse by the specified matrix.\n     * @param matrix the transformation matrix.\n     */\n    static measureBoundaries(matrix: Mat2d.Like): Rect {\n        // Performs singular value decomposition of the model matrix to extract\n        // (1) The length of the semi-x axis (sx), which is equal to the first singular value in the Sigma matrix\n        // (2) The length of the semi-y axis (sy), which is equal to the second singular value in the Sigma matrix\n        // (3) The rotation angle (phi), from -PI/2 to PI/2, which is equal to the angle used to form the U matrix\n        // Boundaries are then meausure with the formula:\n        // x = (sx)^2 * (cos(phi)^2) + (sy)^2*(sin(phi)^2)\n        // y = (sx)^2 * (sin(phi)^2) + (sy)^2*(cos(phi)^2)\n        // left = tx - x, right = tx + x, bottom = ty - y, top = ty + y\n        let { c1r1: a, c2r1: b, c3r1: tx, c1r2: c, c2r2: d, c3r2: ty } = matrix;\n\n        // Helper variables:\n        let a2 = a*a;\n        let b2 = b*b;\n        let c2 = c*c;\n        let d2 = d*d;\n        let m = a*c + b*d;\n        let n = a2 + b2 - c2 - d2;\n\n        // Cos and sin of angle squared:\n        let phi = 0.5 * Math.atan2(2*m, n);\n        let cos2 = Math.pow(Math.cos(phi), 2);\n        let sin2 = Math.pow(Math.sin(phi), 2);\n\n        // Length of axes squared:\n        let s1 = a2 + b2 + c2 + d2;\n        let s2 = Math.sqrt(n*n + 4*m*m);\n        let sx2 = 0.5 * (s1 + s2);\n        let sy2 = 0.5 * (s1 - s2);\n\n        // Boundaries:\n        let x = Math.sqrt(sx2*cos2 + sy2*sin2);\n        let y = Math.sqrt(sx2*sin2 + sy2*cos2);\n        return Rect.copy({ \n            left: tx - x, right: tx + x, \n            top: ty + y, bottom: ty - y \n        });\n    }\n\n    constructor(matrix?: Mat2d.Like) {\n        super(EllipseProgram.mesh, matrix);\n    }\n\n    get bounds(): Rect {\n        return EllipseModel.measureBoundaries(this.matrix);\n    }\n\n    set bounds(dst: Rect) { // Preserves orientation\n        this.transform(Mat2d.rectToRect(this.bounds, dst));\n    }\n\n    /** Checks if this ellipse contains the specified point. */\n    contains(p: Point.Like) {\n        let modelPoint = this.mapPointToModelSpace(p);\n        if(this.mesh.bounds.containsPoint(modelPoint)){\n            return Vec2.length2(modelPoint) <= 1;\n        } \n        return false;\n    }\n}\n","import { Point, Rect, Vec2, Vec2Buffer } from \"..\";\n\n/** Stores static vertex and index data that multiple graphics can share. */\nexport abstract class Mesh {\n\n    public readonly bounds = this.vertices.bounds;\n\n    public miters?: Vec2Buffer;\n\n    /** The byte offset of this mesh's vertex data in a vertex buffer (if any). */\n    public vertexBufferOffset?: number;\n\n    /** The byte offset of this mesh's index data in an element buffer (if any). */\n    public indexBufferOffset?: number;\n\n    /** The byte offset of this mesh's stroke vertex data in a vertex buffer (if any). */\n    public strokeVertexBufferOffset?: number;\n\n    /** The byte offset of this mesh's stroke index data in an element buffer (if any). */\n    public strokeIndexBufferOffset?: number;\n\n    /** The number of indices used to render the stroke (if any). */\n    public strokeIndexCount?: number;\n\n    /** The byte offset of this mesh's miter data in an element buffer (if any). */\n    public miterBufferOffset?: number;\n\n    constructor(\n        /** Vertices in model space, centered at the origin */\n        public readonly vertices: Vec2Buffer,\n        /** Triangle indices for this mesh */\n        public readonly indices?: Uint16Array,\n    ) {}\n\n    /** Checks if this mesh contains the specified point */\n    abstract containsPoint(p: Point.Like): boolean;\n}","import { Drawable, Mat2d, Point, Rect, Vec2, Renderer } from \"..\";\n\n/** A graphic that can be transformed by altering its 2d model matrix. */\nexport abstract class Model {\n\n    constructor(\n        /** 2d matrix that maps this graphic from model space to world space. */\n        public readonly matrix: Mat2d.Like\n    ) {}\n\n    /** \n     * Measures the position of this graphic's center point in world space. \n     * Assumes the model for the graphic is centered at the origin.\n     **/\n    get center(): Point.Like {\n        return { x: this.matrix.c3r1, y: this.matrix.c3r2 };\n    }\n\n    /**\n     * Centers this graphic at the specified point in world space.\n     * Assumes the model for the graphic is centered at the origin.\n     */\n    set center({x, y}: Point.Like) {\n        this.matrix.c3r1 = x;\n        this.matrix.c3r2 = y;\n    }\n\n    /** Measures the boundaries of this graphic in world space. */\n    abstract get bounds(): Rect;\n\n    /** Converts a point in this graphic's model space to a point in world space. */\n    mapPointToWorldSpace(modelPoint: Point.Like, out = <Point.Like> {}) {\n        return Mat2d.mapPoint(this.matrix, modelPoint, out);\n    }\n\n    /** Converts a point in world space to a point in this graphic's model space. */\n    mapPointToModelSpace(worldPoint: Point.Like, out = <Point.Like> {}){\n        return Mat2d.mapPoint(Mat2d.invert(this.matrix), worldPoint, out);\n    }\n\n    /** Checks if this graphic contains the specified point. */\n    abstract containsPoint(p: Point.Like): boolean;\n   \n    /** Transforms this graphic by the specified matrix. */\n    transform(m: Mat2d.Like) {\n        Mat2d.concat(m, this.matrix, this.matrix);\n    }\n\n    /** Translates this graphic by the specified vector. */\n    translate(v: Vec2.Like) {\n        this.transform(Mat2d.translate(v));\n    }\n\n    /** Scales this graphic by the specified vector, with a pivot point at its center.  */\n    scale(v: Vec2.Like){\n        this.transform(Mat2d.pivot(Mat2d.scale(v), this.center));\n    }\n\n    /** Stretches this graphic by the specified factor, with a pivot point at its center. */\n    stretch(factor: number){\n        this.transform(Mat2d.pivot(Mat2d.stretch(factor), this.center))\n    }\n\n    /** Rotates this graphic by the specified angle, with a pivot point at its center. */\n    rotate(radians: number){\n        this.transform(Mat2d.pivot(Mat2d.rotate(radians), this.center));\n    }\n}","import { Point, Mat2d, Vec2, Vec2Buffer, Mesh, Rect } from '..';\n\nexport class PolygonMesh extends Mesh {\n\n    static regularPolygon(n: number, flatTop = false) {\n        return new PolygonMesh(this.regularVertices(n, flatTop), this.regularIndices(n));\n    }\n\n    /**\n     * Generates the vertices for a regular polygon centered at (0,0).\n     * @param n how many sides the polygon should have.\n     * @param isFlatTopped whether the polygon is flat-topped (true) or pointy-topped (false). Defaults to false.\n     */\n    static regularVertices(n: number, flatTop = false) {\n        // Create a buffer large enough to hold the n vertices\n        let vertices = Vec2Buffer.withLength(n);\n        // Create a matrix to rotate from vertex to vertex\n        let angle = 2 * Math.PI / n;\n        let rotation = Mat2d.rotate(angle)\n        // Begin with the vertex (0,1), rotating for flat top polygon if requested\n        let v = vertices.get(0); v.y = 1;\n        if (flatTop) {\n            Mat2d.mapPoint(Mat2d.rotate(angle / 2), v, v);\n        }\n        // Keep rotating the point and adding to buffer till it is full\n        for (let i = 1; i < n; i++) {\n            Mat2d.mapPoint(rotation, vertices.get(i - 1), vertices.at(i));\n        }\n        return vertices;\n    }\n\n    /**\n     * Generates the indices for a regular polygon with n sides.\n     * The resulting index array will have have 3*(n-2) indices.\n     * @param n how many sides the mesh should have.\n     */\n    static regularIndices(n: number) {\n        let indices = new Uint16Array(3 * (n - 2));\n        for (let i = 0; i < n; i++) {\n            indices[3 * i + 1] = i + 1;\n            indices[3 * i + 2] = i + 2;\n        }\n        return indices;\n    }\n\n    /**\n     * Creates the mesh for a rectangle\n     * @param id an optional id for the mesh.\n     */\n    static rectangle(r: Rect) {\n        let vertices = PolygonMesh.rectangleVertices(r);\n        let indices = PolygonMesh.regularIndices(4);\n        return new PolygonMesh(vertices, indices);\n    }\n\n    /**\n      * Extracts the vertices from the specified rect into a new vertex buffer.\n      * @param rect the rect from which to extract the vertices.\n      */\n    static rectangleVertices(r: Rect) {\n        let vertices = Vec2Buffer.withLength(4);\n        r.topLeft(vertices.at(0));\n        r.bottomLeft(vertices.at(1));\n        r.bottomRight(vertices.at(2));\n        r.topRight(vertices.at(3));\n        return vertices;\n    }\n\n    /**\n     * Creates the mesh for a star with n points and the specified inner and outer radii.\n     * @param n how many points the star should have.\n     * @param ratio ratio of the inner radius to the outer radius.\n     */\n    static star(n: number, ratio: number) {\n        let vertices = PolygonMesh.starVertices(n, ratio);\n        let indices = PolygonMesh.starIndices(n);\n        return new PolygonMesh(vertices, indices);\n    }\n\n    /**\n     * Generates the vertices for a star centered at (0,0).\n     * @param points how many points the star should have.\n     * @param ratio ratio of the inner radius to the outer radius.\n     */\n    static starVertices(points: number, ratio: number) {\n        // Create vertex buffer big enough to hold the n inner vertices and n outer vertices\n        let vertices = Vec2Buffer.withLength(points + points);\n        // Calculate the rotation angle\n        let angle = 2 * Math.PI / points;\n        let rotation = Mat2d.rotate(angle);\n        // Start with (0, 1) as the outer vertex\n        vertices.y = 1;\n        // Scale by the specified ratio and rotate by half the angle to get the first inner vertex\n        Mat2d.mapPoint(Mat2d.rotate(0.5 * angle), { x: 0, y: ratio }, vertices.at(1));\n        // Keep rotating the inner and outer vertices and adding them to the buffer until it is full.\n        for (let i = 2; i < vertices.length; i++) {\n            Mat2d.mapPoint(rotation, vertices.get(i - 2), vertices.at(i));\n        }\n        return vertices;\n    }\n\n    /**\n     * Generates the indices for a star with n points.\n     * The star will have 3*(n-2) inner indices and 3n outer indices.\n     * @param n how many points the star should have.\n     */\n    static starIndices(n: number) {\n        // Create an array big enough to hold all the indices\n        let innerIndexCount = 3 * (n - 2);\n        let outerIndexCount = 3 * n;\n        let indices = new Uint16Array(innerIndexCount + outerIndexCount);\n        // Compute inner indices and add to array\n        let first = 1, second = 3, third = 5;\n        for (let i = 0; i < innerIndexCount; second += 2, third += 2) {\n            indices[i++] = first;\n            indices[i++] = second;\n            indices[i++] = third;\n        }\n        // Computer outer indices and add to array\n        first = 2 * n - 1; second = 0; third = 1;\n        for (let i = 0; i < outerIndexCount; i++, first = third++, second = third++) {\n            indices[i++] = first;\n            indices[i++] = second;\n            indices[i++] = third;\n        }\n        // Return the indices\n        return indices;\n    }\n\n    static miters(vertices: Vec2Buffer){\n        let length = vertices.length, lastIndex = length - 1;\n        let miters = Vec2Buffer.withLength(length);\n        let prev = Vec2.copy(vertices.at(lastIndex));\n        let curr = Vec2.copy(vertices.at(0));\n        let line1 = Vec2.fromPointToPoint(prev, curr);\n        let line2 = <Vec2.Like> {};\n        for (let i = 0; i < length; i++) {\n            Vec2.copy(curr, prev);\n            Vec2.copy(vertices.at((i + 1) % lastIndex), curr);\n            Vec2.fromPointToPoint(prev, curr, line2);\n            Vec2.miter(line1, line2, 1, 3, miters.at(i));\n            Vec2.copy(line2, line1);\n        }\n        return miters;\n    }\n\n    public readonly miters = PolygonMesh.miters(this.vertices);\n\n    containsPoint(p: Point.Like): boolean {\n        return this.vertices.containsPoint(p);\n    }\n}\n\n","import { Model, Mesh, Mat2d, Rect, Point, LineSegment, Vec2 } from \"..\";\n\n/** Shape defined by matrix transformation of a mesh. */\nexport class PolygonModel extends Model {\n    \n    /**\n     * Creates a shape with the specified mesh data and initial transformation matrix.\n     * @param mesh the static vertex and index data data for this shape.\n     * @param matrix the initial transformation matrix. Defaults to identiy.\n     */\n    constructor(\n        public readonly mesh: Mesh, matrix = Mat2d.identity()){\n        super(matrix);\n    }\n\n    get bounds(): Rect {\n        let { vertices } = this.mesh;\n        let { x, y } = this.mapPointToWorldSpace(vertices.at(0));\n        let bounds = Rect.dimensions(x, y, 0, 0);\n        for (let i = 1; i < vertices.length; i++) {\n            bounds.unionPoint(this.mapPointToWorldSpace(vertices.at(i)));\n        }\n        return bounds;\n    }\n\n    set bounds(dst: Rect) { // Preserves orientation\n        this.transform(Mat2d.rectToRect(this.bounds, dst));\n    }\n\n    /** Get the position of the vertex at the specified index */\n    vertexAt(index: number, out = <Vec2.Like> {}) {\n        return this.mapPointToWorldSpace(this.mesh.vertices.at(index), out);\n    }\n\n    containsPoint(p: Point.Like): boolean {\n        return this.mesh.containsPoint(this.mapPointToModelSpace(p));\n    }\n\n    /** Scales this shape to fit inside the destination rect using the specified scale to fit option */\n    scaleToFit(dst: Rect, stf = Mat2d.ScaleToFit.Fill) {\n        Mat2d.rectToRect(this.mesh.bounds, dst, stf, this.matrix);\n    }\n\n    /** Stretch-rotates this shape across the specified line segment */\n    stretchAcross({p1, p2}: LineSegment) {\n        // Translate center top to p1\n        let b = this.mesh.bounds;\n        let cx = b.centerX;\n        let v = Vec2.fromPointToPoint({ x: cx, y: b.top }, p1);\n        let t = Mat2d.translate(v, this.matrix);\n        \n        // Stretch rotate from (translated) center bottom to p2, with pivot point at p1\n        let c = Mat2d.mapPoint(t, {x: cx, y: b.bottom});\n        let s = Mat2d.stretchRotateToPoint(c, p2, p1);\n        this.transform(s);\n    }\n}","import { ColorfBuffer, Mat2dBuffer, Program, ProgramUtil, PolygonMesh, Rect, Renderer } from '..';\nimport * as Shader from '../shader/ellipse'\n\n/** Program for rendering ellipses. */\nexport class EllipseProgram extends Program<Shader.Uniforms, Shader.Attributes> {\n\n    static readonly mesh = PolygonMesh.rectangle(Rect.dimensions(-1, 1, 2, 2));\n\n    private positionBuffer: WebGLBuffer;\n    private matrixBuffer: WebGLBuffer;\n\n    public fillColor: ColorfBuffer;\n    public strokeColor: ColorfBuffer;\n    public lineWidth: number;\n    \n    static create(util: ProgramUtil) {\n        let program = new EllipseProgram;\n        program.location = util.createProgramFromSources(Shader.vertex, Shader.fragment);\n        program.uniforms = util.getUniformLocationMap(program.location, Shader.uniformRenaming) as Shader.Uniforms;\n        program.attribs = util.getAttributeLocationMap(program.location, Shader.attributeRenaming) as Shader.Attributes;\n        program.positionBuffer = util.createArrayBuffer(EllipseProgram.mesh.vertices.data);\n        program.matrixBuffer = util.createBuffer();\n        return program;\n    }\n\n    onAttach({gl, angleExt}: Renderer) {\n        let c1 = this.attribs.model;\n        let c2 = c1 + 1;\n        let c3 = this.attribs.offset;\n\n        // Enable blending (for transparency)\n        gl.enable(gl.BLEND);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n        gl.enableVertexAttribArray(this.attribs.position);\n        gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 0, 0);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.matrixBuffer);\n\n        gl.enableVertexAttribArray(c1);\n        gl.enableVertexAttribArray(c2);\n        gl.enableVertexAttribArray(c3);\n        \n        angleExt.vertexAttribDivisorANGLE(c1, 1);\n        angleExt.vertexAttribDivisorANGLE(c2, 1);\n        angleExt.vertexAttribDivisorANGLE(c3, 1);\n    }\n\n    onDetach({angleExt}: Renderer) {\n        let c1 = this.attribs.model;\n        let c2 = c1 + 1;\n        let c3 = this.attribs.offset;\n\n        angleExt.vertexAttribDivisorANGLE(c1, 0);\n        angleExt.vertexAttribDivisorANGLE(c2, 0);\n        angleExt.vertexAttribDivisorANGLE(c3, 0);       \n    }\n\n    draw(renderer: Renderer, matrices: Mat2dBuffer) {\n        let {gl, angleExt, camera } = renderer;\n        renderer.useProgram(this);\n        this.loadProjection(gl, camera.matrix);\n        this.loadMatrices(gl, matrices);\n        this.loadFillColor(gl);\n        this.loadStrokeColor(gl);\n        this.loadLineWidth(gl);\n        angleExt.drawArraysInstancedANGLE(gl.TRIANGLE_FAN, 0, 4, matrices.length);\n    }\n\n    private loadProjection(gl: WebGLRenderingContext, projection: Float32Array) {\n        gl.uniformMatrix4fv(this.uniforms.projection, false, projection);\n    }\n\n    /** Sets the matrix for each ellipse instance.*/\n    private loadMatrices(gl: WebGLRenderingContext, matrices: Mat2dBuffer) {\n        // Note: assumes \n        // (1) matrix buffer is already bound\n        // (2) attrib arrays are already enabled\n        // (3) attrib divisors have already been specified\n        let c1 = this.attribs.model;\n        let c2 = c1 + 1;\n        let c3 = this.attribs.offset;\n        \n        // Load data into WebGL\n        gl.bufferData(gl.ARRAY_BUFFER, matrices.data, gl.DYNAMIC_DRAW);\n\n        // Set first column vector (part of mat2)\n        gl.vertexAttribPointer(c1, 2, gl.FLOAT, false, 24, 0);\n        \n        // Set second column vector (part of mat2)\n        gl.vertexAttribPointer(c2, 2, gl.FLOAT, false, 24, 8);\n\n        // Set third column vector (separate vec2)\n        gl.vertexAttribPointer(c3, 2, gl.FLOAT, false, 24, 16);\n    }\n\n    /** Loads the fill color for the ellipse batch into this program. */\n    private loadFillColor(gl: WebGLRenderingContext) {\n        gl.uniform4fv(this.uniforms.fillColor, this.fillColor.data);\n    }\n\n    /** Loads the stroke color for the ellipse batch into this program. */\n    private loadStrokeColor(gl: WebGLRenderingContext) {\n        gl.uniform4fv(this.uniforms.strokeColor, this.strokeColor.data);\n    }\n\n    /** Loads the width of the lines making up the stroke. */\n    private loadLineWidth(gl: WebGLRenderingContext) {\n        gl.uniform1f(this.uniforms.lineWidth, this.lineWidth);\n    }\n}","import { Program, ColorfBuffer, Mesh, Renderer, ProgramUtil, Mat2dBuffer, Vec2Buffer } from \"..\";\nimport * as Shader from '../shader/fill'\n\n/**  Program for rendering polygons filled with a uniform color. */\nexport class FillProgram extends Program<Shader.Uniforms, Shader.Attributes> {\n\n    public color: ColorfBuffer;\n\n    private indexBuffer: WebGLBuffer;\n    private positionBuffer: WebGLBuffer;\n    private matrixBuffer: WebGLBuffer;\n    private dynamicBuffer: WebGLBuffer;\n    \n    static create(util: ProgramUtil, meshes: Mesh[]) {\n        let program = new FillProgram;\n        program.location = util.createProgramFromSources(Shader.vertex, Shader.fragment);\n        program.uniforms = util.getUniformLocationMap(program.location, Shader.uniformRenaming) as Shader.Uniforms;\n        program.attribs = util.getAttributeLocationMap(program.location, Shader.attributeRenaming) as Shader.Attributes;\n        program.indexBuffer = util.createIndexBuffer(meshes);\n        program.positionBuffer = util.createVertexBuffer(meshes);\n        program.matrixBuffer = util.createBuffer();\n        program.dynamicBuffer = util.createBuffer();\n        return program;\n    }\n\n    onAttach({ gl, angleExt }: Renderer) {\n        let column1 = this.attribs.model;\n        let column2 = column1 + 1;\n        let column3 = this.attribs.offset;\n\n        gl.enable(gl.BLEND);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.enableVertexAttribArray(this.attribs.position);\n\n        // Enable a separate array for each column of the 3x2 model matrix\n        gl.enableVertexAttribArray(column1);\n        gl.enableVertexAttribArray(column2); \n        gl.enableVertexAttribArray(column3);\n        \n        // Only change the model matrix when the instance changes\n        angleExt.vertexAttribDivisorANGLE(column1, 1); \n        angleExt.vertexAttribDivisorANGLE(column2, 1);\n        angleExt.vertexAttribDivisorANGLE(column3, 1);\n    }\n\n    onDetach({angleExt}: Renderer){\n        let column1 = this.attribs.model;\n        let column2 = column1 + 1;\n        let column3 = this.attribs.offset;\n\n        // Disable instancing of 3x2 model matrix (because it affects global state)\n        angleExt.vertexAttribDivisorANGLE(column1, 0);\n        angleExt.vertexAttribDivisorANGLE(column2, 0);\n        angleExt.vertexAttribDivisorANGLE(column3, 0);    \n    }\n\n    draw(renderer: Renderer, mesh: Mesh, matrices: Mat2dBuffer) {\n        let {gl, angleExt} = renderer;\n        renderer.useProgram(this);\n        this.loadProjection(gl, renderer.camera.matrix);\n        this.loadColor(gl);\n        this.loadVertices(gl, mesh);\n        this.loadMatrices(gl, matrices);\n        if (mesh.indices) {\n            angleExt.drawElementsInstancedANGLE(gl.TRIANGLES, mesh.indices.length, gl.UNSIGNED_SHORT, mesh.indexBufferOffset, matrices.length)\n        } else {\n            angleExt.drawArraysInstancedANGLE(gl.TRIANGLES, 0, mesh.vertices.length, matrices.length);\n        }\n    }\n\n    drawTriangleStrip(renderer: Renderer, vertices: Vec2Buffer, matrices: Mat2dBuffer) {\n        let { gl, angleExt } = renderer;\n        renderer.useProgram(this);\n        this.loadProjection(gl, renderer.camera.matrix);\n        this.loadColor(gl);\n        this.loadLineVertices(gl, vertices);\n        this.loadMatrices(gl, matrices);\n        angleExt.drawArraysInstancedANGLE(gl.TRIANGLE_STRIP, 0, vertices.length, matrices.length);\n    }\n\n    private loadProjection(gl: WebGLRenderingContext, projection: Float32Array) {\n        gl.uniformMatrix4fv(this.uniforms.projection, false, projection);\n    }\n\n    /** Loads the fill color into this program. */\n    private loadColor(gl: WebGLRenderingContext) {\n        gl.uniform4fv(this.uniforms.color, this.color.data);\n    }\n\n    private loadVertices(gl: WebGLRenderingContext, mesh: Mesh) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n        gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 0, mesh.vertexBufferOffset);\n    }\n\n    private loadLineVertices(gl: WebGLRenderingContext, vertices: Vec2Buffer) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, vertices.data, gl.DYNAMIC_DRAW);\n        gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 0, 0);\n    }\n\n    /** Sets the matrix for each ellipse instance.*/\n    private loadMatrices(gl: WebGLRenderingContext, matrices: Mat2dBuffer) {\n        let column1 = this.attribs.model;\n        let column2 = column1 + 1;\n        let column3 = this.attribs.offset;\n\n        // Load data into WebGL\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.matrixBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, matrices.data, gl.DYNAMIC_DRAW);\n\n        // Set each column of the 3x2 model matrix\n        gl.vertexAttribPointer(column1, 2, gl.FLOAT, false, 24, 0);\n        gl.vertexAttribPointer(column2, 2, gl.FLOAT, false, 24, 8);\n        gl.vertexAttribPointer(column3, 2, gl.FLOAT, false, 24, 16);\n    }\n}\n","import { AttributeLocationMap, UniformLocationMap, Mesh, TypedArray } from \"..\";\n\nexport type ArraySize = number | BufferSource;\nexport type ElementArraySize = number | ArrayBuffer | Uint8Array | Uint16Array;\n\n/** Maps the name of a uniform or attribute to it's minified renaming. */\nexport interface Renaming {\n    [key: string]: string;\n}\n\n/** Contains convenience functions for creating programs and loading data into them. */\nexport class ProgramUtil {\n\n    constructor(public gl: WebGLRenderingContext) { }\n\n    createBuffer() {\n        return this.gl.createBuffer();\n    }\n\n    /**\n     * Creates an array buffer with the specified size.\n     * @param size the size of the array buffer, or the initial data for the buffer.\n     * @param usage one of gl.STATIC_DRAW (often used, seldom changed), gl.DYNAMIC_DRAW (often used, often changed), or gl.STREAM_DRAW (seldom used).\n     */\n    createArrayBuffer(size: ArraySize, usage = this.gl.STATIC_DRAW) {\n        let gl = this.gl, buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, <any>size, usage);\n        return buffer;\n    }\n\n    /**\n     * Creates an element buffer with the specified size.\n     * @param size the size of the element buffer, or the initial data for the buffer.\n     * @param usage one of gl.STATIC_DRAW (often used, seldom changed), gl.DYNAMIC_DRAW (often used, often changed), or gl.STREAM_DRAW (seldom used).\n     */\n    createElementBuffer(size: ElementArraySize, usage = this.gl.STATIC_DRAW) {\n        let gl = this.gl, buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, <any>size, usage);\n        return buffer;\n    }\n\n    /** Packs mesh vertices into a single vertex buffer, saving the offsets. */\n    createVertexBuffer(meshes: Mesh[]) {\n        // Create an array buffer big enough to hold all the vertices\n        let gl = this.gl;\n        let size = this.sizeOfVertexBuffer(meshes);\n        let buffer = this.createArrayBuffer(size, gl.STATIC_DRAW);\n\n        // Pack the vertices into the buffer, saving the byte offsets\n        let offset = 0;\n        for (let mesh of meshes) {\n            let data = mesh.vertices.data;\n            gl.bufferSubData(gl.ARRAY_BUFFER, offset, data);\n            mesh.vertexBufferOffset = offset;\n            offset += data.byteLength;\n        }\n\n        return buffer;\n    }\n\n    private sizeOfVertexBuffer(meshes: Mesh[]) {\n        return meshes.reduce((total: number, mesh: Mesh) => total + mesh.vertices.data.byteLength, 0);\n    }\n\n    /** Packs mesh indices into a single buffer, saving the offsets. */\n    createIndexBuffer(meshes: Mesh[]) {\n\n        // Create an array buffer big enough to hold all the indices\n        let gl = this.gl;\n        let size = this.sizeOfIndexBuffer(meshes)\n        let buffer = this.createElementBuffer(size, gl.STATIC_DRAW);\n\n        // Pack the indices into the buffer, saving the byte offsets\n        let offset = 0;\n        for (let mesh of meshes) {\n            let data = mesh.indices;\n            gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, offset, data);\n            mesh.indexBufferOffset = offset;\n            offset += data.byteLength;\n        }\n\n        return buffer;\n    }\n\n    private sizeOfIndexBuffer(meshes: Mesh[]) {\n        return meshes.reduce((total: number, mesh: Mesh) => total + mesh.indices.byteLength, 0);\n    }\n\n    createMiterBuffer(meshes: Mesh[]) {\n        // Create an array buffer big enough to hold all the miters, including the \"zero\" miters used on the inner vertices\n        let gl = this.gl;\n        let size = this.sizeOfStrokeVertexBuffer(meshes);\n        let buffer = this.createArrayBuffer(size);\n\n        // Pack the vertices into the buffer, saving the byte offsets\n        let offset = 0;\n        let data: Float32Array;\n        for (let mesh of meshes) {\n            mesh.miterBufferOffset = offset;\n            offset += mesh.vertices.data.byteLength; // leave zeros for miters applied to inner vertices\n            data = mesh.miters.data;\n            gl.bufferSubData(gl.ARRAY_BUFFER, offset, data);\n            offset += data.byteLength; \n        }\n\n        return buffer;\n    }\n\n    createStrokeIndexBuffer(meshes: Mesh[]) {\n        // Ex: Let polygon p = [v0,v1,v2]\n        // -> indexCount =  2 * (p.length + 1) = 2 * 2 * (3 + 1) = 8\n        // -> indices = [[0,3], [1,4], [2,5], [0,3]]\n        // -> size = sizeof(short) * indexCount = 2 bytes * 8 = 16 bytes\n\n        // Create a Uint16Array big enough to hold all the indices\n        let indexCount = this.lengthOfStrokeIndexArray(meshes);\n        let indices = new Uint16Array(indexCount);\n        let position = 0;\n\n        for(let mesh of meshes){\n            let vertexCount = mesh.vertices.length; \n            mesh.strokeIndexCount = 2 * (vertexCount + 1);\n            mesh.strokeIndexBufferOffset = position * 2; // sizeof(short)\n            // Line to each point on path\n            for(let i = 0; i < vertexCount; i++){\n                indices[position++] = i + vertexCount;\n                indices[position++] = i;\n            }\n            // Close path\n            indices[position++] = vertexCount;\n            indices[position++] = 0;\n        }\n\n        return this.createElementBuffer(indices, this.gl.STATIC_DRAW);\n    }\n\n    private lengthOfStrokeIndexArray(meshes: Mesh[]) {\n        return meshes.reduce((total: number, mesh: Mesh) => total + (2 * (mesh.vertices.length + 1)), 0);\n    }\n\n    createStrokeVertexBuffer(meshes: Mesh[]){\n        // Create an array buffer big enough to hold all the vertices and all the miters\n        let gl = this.gl;\n        let size = this.sizeOfStrokeVertexBuffer(meshes);\n        let buffer = this.createArrayBuffer(size);\n\n        // Pack the vertices into the buffer, saving the byte offsets\n        let offset = 0;\n        for (let mesh of meshes) {\n            // Inner vertices (will be offset by a \"zero\" miter)\n            let data = mesh.vertices.data;\n            gl.bufferSubData(gl.ARRAY_BUFFER, offset, data);\n            mesh.strokeVertexBufferOffset = offset;\n            // Outer vertices (will be offset by miter)\n            offset += data.byteLength;\n            gl.bufferSubData(gl.ARRAY_BUFFER, offset, data);\n            offset += data.byteLength;\n        }\n\n        return buffer;\n    }\n\n    private sizeOfStrokeVertexBuffer(meshes: Mesh[]) {\n        let innerVertexSize = this.sizeOfStrokeVertexBuffer(meshes);\n        let outerVertexSize = meshes.reduce((total: number, m: Mesh) => total + m.miters.data.byteLength, 0);\n        return innerVertexSize + outerVertexSize;\n    }\n\n    /**\n     * Creates a program from 2 shaders.\n     * @param  vertexShaderSource string containing code for the vertex shader.\n     * @param  fragmentShaderSource string containing code for the fragment shader.\n     * @returns the program.\n     */\n    createProgramFromSources(vertexShaderSource: string, fragmentShaderSource: string) {\n        // Compile vertex and fragment shader\n        let vs = this.compileShader(vertexShaderSource, this.gl.VERTEX_SHADER);\n        let fs = this.compileShader(fragmentShaderSource, this.gl.FRAGMENT_SHADER);\n        // Create program and return\n        return this.createProgramFromShaders(vs, fs);\n    };\n\n    /**\n     * Creates a program from 2 shaders.\n     * @param  vertexShader a compiled vertex shader.\n     * @param  fragmentShader a compiled fragment shader.\n     * @returns the program.\n     */\n    createProgramFromShaders(vertexShader: WebGLShader, fragmentShader: WebGLShader) {\n        // create a program.\n        let gl = this.gl, program = gl.createProgram();\n\n        // attach the shaders.\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n\n        // link the program.\n        gl.linkProgram(program);\n\n        // Check if it linked.\n        var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n        if (!success) {\n            // something went wrong with the link\n            throw (\"program filed to link:\" + gl.getProgramInfoLog(program));\n        }\n\n        return program;\n    };\n\n    /**\n     * Creates and compiles a shader.\n     * @param shaderSource the GLSL source code for the shader.\n     * @param shaderType the type of shader, VERTEX_SHADER or FRAGMENT_SHADER.\n     * @returns the shader.\n     */\n    compileShader(shaderSource: string, shaderType: number) {\n        // Create the shader object\n        let gl = this.gl, shader = gl.createShader(shaderType);\n\n        // Set the shader source code.\n        gl.shaderSource(shader, shaderSource);\n\n        // Compile the shader\n        gl.compileShader(shader);\n\n        // Check if it compiled\n        var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n        if (!success) {\n            // Something went wrong during compilation; get the error\n            throw \"could not compile shader:\" + gl.getShaderInfoLog(shader);\n        }\n\n        return shader;\n    }\n\n    /** Gets the location of each of the uniforms associated with the specified program. */\n    getUniformLocationMap(program: WebGLProgram, renamed?: Renaming) {\n        let gl = this.gl, uniforms = <UniformLocationMap>{};\n        if (renamed) {\n            for (let name in renamed) {\n                uniforms[name] = gl.getUniformLocation(program, renamed[name]);\n            }\n        } else {\n            let count = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n            for (let i = 0; i < count; i++) {\n                let { name } = gl.getActiveUniform(program, i);\n                uniforms[name] = gl.getUniformLocation(program, name);\n            }\n        }\n        return uniforms;\n    }\n\n    /** Gets the location of each of the attributes associated with the specified program. */\n    getAttributeLocationMap(program: WebGLProgram, renamed?: Renaming) {\n        let gl = this.gl, attribs = <AttributeLocationMap>{};\n        if (renamed) {\n            for (let name in renamed) {\n                attribs[name] = gl.getAttribLocation(program, renamed[name]);\n            }\n        } else {\n            let count = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n            for (let i = 0; i < count; i++) {\n                let { name } = gl.getActiveAttrib(program, i);\n                attribs[name] = gl.getAttribLocation(program, name);\n            }\n        }\n        return attribs;\n    }\n}\n","import { Renderer } from '..';\n\n/** Maps the name of a uniform to its location in a WebGL program. */\nexport interface UniformLocationMap {\n    [key: string]: WebGLUniformLocation;\n}\n\n/** Maps the name of an attribute to its location in a WebGL program. */\nexport interface AttributeLocationMap {\n    [key: string]: number;\n}\n\nexport abstract class Program<U = UniformLocationMap, A = AttributeLocationMap> {\n\n    /** The location of this program in WebGL. */\n    location: WebGLProgram;\n\n    /** The locations of the uniforms associated with this program, keyed by the uniform name. */\n    uniforms: U;\n\n    /** The locations of the attributes associated with this program, keyed by the attribute name. */\n    attribs: A;\n\n    /** Called whenever this program is attached to the renderer. */\n    abstract onAttach(renderer: Renderer): any;\n\n    /** Called whenever this program is detached from the renderer. */\n    abstract onDetach(renderer: Renderer): any;\n}\n","import { Rect, Vec2, Mat4, Mat2d, Point } from '..';\n\n/** Defines an orthographic projection from world space to clip space. */\nexport class Camera {\n\n    /** The orthographic projection matrix that puts the world in view. */\n    public readonly matrix = new Float32Array(16);\n\n    /** The area of the world that is currently in view. */\n    public readonly view = Rect.copy(this.world);\n\n    /** The current position of the camera in relation to the center of the world. */\n    public readonly position = this.world.center();\n\n    /** The current zoom setting for this camera. */\n    public zoom = 1;\n\n    constructor(\n        /** The area that can be viewed by this camera */\n        public readonly world: Rect,\n        /** The min-allowed zoom setting for this camera. */\n        public readonly minZoom: number,\n        /** The max-allowed zoom setting for this camera. */\n        public readonly maxZoom: number\n    ) {}\n\n    /**\n     * Sets the size of the viewport in which the camera image will be displayed.\n     * The resulting image will be centered inside the viewport and will match the aspect of the camera. \n     * @param vw the new width of the viewport.\n     * @param vh the new height of the viewport.\n     */\n    setViewport(vw: number, vh: number) {\n        // Compute width to height ratio of viewport and world\n        let vr = vw / vh, wr = this.world.aspect;\n        // Scale width or height of view to match aspect of viewport\n        let m = Mat2d.scale(wr < vr ? {x: vr / wr, y: 1} : {x: 1, y: wr / vr});\n        // Apply our other camera settings on top\n        Mat2d.concat(Mat2d.stretch(1 / this.zoom), m, m);\n        Mat2d.concat(Mat2d.translate(this.position), m, m);\n        Mat2d.mapRect(m, this.world, this.view);\n        // Update matrix to reflect changes to view\n        this.updateMatrix();\n    }\n\n    /**\n     * Sends a request to offset this camera by the desired vector.\n     * Note: the desired offset may be adjusted to keep the camera from viewing anything outside of the world area.\n     * @param desiredOffset the desired offset. \n     * @returns the actual offset.\n     */\n    offset(desiredOffset: Vec2.Like) {\n        let target = Vec2.add(desiredOffset, this.position);\n        let ratio = (this.zoom - this.minZoom) / this.zoom;\n        let size = Mat2d.mapRect(Mat2d.stretch(ratio), this.world); // Max allowable size given zoom\n        let far = Rect.copy(size); far.offset(Vec2.rotate180(size.center())); // Center at origin so we know how far we can go in any direction\n\n        let actualOffset = Vec2.copy(desiredOffset);\n        // If world position is too far left\n        if (target.x < far.left) {\n            // Adjust offset so that offset.x + position.x = far.left\n            actualOffset.x = far.left - this.position.x;\n        }\n        // If world position is too far right\n        else if (target.x > far.right) {\n            // Adjust offset so that offset.x + position.x = far.right\n            actualOffset.x = far.right - this.position.x;\n        }\n        // If world position is too far down\n        if (target.y < far.bottom) {\n            // Adjust offset so that offset.y + position.y = far.bottom\n            actualOffset.y = far.bottom - this.position.y;\n        }\n        // If world position is too far up\n        else if (target.y > far.top) {\n            // Adjust offset so that offset.y + position.y = far.top\n            actualOffset.y = far.top - this.position.y;\n        }\n\n        // Now we can safely apply the offset\n        this.view.offset(actualOffset);\n        Vec2.add(this.position, actualOffset, this.position);\n        this.updateMatrix();\n        return actualOffset;\n    }\n\n    /**\n     * Sends a request to zoom in this camera by the desired scale factor.\n     * Note: the desired scale factor is automatically adjusted to keep the camera from viewing anything outside of the world area. \n     * @param desiredScaleFactor the desired scale factor.\n     * @returns the actual scale factor.\n     */\n    zoomIn(desiredScaleFactor: number) {\n        let targetZoom = this.zoom * desiredScaleFactor;\n        let actualScaleFactor: number;\n        if (targetZoom < this.minZoom) {\n            // Adjust scale factor so that zoom * changeInZoom = minZoom\n            actualScaleFactor = this.minZoom / this.zoom;\n            this.zoom = this.minZoom;\n        } else if (targetZoom > this.maxZoom) {\n            // Adjust scale factor so that zoom * changeInZoom = maxZoom\n            actualScaleFactor = this.maxZoom / this.zoom;\n            this.zoom = this.maxZoom;\n        } else {\n            // No need to adjust scale factor\n            actualScaleFactor = desiredScaleFactor;\n            this.zoom = targetZoom;\n        }\n        let m = Mat2d.pivot(Mat2d.stretch(1 / actualScaleFactor), this.position);\n        Mat2d.mapRect(m, this.view, this.view);\n        this.updateMatrix();\n        return actualScaleFactor;\n    }\n\n    /**\n     * Sends a request to zoom this camera by the desired scale factor.\n     * Note: the desired scale factor is automatically adjusted to keep the camera from viewing anything outside of the world area. \n     * @param desired the desired scale factor.\n     * @param focus the focus point. \n     * @returns the actual scale factor and offset.\n     */\n    zoomToPoint(desiredScaleFactor: number, focus: Point.Like) {\n        let view = this.view\n        // Convert (x,y) coordinates to [0,1] space\n        let normX = (focus.x - view.left) / view.width;\n        let normY = (focus.y - view.bottom) / view.height;\n        // Apply scale factor\n        let actualScaleFactor = this.zoomIn(desiredScaleFactor);\n        // Determine position of focus point after change in zoom\n        let aft: Vec2.Like = {\n            x: view.left + (normX * view.width),\n            y: view.bottom + (normY * view.height)\n        }\n        // Compute offset back to focus point\n        let offset = Vec2.fromPointToPoint(aft, focus);\n        // Apply the offset\n        let actualOffset = this.offset(offset);\n        // Return actual scale factor and offset so caller can check if they differ from desired\n        return {scale: actualScaleFactor, offset: actualOffset};\n    }\n\n    /** Recalculates the projection matrix to reflect changes in the camera settings.*/\n    private updateMatrix() {\n        Mat4.ortho(this.view, 0.1, 10, this.matrix);\n    }\n}","import { Camera, Program } from '..';\n\n/** Helper class for rendering graphics with WebGL. */\nexport class Renderer {\n\n    public readonly angleExt = this.gl.getExtension('ANGLE_instanced_arrays');\n\n    /** The location of the currently bound program. */\n    private currentProgram: Program;\n\n    constructor(\n        public readonly gl: WebGLRenderingContext, \n        public readonly camera: Camera,\n    ) {}\n\n    /**\n     * Called whenever the canvas size changes.\n     * @param width the new width of the canvas.\n     * @param height the new height of the canvas.\n     */\n    onSurfaceChange(width: number, height: number) {\n        // Update the viewport to match the new dimensions of the drawing buffer\n        this.gl.viewport(0, 0, width, height);\n        // Adjust camera to viewport\n        this.camera.setViewport(width, height);\n    }\n\n    /** Binds the specified program to the WebGL rendering context, if not already bound. */\n    useProgram(program: Program) {\n        if (this.currentProgram !== program) {\n            this.attachProgram(program);\n        }\n    }\n\n    private attachProgram(program: Program) {\n        this.gl.useProgram(program.location);\n        // Notify detached program\n        if(this.currentProgram){ this.currentProgram.onDetach(this); }\n        // Notify attached program\n        program.onAttach(this);\n        // Keep track of the current program\n        this.currentProgram = program;\n    }\n};","import { Drawable, Point, Renderer, Rect, Vec2, ScreenPoint, PointerEventListener } from '..';\nimport { PointerEventDetector } from '../event/pointer-event';\nimport { WheelEventDetector } from '../event/wheel-event';\n\n/** A rendering surface linked to an HTMLCanvasElement (the drawing buffer). */\nexport class Surface {\n\n    /** The drawing buffer's bounding client rect. */\n    clientRect = this.canvasEl.getBoundingClientRect();\n\n    /*** True if a request has been made to re-render this surface. */\n    hasRenderRequest = false;\n\n    constructor(\n        public readonly canvasEl: HTMLCanvasElement, \n        public readonly renderer: Renderer,\n        public readonly scene: Drawable\n    ) {}\n\n    startRenderLoop() {\n        this.requestRender();\n        this.checkRender();\n    }\n\n    /** Checks each frame if the surface needs to be re-rendered. */\n    private checkRender = () => {\n        // Resize surface if necessary\n        this.resize()\n        // Notify surface of animation frame\n        this.onAnimationFrame()\n        // Keep calling this function every frame\n        requestAnimationFrame(this.checkRender);\n    }\n\n    /**\n     * Requests that this surface be re-rendered.\n     */\n    requestRender() {\n        this.hasRenderRequest = true;\n    }\n\n    /**\n     * Re-renders this surface if it has a render request.\n     */\n    onAnimationFrame() {\n        if(this.hasRenderRequest){\n            this.scene.draw(this.renderer);\n            this.hasRenderRequest = false;\n        }\n    }\n\n    /** Resizes this surface to match the specified width/height dimensions. */\n    resize(width = this.canvasEl.clientWidth, height = this.canvasEl.clientHeight) {\n        // If width or height has changed\n        if (this.canvasEl.width !== width || this.canvasEl.height !== height) {\n            // Resize canvas to specified dimensions\n            this.canvasEl.width = width;\n            this.canvasEl.height = height;\n            // Get new bounding box\n            this.clientRect = this.canvasEl.getBoundingClientRect();\n            // Notify renderer of surface change\n            this.renderer.onSurfaceChange(width, height);\n            // Request render to show changes\n            this.requestRender();\n        }\n    }\n\n    startDetectingPointerEvents() {\n        let detector = new PointerEventDetector(this);\n        detector.startListening();\n        return detector;\n    }\n\n    startDetectingWheelEvents() {\n        let detector = new WheelEventDetector(this);\n        detector.startListening();\n        return detector;\n    }\n\n    /** Sends a request to pan the image displayed by this surface. */\n    pan(desiredOffset: Vec2.Like) {\n        let camera = this.renderer.camera;\n        let actual = camera.offset(desiredOffset);\n        if (Vec2.length2(actual) != 0) {\n            this.requestRender();\n        }\n        return actual;\n    }\n\n    /** Sends a request to zoom into the image displayed by this surface. */\n    zoomIn(desiredScaleFactor: number){\n        let camera = this.renderer.camera;\n        let actual = camera.zoomIn(desiredScaleFactor);\n        if(actual != 1){\n            this.requestRender();\n        }\n    }\n\n    /** Sends a request to zoom out of the image displayed by this surface. */\n    zoomOut(desiredScaleFactor: number){\n        this.zoomIn(1/desiredScaleFactor);\n    }\n\n    /** Sends a request to zoom into the image displayed by this surface while fixing the specified focus point. */\n    zoomToPoint(desiredScaleFactor: number, focus: Point.Like) {\n        let camera = this.renderer.camera;\n        let actual = camera.zoomToPoint(desiredScaleFactor, focus);\n        if(actual.scale != 1 || Vec2.length2(actual.offset) != 0){\n            this.requestRender();\n        }\n        return actual;\n    }\n\n    /** Maps a screen point to canvas space. */\n    mapScreenPointToCanvas(screenPoint: ScreenPoint): Point.Like {\n        return {\n            x: screenPoint.clientX - this.clientRect.left,\n            y: screenPoint.clientY - this.clientRect.top\n        };\n    }\n\n    /** Maps a screen point to NDC space [0,1].*/\n    mapScreenPointToNdc(screenPoint: ScreenPoint) {\n        return this.mapCanvasPointToNdc(this.mapScreenPointToCanvas(screenPoint));\n    }\n\n    /** Maps a screen point to clip space. */\n    mapScreenPointToWorld(screenPoint: ScreenPoint) {\n        return this.mapNdcToWorld(this.mapScreenPointToNdc(screenPoint));\n    }\n\n    /** Maps a canvas coordinate to NDC space [0,1]. */\n    mapCanvasPointToNdc(canvasPoint: Point.Like) {\n        let {width, height} = this.clientRect;\n        let x = canvasPoint.x / width;\n        let y = (height - canvasPoint.y) / height; // Flip in y axis\n        return {x: x, y: y};\n    }\n\n    /** Maps a normalized device coordinate (NDC) to world space. */\n    mapNdcToWorld(ndc: Point.Like) {\n        let view = this.renderer.camera.view; // Depends on what is currently in view\n        let x = view.left + (ndc.x * view.width);\n        let y = view.bottom + (ndc.y * view.height);\n        return {x: x, y: y};\n    }\n};\n","export interface Uniforms {\n    readonly [name: string]: WebGLUniformLocation;\n    projection: WebGLUniformLocation;\n    lineWidth: WebGLUniformLocation;\n    fillColor: WebGLUniformLocation;\n    strokeColor: WebGLUniformLocation;\n}\n\nexport interface Attributes {\n    readonly [name: string]: number;\n    model: number;\n    offset: number;\n    position: number;\n}\n\nexport type Variables = Uniforms|Attributes;\n\nexport const vertex = \"precision mediump float;uniform mat4 z;uniform float s;attribute mat2 c;attribute vec2 v,h;varying vec2 f,e;mat2 i(float a){float b=sin(a),d=cos(a);return mat2(d,b,-b,d);}void main(){float j=c[0].x,k=c[1].x,l=c[0].y,m=c[1].y,a=(j+m)/2.,b=(j-m)/2.,d=(l+k)/2.,g=(l-k)/2.,n=sqrt(a*a+g*g),o=sqrt(b*b+d*d),A=n+o,p=n-o,q=atan(d,b),r=atan(g,a),w=(r-q)/2.,x=(r+q)/2.;mat2 t=i(x),u=i(w);t[1]*=sign(p),p=abs(p);vec2 y=t*(s*(u*h)),B=c*h+v+y;gl_Position=z*vec4(B,1.,1.),e=u*h,f=e*(1.+s/vec2(A,p));}\", fragment = \"precision mediump float;uniform vec4 C,D;varying vec2 f,e;void main(){bool a=dot(f,f)<1.,b=dot(e,e)<1.;gl_FragColor=a?C:b?D:vec4(0.);}\", attributeRenaming = {\"model\":\"c\",\"offset\":\"v\",\"position\":\"h\"}, uniformRenaming = {\"projection\":\"z\",\"lineWidth\":\"s\",\"fillColor\":\"C\",\"strokeColor\":\"D\"};\n","export interface Uniforms {\n    readonly [name: string]: WebGLUniformLocation;\n    projection: WebGLUniformLocation;\n    color: WebGLUniformLocation;\n}\n\nexport interface Attributes {\n    readonly [name: string]: number;\n    model: number;\n    offset: number;\n    position: number;\n}\n\nexport type Variables = Uniforms|Attributes;\n\nexport const vertex = \"precision mediump float;uniform mat4 d;attribute mat2 a;attribute vec2 b,c;void main(){vec2 e=a*c+b;gl_Position=d*vec4(e,1.,1.);}\", fragment = \"precision mediump float;uniform vec4 f;void main(){gl_FragColor=f;}\", attributeRenaming = {\"model\":\"a\",\"offset\":\"b\",\"position\":\"c\"}, uniformRenaming = {\"projection\":\"d\",\"color\":\"f\"};\n","import { pad, randomByte } from \"./util\";\n\nexport interface Like {\n    /** The red component of this color, a value between 0 and 0xff */\n    r: number;\n    /** The green component of this color, a value between 0 and 0xff */\n    g: number;\n    /** The blue component of this, a value between 0 and 0xff */\n    b: number;\n    /** The alpha component of this color, a value between 0 and 0xff */\n    a: number;\n}\n\n/** Copies a color */\nexport function copy(c: Like, out = <Like> {}) {\n    out.r = c.r;\n    out.g = c.g;\n    out.b = c.b;\n    out.a = c.a;\n    return out;\n}\n\n/** Converts an 0xrrggbbaa int to a color */\nexport function fromRgbaInt(rgba: number, out = <Like> {}) {\n    out.r = (rgba >> 24) & 0xff;\n    out.g = (rgba >> 16) & 0xff;\n    out.b = (rgba >> 8) & 0xff;\n    out.a = (rgba >> 0) & 0xff;\n    return out;\n}\n\n/** Converts an 0xrrggbb int to a (fully opaque) color */\nexport function fromRgbInt(rgb: number, out = <Like> {}) {\n    return fromRgbaInt((rgb << 8) | 0xff, out);\n}\n\n/** Converts a color to an 0xrrggbbaa int */\nexport function toRgbaInt(c: Like) {\n    let r = c.r << 24;\n    let g = c.g << 16;\n    let b = c.b << 8;\n    let a = c.a << 0;\n    return (r | g | b | a) >>> 0; // Convert to unsigned\n}\n\n/** Converts an #aarrggbb string to a color. The leading # is optional. */\nexport function fromArgbString(argb: string, out = <Like> {}) {\n    let i = argb[0] == '#' ? 1 : 0;\n    out.a = parseInt(argb.substr(i, 2), 16);\n    out.r = parseInt(argb.substr(i + 2, 2), 16);\n    out.g = parseInt(argb.substr(i + 4, 2), 16);\n    out.b = parseInt(argb.substr(i + 6, 2), 16);\n    return out;\n}\n\n/** Converts a color to an #aarrggbb string. */\nexport function toArgbString(c: Like) {\n    let a = pad(c.a.toString(16)); // aa\n    let r = pad(c.r.toString(16)); // rr\n    let g = pad(c.g.toString(16)); // gg\n    let b = pad(c.b.toString(16)); // bb\n    return '#' + a + r + g + b; // #aarrggbb\n}\n\n/** Creates a random color. Preserves the alpha value of the out param if specified; otherwise defaults to fully opaque */\nexport function random(out = <Like> {}) {\n    out.r = randomByte();\n    out.g = randomByte();\n    out.b = randomByte();\n    out.a = out.a === undefined ? 0xff : out.a;\n    return out;\n}\n\n/** Blends src into dst using (src.alpha, 1-src.alpha) blend mode */\nexport function blend(src: Like, dst: Like, out = <Like> {}) {\n    let alpha = src.a + 1, invAlpha = 256 - src.a;\n    out.r = (alpha * src.r + invAlpha * dst.r) >> 8; // divide by 2^8\n    out.g = (alpha * src.g + invAlpha * dst.g) >> 8;\n    out.b = (alpha * src.b + invAlpha * dst.b) >> 8;\n    out.a = dst.a;\n    return out;\n}\n\n/** Checks if a color is fully opaque */\nexport function isOpaque(c: Like) {\n    return c.a === 0xff;\n}\n\n/** Checks if a color is fully transparent */\nexport function isTransparent(c: Like) {\n    return c.a === 0;\n}\n\n/** Checks if c1 and c2 are equal */\nexport function equals(c1: Like, c2: Like) {\n    return c1.r == c2.r\n        && c1.g == c2.g\n        && c1.b == c2.b\n        && c1.a == c2.a;\n}","import { Color  } from '..';\n\n// These functions are the same\nexport { copy, isTransparent, Like } from './color'; \n\n/** Checks if c1 and c2 are approximately equal */\nexport function equals(c1: Color.Like, c2: Color.Like, e = 0) {\n    return Math.abs(c1.r - c2.r) <= e\n        && Math.abs(c1.g - c2.g) <= e\n        && Math.abs(c1.b - c2.b) <= e;\n}\n\n/** Converts a byte-based rgba color to a float-based rgba color */\nexport function fromColor(src: Color.Like, out = <Color.Like> {}){\n    out.r = src.r / 0xff;\n    out.g = src.g / 0xff;\n    out.b = src.b / 0xff;\n    out.a = src.a / 0xff;\n    return out;\n}\n\n/** Converts a float-based rgba color to a byte-based rgba color */\nexport function toColor(src: Color.Like, out = <Color.Like> {}){\n    out.r = (src.r * 0xff) >> 0;\n    out.g = (src.g * 0xff) >> 0;\n    out.b = (src.b * 0xff) >> 0;\n    out.a = (src.a * 0xff) >> 0;\n    return out;\n}\n\n/** Creates a random color. Preserves the alpha value of the out param if specified; otherwise defaults to fully opaque */\nexport function random(out = <Color.Like> {}) {\n    out.r = Math.random();\n    out.g = Math.random();\n    out.b = Math.random();\n    out.a = out.a === undefined ? 1 : out.a;\n    return out;\n}\n\n/** Checks if a color is fully opaque */\nexport function isOpaque(c: Color.Like) {\n    return c.a === 1;\n}\n\n/** Premultiplies the (r,g,b) components of a color by it's alpha component */\nexport function premultiplyAlpha(c: Color.Like, out = <Color.Like> {}) {\n    out.r = c.r * c.a;\n    out.g = c.g * c.a;\n    out.b = c.b * c.a;\n    out.a = 1;\n    return out;\n}","import { Point, Rect, Vec2 } from \"..\";\n\nexport interface Like {\n    /** The semi x axis of this ellipse, that is, the distance from the center of this ellipse to its left and right vertices. */\n    rx: number;\n    /**  The semi y axis of this ellipse, that is, the distance from the center of this ellipse to its top and bottom vertices. */\n    ry: number;\n    /** The point at the center of this ellipse. */\n    c: Point.Like;\n}\n\n/** Copies an ellipse */\nexport function copy(e: Like, out = <Like> {}) {\n    out.rx = e.rx;\n    out.ry = e.ry;\n    out.c = Point.copy(e.c, out.c);\n    return out;\n}\n\n/** Creates a circle with radius r centered at point c */\nexport function circle(r: number, c: Point.Like, out = <Like> {}) {\n    return copy({rx: r, ry: r, c: c}, out);\n}\n\n/** Creates an ellipse with the specified boundaries */\nexport function fromRect(r: Rect, out = <Like> {}) {\n    return copy({rx: r.width / 2, ry: r.height / 2, c: r.center()}, out);\n}\n\n/** Check if an ellipse contains the specified point */\nexport function containsPoint(e: Like, p: Point.Like) {\n    // Similar to point in circle problem, but need to account for x/y axes\n    let d = Vec2.fromPointToPoint(p, e.c); \n    let sx = d.x / e.rx;\n    let sy = d.y / e.ry;\n    return (sx * sx) + (sy * sy) <= 1;\n}\n\n/** Checks if e1 and e2 are approximately equal */\nexport function equals(e1: Like, e2: Like, e = 0) {\n    return Math.abs(e1.rx - e2.rx) <= e\n        && Math.abs(e1.ry - e2.ry) <= e\n        && Point.equals(e1.c, e2.c, e);\n}\n ","import { Point, Vec2 } from \"..\";\n\nexport class LineSegment {\n    constructor(\n        /** The point at one end of this line segment */\n        public p1: Point.Like, \n        /** The point at the other end of this line segment */\n        public p2: Point.Like\n    ) {}\n\n    get midpoint() {\n        return Point.midpoint(this.p1, this.p2);\n    }\n\n    get length() {\n        return Point.distance(this.p1, this.p2);\n    }\n\n    /** Checks if the distance from this line to (x,y) is less than or equal to epsilon  */\n    containsPoint(p: Point.Like, epsilon = 0) {\n        // Paramaterize the line segment to a + bt, 0<=t<=1\n        let a = this.p1,\n            b = Vec2.fromPointToPoint(this.p1, this.p2),\n            t = -1;\n\n        // Find the value of t that produces a point closest to point p (using vector projection)\n        let v = Vec2.fromPointToPoint(a, p);\n        let len2 = Vec2.length2(b);\n        if (len2 != 0) { //in case of 0 length line\n            t = Vec2.dot(b, v) / len2;\n        }\n\n        // If t does not produce a point on our line segment, then then the line segment does not contain the point\n        if (t < 0 || t > 1) {\n            return false;\n        }\n\n        // The distance between the given point and specified point must be less than epsilon\n        // As an optimization, we check distance squared to avoid having to take the square root\n        let closest = Vec2.add(a, Vec2.multiply(b, t));\n        let dist2 = Point.distance2(closest, p);\n        return dist2 <= (epsilon * epsilon);\n    }\n\n    /** Copies a line segment */\n    copy() {\n        return new LineSegment(Point.copy(this.p1), Point.copy(this.p2));\n    }\n\n    /** Checks if l1 and l2 are approximately equal */\n    equals(l: LineSegment, e = 0) {\n        return Point.equals(this.p1, l.p1, e) \n            && Point.equals(this.p2, l.p2, e);\n    }\n}\n","import { Point, Rect, Vec2 } from \"..\";\n\nexport interface Like {\n    /** The first entry in the first column of this Mat2d */\n    c1r1: number;\n    /** The second entry in the first column of this Mat2d */\n    c1r2: number;\n    /** The first entry in the second column of this Mat2d */\n    c2r1: number;\n    /** The second entry in the second column of this Mat2d */\n    c2r2: number;\n    /** The first entry in the third column of this Mat2d */\n    c3r1: number;\n    /** The second entry in the third column of this Mat2d */\n    c3r2: number;\n}\n\n/** Copies a 2d matrix */\nexport function copy(m: Like, out = <Like> {}) {\n    out.c1r1 = m.c1r1; out.c2r1 = m.c2r1; out.c3r1 = m.c3r1;\n    out.c1r2 = m.c1r2; out.c2r2 = m.c2r2; out.c3r2 = m.c3r2;\n    return out;\n}\n\n/** Inverts a 2d matrix. */\nexport function invert(m: Like, out = <Like> {}){\n    let det = determinant(m);\n    let { c1r1, c2r1, c3r1, c1r2, c2r2, c3r2 } = m;\n    out.c1r1 = c2r2 / det;\n    out.c2r1 = -c2r1 / det;\n    out.c3r1 = ((c2r1 * c3r2) - (c3r1 * c2r2)) / det;\n    out.c1r2 = -c1r2 / det;\n    out.c2r2 = c1r1 / det;\n    out.c3r2 = ((c1r2 * c3r1) - (c1r1 * c3r2)) / det;\n    return out;\n}\n\n/** Computes the determinant of a 2d matrix. */\nexport function determinant(m: Like) {\n    return (m.c1r1 * m.c2r2) - (m.c2r1 * m.c1r2);\n}\n\n/** Concatenates 2 matrices together by multiplication: left * right */\nexport function concat(left: Like, right: Like, out = <Like> {}) {\n    // Calculate the first row, fixing the first left hand row\n    // and moving across each of the right hand columns\n    let c1r1 = left.c1r1 * right.c1r1 + left.c2r1 * right.c1r2;\n    let c2r1 = left.c1r1 * right.c2r1 + left.c2r1 * right.c2r2;\n    let c3r1 = left.c1r1 * right.c3r1 + left.c2r1 * right.c3r2 + left.c3r1;\n    // Calculate the second row, fixing the second left hand row\n    // and moving across each of the right hand columns\n    let c1r2 = left.c1r2 * right.c1r1 + left.c2r2 * right.c1r2;\n    let c2r2 = left.c1r2 * right.c2r1 + left.c2r2 * right.c2r2;\n    let c3r2 = left.c1r2 * right.c3r1 + left.c2r2 * right.c3r2 + left.c3r2;\n    // Output the result\n    out.c1r1 = c1r1; out.c2r1 = c2r1; out.c3r1 = c3r1;\n    out.c1r2 = c1r2; out.c2r2 = c2r2; out.c3r2 = c3r2;\n    return out;\n}\n\n/** Pivots the fixed point of a matrix by the specified vector */\nexport function pivot(m: Like, v: Point.Like, out = <Like> {}) {\n    return conjugate(m, translate(v), out);\n}\n\n/** Conjugates a matrix by the specified conjugator matrix */\nexport function conjugate(m: Like, conjugator: Like, out = <Like> {}) {\n    return concat(conjugator, concat(m, invert(conjugator)), out);\n}\n\n/** Creates an identity matrix */\nexport function identity(out = <Like> {}) {\n    out.c1r1 = 1; out.c2r1 = 0; out.c3r1 = 0;\n    out.c1r2 = 0; out.c2r2 = 1; out.c3r2 = 0;\n    return out;\n}\n\n/** Creates a matrix to translate by the specified vector */\nexport function translate({x, y}: Vec2.Like, out = <Like> {}) {\n    out.c1r1 = 1; out.c2r1 = 0; out.c3r1 = x;\n    out.c1r2 = 0; out.c2r2 = 1; out.c3r2 = y;\n    return out;\n}\n\n/** Creates a matrix to scale by the specified vector */\nexport function scale({x, y}: Vec2.Like, out = <Like> {}) {\n    out.c1r1 = x; out.c2r1 = 0; out.c3r1 = 0;\n    out.c1r2 = 0; out.c2r2 = y; out.c3r2 = 0;\n    return out;\n}\n\n/** Creates a matrix to scale from the specified start point to the specified end point, with a pivot point at p. */\nexport function scaleToPoint(start: Point.Like, end: Point.Like, p: Point.Like, out = <Like> {}) {\n    let v1 = Vec2.fromPointToPoint(p, start);\n    let v2 = Vec2.fromPointToPoint(p, end);\n    let s = scale({x: v2.x / v1.x, y: v2.y / v1.y}, out);\n    return pivot(s, p, out);\n}\n\n/** Creates a matrix to scale by the specified factor */\nexport function stretch(factor: number, out = <Like> {}) {\n    return scale({x: factor, y: factor}, out); \n}\n\n/** Creates a matrix to rotate by the specified number of radians */\nexport function rotate(radians: number, out = <Like> {}) {\n    return sinCos(Math.sin(radians), Math.cos(radians), out);\n}\n\n/** Creates a matrix to stretch and rotate from the specified start point to the specified end point, with a pivot point at p. */\nexport function stretchRotateToPoint(start: Point.Like, end: Point.Like, p: Point.Like, out = <Like> {}) {\n    // Determine the stretch ratio\n    let v1 = Vec2.fromPointToPoint(p, start);\n    let v2 = Vec2.fromPointToPoint(p, end);\n    let l1 = Vec2.length(v1);\n    let l2 = Vec2.length(v2);\n    let s = stretch(l2 / l1);\n\n    // Determine the sin and cos of the rotation angle\n    let n1 = Vec2.divide(v1, l1);\n    let n2 = Vec2.divide(v2, l2);\n    let sin = Vec2.cross(n1, n2);\n    let cos = Vec2.dot(n1, n2);\n    let r = sinCos(sin, cos);\n\n    // Rotate first, then stretch\n    return pivot(concat(s, r), p, out);\n}\n\n/** Creates a matrix to rotate by the specified sine and cosine values */\nexport function sinCos(sin: number, cos: number, out = <Like> {}) {\n    out.c1r1 = cos; out.c2r1 = -sin; out.c3r1 = 0;\n    out.c1r2 = sin; out.c2r2 = cos; out.c3r2 = 0;\n    return out;\n}\n\n/** Scale to fit options for a rect-to-rect matrix. */\nexport const enum ScaleToFit {\n    /** Stretches the src rect to fit inside dst, then centers the src rect inside the dst rect */\n    Center,\n    /** Stretches the src rect to fit inside dst, then translates the src rect to the bottom right corner of the dst rect */\n    End,\n    /** Scales the src rect to fit inside dst exactly, then translates src to dst */\n    Fill,\n    /** Stretches the src rect to fit inside dst, then translates the src rect to top left corner of the dst rect*/\n    Start\n};\n\n/** Creates a matrix to map src into dst using the specifed scale to fit option  */\nexport function rectToRect(src: Rect, dst: Rect, stf = ScaleToFit.Fill, out = <Like> {}) {\n    // Translate to origin\n    let origin = {x: 0, y: 0};\n    let srcPoint = getScaleToFitPoint(src, stf);\n    let dstPoint = getScaleToFitPoint(dst, stf);\n    translate(Vec2.fromPointToPoint(srcPoint, origin), out); \n\n    // Apply the scale\n    let sx = dst.width / src.width;\n    let sy = dst.height / src.height;\n    let scaleMatrix = stf == ScaleToFit.Fill ? scale({x: sx, y: sy}) : stretch(Math.min(sx, sy));\n    concat(scaleMatrix, out, out);\n\n    // Translate to destination point\n    let translation = translate(Vec2.fromPointToPoint(origin, dstPoint));\n    return concat(translation, out, out);\n}\n\n/** Determine which point to match based on the scale to fit option. */\nfunction getScaleToFitPoint(r: Rect, stf: ScaleToFit): Point.Like {\n    switch (stf) {\n        case ScaleToFit.Center:\n            return r.center();\n        case ScaleToFit.End:\n            return r.bottomRight();\n        default:\n            return r.topLeft();\n    }\n}\n\n/** Maps a point by the specified matrix */\nexport function mapPoint(m: Like, {x, y}: Point.Like, out = <Point.Like> {}) {\n    out.x = m.c1r1 * x + m.c2r1 * y + m.c3r1;\n    out.y = m.c1r2 * x + m.c2r2 * y + m.c3r2;\n    return out;\n}\n\n/** Maps a rect by the specified matrix */\nexport function mapRect(m: Like, r: Rect, out = Rect.empty()) {\n    let {x, y} = mapPoint(m, r.topLeft()); \n    let corners = [r.bottomLeft(), r.bottomRight(), r.topRight()];\n    out.left = out.right = x; \n    out.top = out.bottom = y;\n    for (let corner of corners) {\n        out.unionPoint(mapPoint(m, corner));\n    }\n    return out;\n}\n\n/** Checks if two matrices are approximately equal */\nexport function equals(m1: Like, m2: Like, e = 0) {\n    return Math.abs(m1.c1r1 - m2.c1r1) <= e\n        && Math.abs(m1.c1r2 - m2.c1r2) <= e\n        && Math.abs(m1.c2r1 - m2.c2r1) <= e\n        && Math.abs(m1.c2r2 - m2.c2r2) <= e\n        && Math.abs(m1.c3r1 - m2.c3r1) <= e\n        && Math.abs(m1.c3r2 - m2.c3r2) <= e\n}","import { Rect } from '..';\n\n/**\n * Creates an othogonal transformation matrix.\n * @param clip the near clipping plane viewport.\n * @param near the depth (negative z coordinate) of the near clipping plane.\n * @param far the depth (negative z coordinate) of the far clipping plane.\n */\nexport function ortho(clip: Rect, near: number, far: number, out: Float32Array) {\n    let width = clip.width,\n        height = clip.height,\n        depth = near - far;\n\n    out[0] = 2 / width;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n\n    out[4] = 0;\n    out[5] = 2 / height;\n    out[6] = 0;\n    out[7] = 0;\n\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1 / depth;\n    out[11] = 0;\n\n    out[12] = -(clip.right + clip.left) / width;\n    out[13] = -(clip.top + clip.bottom) / height;\n    out[14] = -near / depth;\n    out[15] = 1;\n}\n","import { Vec2 } from \"..\";\n\nexport interface Like {\n    x: number;\n    y: number;\n}\n\n/** Copies a point */\nexport function copy(p: Like, out = <Like> {}) {\n    out.x = p.x;\n    out.y = p.y;\n    return out;\n}\n\n/** Computes the midpoint of p1 and p2 */\nexport function midpoint(p1: Like, p2: Like, out = <Like> {}) {\n    return Vec2.multiply(Vec2.add(p1, p2, out), 0.5, out);\n}\n\n/** Computes the distance between p1 and p2 */\nexport function distance(p1: Like, p2: Like) {\n    return Math.sqrt(distance2(p1, p2));\n}\n\n/** Computes the distance squared between p1 and p2 */\nexport function distance2(p1: Like, p2: Like) {\n    return Vec2.length2(Vec2.fromPointToPoint(p1, p2));\n}\n\n/** Checks if p1 and p2 are approximately equal */\nexport function equals(p1: Like, p2: Like, e = 0) {\n    return Math.abs(p1.x - p2.x) <= e\n        && Math.abs(p1.y - p2.y) <= e;\n}","import { Point, Vec2 } from \"..\";\n\nexport interface RectLike {\n    /** The left boundary of this Rect */\n    left: number;\n    /** The top boundary of this Rect */\n    top: number;\n    /** The right boundary of this Rect */\n    right: number;\n    /** The bottom boundary of this Rect */\n    bottom: number;\n}\nexport class Rect implements RectLike {\n\n    static copy(r: RectLike) {\n        return new Rect(r.left, r.top, r.right, r.bottom);\n    }\n\n    /** Creates an empty rect */\n    static empty() {\n        return new Rect(0, 0, 0, 0);\n    }\n\n    /** Creates this rect with the specified dimensions */\n    static dimensions(left: number, top: number, width: number, height: number) {\n        return new Rect(left, top, left + width, top - height);\n    }\n\n    constructor(\n        public left: number,\n        public top: number,\n        public right: number,\n        public bottom: number\n    ) {}\n\n    /** Measures the width of this rect */\n    get width() {\n        return this.right - this.left;\n    }\n\n    set width(w: number) {\n        this.right = this.left + w;\n    }\n\n    /** Measures the height of this rect */\n    get height() {\n        return this.top - this.bottom;\n    }\n\n    set height(h: number) {\n        this.bottom = this.top - h;\n    }\n\n    get aspect() {\n        return this.width / this.height;\n    }\n\n    /** Measures the area of this rect */\n    get area() {\n        return this.width * this.height;\n    }\n\n    /** Gets the point at the center of this rect */\n    center(out = <Point.Like> {}) {\n        out.x = this.centerX;\n        out.y = this.centerY;\n        return out;\n    }\n\n    /** Measures the x-coordinate of the point at the center of this rect */\n    get centerX() {\n        return 0.5 * (this.left + this.right);\n    }\n\n    /** Measures the y-coordinate of the point at the center of this rect */\n    get centerY() {\n        return 0.5 * (this.bottom + this.top);\n    }\n\n    /** Gets the point at the top left corner of this rect */\n    topLeft(out = <Point.Like> {}) {\n        out.x = this.left;\n        out.y = this.top;\n        return out;\n    }\n\n    /** Gets the point at the bottom left corner of this rect */\n    bottomLeft(out = <Point.Like> {}) {\n        out.x = this.left;\n        out.y = this.bottom;\n        return out;\n    }\n\n    /** Gets the point at the bottom right corner of this rect */\n    bottomRight(out = <Point.Like> {}) {\n        out.x = this.right;\n        out.y = this.bottom;\n        return out;\n    }\n\n    /** Gets the point at the top right corner of this rect */\n    topRight(out = <Point.Like> {}) {\n        out.x = this.right;\n        out.y = this.top;\n        return out;\n    }\n\n    /** Checks if this rect is empty. True if left >= right or bottom >= top. */\n    isEmpty() {\n        return this.left >= this.right || this.bottom >= this.top;\n    }\n\n    /** Checks if the boundaries of this Rect represent a valid rectangle. True if right >= left and top >= bottom. */\n    isValid() {\n        return this.right >= this.left && this.top >= this.bottom;\n    }\n\n    /** Expands this rect to include the other rect */\n    union(r: RectLike) {\n        this.left = Math.min(this.left, r.left);\n        this.right = Math.max(this.right, r.right);\n        this.bottom = Math.min(this.bottom, r.bottom);\n        this.top = Math.max(this.top, r.top);\n    }\n\n    /** Expands this rect to enclose the specified point */\n    unionPoint({x, y}: Point.Like) {\n        this.left = Math.min(x, this.left);\n        this.top = Math.max(y, this.top);\n        this.right = Math.max(x, this.right);\n        this.bottom = Math.min(y, this.bottom);\n    }\n\n    /** Checks if this rect intersects the other rect */\n    intersects(r: RectLike) {\n        return this.right >= r.left && r.right >= this.left && this.top >= r.bottom && r.top >= this.bottom;\n    }\n\n    /** Finds the intersection of this rect with the other rect */\n    intersect(r: RectLike) {\n        this.left = Math.max(this.left, r.left);\n        this.right = Math.min(this.right, r.right);\n        this.bottom = Math.max(this.bottom, r.bottom);\n        this.top = Math.min(this.top, r.top);\n    }\n\n    /** Insets the boundaries of this rect by the specified vector. */\n    inset({x, y}: Vec2.Like) {\n        this.left += x;\n        this.top -= y;\n        this.right -= x;\n        this.bottom += y;\n    }\n\n    /** Offsets the position of this rect by the specified vector */\n    offset({x, y}: Vec2.Like) {\n        this.offsetX(x);\n        this.offsetY(y);\n    }\n\n    /** Offsets the position of this rect by the specified change in x (dx) */\n    offsetX(dx: number) {\n        this.left += dx;\n        this.right += dx;\n    }\n\n    /** Offsets the position of this rect by the specified change in y (dy) */\n    offsetY(dy: number) {\n        this.top += dy;\n        this.bottom += dy;\n    }\n\n    /** Checks if this rect contains the other rect */\n    contains(r: RectLike) {\n        return this.left <= r.left && r.right <= this.right &&\n            this.bottom <= r.bottom && r.top <= this.top;\n    }\n\n    /** Checks if this rect contains the specified point */\n    containsPoint({x, y}: Point.Like) {\n        return this.containsX(x) && this.containsY(y);\n    }\n\n    /** Checks if this rect contains any point with the specified x coordinate  */\n    containsX(x: number) {\n        return this.left <= x && x <= this.right;\n    }\n\n    /** Checks if this rect contains any point with the specified y coordinate  */\n    containsY(y: number) {\n        return this.bottom <= y && y <= this.top;\n    }\n\n    /** Swaps the top/bottom or left/right boundaries of this rect if they are flipped, meaning left > right and/or top > bottom */\n    sort() {\n        let {top, left, bottom, right} = this;\n        let vFlipped = bottom > top;\n        let hFlipped = left > right;\n        this.top = vFlipped ? bottom : top;\n        this.left = hFlipped ? right : left;\n        this.bottom = vFlipped ? top : bottom;\n        this.right = hFlipped ? left : right;\n    }\n\n    /** Checks if this rect is approximately equal to the other rect */\n    equals(r: RectLike, e = 0) {\n        return Math.abs(this.left - r.left) <= e\n            && Math.abs(this.top - r.top) <= e\n            && Math.abs(this.right - r.right) <= e\n            && Math.abs(this.bottom - r.bottom) <= e;\n    }\n}\n","export function pad(str: string) {\n    return (str.length == 1) ? '0' + str : str;\n}\n\n/** Returns a random integer between min (inclusive) and max (inclusive) */\nexport function randomInt(min: number, max: number) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n/** Returns a random byte value between 0 and 0xff */\nexport function randomByte() {\n    return randomInt(0, 0xff);\n}","import { Point, Rect } from \"..\";\n\n/** A two-dimensional vector with (x,y) components */\nexport interface Like {\n    x: number;\n    y: number;\n}\n\n/** Copies a */\nexport function copy(v: Like, out = <Like> {}) {\n    out.x = v.x;\n    out.y = v.y;\n    return out;\n}\n\n/** Returns v1 + v2 (component-wise addition) */\nexport function add(v1: Like, v2: Like, out = <Like> {}) {\n    out.x = v1.x + v2.x;\n    out.y = v1.y + v2.y;\n    return out;\n}\n\n/** Returns v1 - v2 (component-wise subtraction) */\nexport function subtract(v1: Like, v2: Like, out = <Like> {}) {\n    out.x = v1.x - v2.x;\n    out.y = v1.y - v2.y;\n    return out;\n}\n\n/** Multiplies each component of a vector by the specified factor */\nexport function multiply({x, y}: Like, factor: number, out = <Like> {}) {\n    out.x = x * factor;\n    out.y = y * factor;\n    return out;\n}\n\n/** Divides each component of a vector by the specified factor */\nexport function divide({x, y}: Like, factor: number, out = <Like> {}) {\n    out.x = x / factor;\n    out.y = y / factor;\n    return out;\n}\n\n/** Measures the length of a vector */\nexport function length(v: Like) {\n    return Math.sqrt(length2(v));\n}\n\n/** Measures the length squared of a vector */\nexport function length2({x, y}: Like) {\n    return x * x + y * y;\n}\n\n/** Computes the dot product of v1 and v2 */\nexport function dot(v1: Like, v2: Like) {\n    return v1.x * v2.x + v1.y * v2.y;\n}\n\n/** Computes the cross product of v1 with v2. */\nexport function cross(v1: Like, v2: Like) {\n    return (v1.x * v2.y) - (v2.x * v1.y);\n}\n \n/* Normalizes a vector so that it has a length of 1 */\nexport function normalize(v: Like, out = <Like> {}) {\n    return divide(v, length(v), out);\n}\n\n/** Rotates a vector 90 degrees CCW (to the right) */\nexport function rotate90({x, y}: Like, out = <Like> {}) {\n    out.x = y;\n    out.y = -x;\n    return out;\n}\n\n/** Rotates a vector 180 degrees CCW (flipping it) */\nexport function rotate180({x, y}: Like, out = <Like> {}) {\n    out.x = -x;\n    out.y = -y;\n    return out;\n}\n\n/** Rotates a vector 270 degrees CCW (90 degree to the left) */\nexport function rotate270({x, y}: Like, out = <Like> {}) {\n    out.x = -y;\n    out.y = x;\n    return out;\n}\n\n/** Measures the vector from p1 (initial point) to p2 (terminal point) */\nexport function fromPointToPoint(p1: Point.Like, p2: Point.Like, out = <Like> {}) {\n    out.x = p2.x - p1.x;\n    out.y = p2.y - p1.y;\n    return out;\n}\n\n/** Bounds a translation vector to prevent it from mapping point p outside of bounds r */\nexport function bound(v: Like, p: Point.Like, b: Rect, out = <Like> {}) {\n    out.x = boundX(v.x, p.x, b);\n    out.y = boundY(v.y, p.y, b);\n    return out;\n}\n\n/** Bounds the x-component of a translation vector to prevent it from mapping the x-coordinate of a point outside of bounds b */\nexport function boundX(dx: number, x: number, b: Rect) {\n    let targetX = dx + x;\n    let side = dx < 0 ? b.left : b.right;\n    return b.containsX(targetX) ? dx : side - x;\n}\n\n/** Bounds the y-component of a translation vector to prevent it from mapping the y-coordinate of a point outside of bounds b */\nexport function boundY(dy: number, y: number, b: Rect) {\n    let targetY = dy + y;\n    let side = dy < 0 ? b.bottom : b.top;\n    return b.containsY(targetY) ? dy : side - y;\n}\n\n/**\n * Finds the miter vector needed to join the two specified lines. Assumes the lines are measured from points listed in CCW order.\n * @param line1 The nonzero vector from the start of the first line to the end of the first line. \n * @param line2 The nonzero vector from the start of the second line to the end of the second line. \n * @param lineWidth The width of the second line (or half the width, if joining at the center of the lines).\n * @param miterLimit The maximum allowable miter length before a bevel is applied. Usually some multiple of lineWidth.\n */\nexport function miter(line1: Like, line2: Like, lineWidth: number, miterLimit: number, out = <Like> {}){\n    let n1 = normalize(rotate90(line1));\n    let n2 = normalize(rotate90(line2));\n    let direction = normalize(add(n1, n2));\n    let length = Math.min(miterLimit, lineWidth / dot(direction, n2));\n    return multiply(direction, length, out);\n}\n\n/** Checks if v1 and v2 are approximately equal */\nexport function equals(v1: Like, v2: Like, e = 0) {\n    return Math.abs(v1.x - v2.x) <= e\n        && Math.abs(v1.y - v2.y) <= e;\n}","import { Point, Pointer, PointerEventListener, Vec2 } from \"..\";\n\nexport class PanTool extends PointerEventListener {\n\n    private previous: Point.Like;\n\n    wherePointer(p: Pointer) {\n        return p.isDown && p.activePointers.length == 1;\n    }\n\n    onPointerDown(p: Pointer) {\n        this.previous = p.position;\n    }\n\n    onPointerMove({position, surface}: Pointer) {\n        let toPrevious = Vec2.fromPointToPoint(position, this.previous); \n        let actual = surface.pan(toPrevious);\n        Vec2.add(actual, position, this.previous);\n    }\n}\n   ","import { LineSegment, Point, Pointer, PointerEventListener, Vec2 } from \"..\";\n\nexport class PinchZoomTool extends PointerEventListener {\n\n    private previousSpan: number;\n    private previousFocus: Point.Like;\n\n    wherePointer(p: Pointer) {\n        return p.isDown && p.activePointers.length == 2;\n    }\n\n    onPointerDown(p: Pointer) {\n        let line = this.measureLine(p);\n        this.previousSpan = line.length;\n        this.previousFocus = line.midpoint;\n    }\n\n    onPointerMove(p: Pointer) {\n        let line = this.measureLine(p);\n        let scale = line.length / this.previousSpan;\n        let focus = Point.midpoint(line.midpoint, this.previousFocus);\n        let actual = p.surface.zoomToPoint(scale, focus);\n        this.previousSpan = line.length / actual.scale;\n        this.previousFocus = Vec2.add(actual.offset, this.previousFocus);\n    }\n\n    private measureLine({activePointers}: Pointer) {\n        let p1 = activePointers[0].position;\n        let p2 = activePointers[1].position;\n        return new LineSegment(p1, p2);\n    }\n}\n  ","\nimport { Vec2, Point } from '..';\n\nexport class Stroke {\n\n    public readonly vertices = <Point.Like[]> [];\n\n    /**\n     * Begins this stroke at the specified point.\n     * @param p where to begin the stroke.\n     * @param thickness the thickness of the initial line.\n     */\n    moveTo({x, y}: Point.Like, thickness: number) {\n        let halfThickness = thickness * 0.5;\n        let top = {x: x, y: y + halfThickness};\n        let bot = {x: x, y: y - halfThickness};\n        this.vertices.push(top, bot);\n    }\n\n   /**\n     * Adds a line to the specified point.\n     * @param point the point at the end of the line.\n     * @param thickness the thickness of the line.\n     */\n    lineTo(p: Point.Like, thickness: number) {\n        let nextIndex = this.vertices.length;\n        if (nextIndex < 2) {\n            throw \"Must make a call to moveTo() before making a call to lineTo()\"\n        }\n\n        let halfThickness = 0.5 * thickness\n        let prevCen = this.getPreviousPoint(nextIndex);\n        let line = Vec2.fromPointToPoint(prevCen, p);\n        let prevLine = null;\n        \n        // Merge with previous line if the length of either line is less than half of the desired thickness\n        if (nextIndex >= 4) {\n            let prevPrevCen = this.getPreviousPoint(nextIndex - 2);\n            prevLine = Vec2.fromPointToPoint(prevPrevCen, prevCen);\n            if(Vec2.length(line) <= halfThickness && Vec2.length(prevLine) <= halfThickness){\n                nextIndex -= 2;\n                prevCen = prevPrevCen;\n                line = Vec2.fromPointToPoint(prevCen, p);\n                prevLine = nextIndex >= 4 ? this.getPreviousPoint(nextIndex - 2) : null;\n            }\n        }\n\n        // If there are more than two line segments (with non-zero length), use a miter vector to join them. \n        // Otherwise use the ortho vector to compute the top and bottom left vertices of the line segment.\n        let ortho = Vec2.multiply(Vec2.normalize(Vec2.rotate90(line)), halfThickness);\n        let useMiter = prevLine !== null && Vec2.length(prevLine) > thickness / 8; \n        let miter = useMiter ? Vec2.miter(prevLine, line, halfThickness, thickness) : ortho;\n\n        // Join to previous line\n        this.vertices[nextIndex - 2] = Vec2.add(prevCen, miter);\n        this.vertices[nextIndex - 1] = Vec2.subtract(prevCen, miter);\n        this.vertices[nextIndex + 0] = Vec2.add(p, ortho);\n        this.vertices[nextIndex + 1] = Vec2.subtract(p, ortho);\n    }\n\n    private getPreviousPoint(currIndex: number) {\n        let vertices = this.vertices;\n        let prevTop = vertices[currIndex - 2];\n        let prevBot = vertices[currIndex - 1];\n        return Point.midpoint(prevTop, prevBot);\n    }\n}\n","import {Wheel, WheelEventListener} from '..'\n\n/** Tool for zooming in and out of a surface based on scroll events and cursor position. */\nexport class WheelZoomTool implements WheelEventListener {\n\n    constructor(\n        /** The scale applied to the surface when zooming in. The inverse is applied when zooming out. */\n        public scaleFactor: number\n    ){}\n\n    onWheel(wheel: Wheel) {\n        let scale = wheel.deltaY < 0 ? this.scaleFactor : 1 / this.scaleFactor;\n        let actual = wheel.surface.zoomToPoint(scale, wheel.position);\n    }\n}","import { Drawable, FillProgram, Mat2dBuffer, PolygonModel, Renderer } from \"@wjheesen/glib\";\n\nexport class Scene implements Drawable {\n\n    constructor(\n        private fill: FillProgram,\n        private hexagon: PolygonModel,\n        private matrices: Mat2dBuffer\n    ) {}\n\n    draw(renderer: Renderer): void {\n        let { gl } = renderer;\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.enable(gl.CULL_FACE);\n        gl.cullFace(gl.BACK);\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n        this.fill.draw(renderer, this.hexagon.mesh, this.matrices);\n    }\n}","import { Camera,  Renderer, Surface, Rect, PolygonMesh, ProgramUtil, FillProgram, PolygonModel, Mat2dBuffer, ColorBuffer, Color, ColorF, Mat2d, WheelZoomTool, PointerEventDetector, PanTool, PinchZoomTool } from '@wjheesen/glib';\nimport { Scene } from './hexel/scene';\n\nlet canvasEl = <HTMLCanvasElement> document.getElementById('onscreen-canvas');\nlet camera = new Camera(new Rect(-1, 1, 1, -1), 0.5, 10);\nlet renderer = new Renderer(canvasEl.getContext('webgl'), camera);\nlet hexMesh =  PolygonMesh.regularPolygon(6);\nlet util = new ProgramUtil(renderer.gl);\nlet matBuf = Mat2dBuffer.withLength(1);\nlet hexagon = new PolygonModel(hexMesh, matBuf.get(0));\nMat2d.identity(hexagon.matrix);\nlet fill = FillProgram.create(util, [hexMesh]); \nfill.color = new ColorBuffer(new Float32Array([1,1,1,1]));\nColorF.random(fill.color);\nlet scene = new Scene(fill, hexagon, matBuf);\nlet surface = new Surface(canvasEl, renderer, scene);\nsurface.startRenderLoop();\n\nlet wheelEvents = surface.startDetectingWheelEvents();\nwheelEvents.addListener(new WheelZoomTool(1.1));\n\nlet pointerEvents = surface.startDetectingPointerEvents();\npointerEvents.addListener(new PanTool);\npointerEvents.addListener(new PinchZoomTool);","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module\n__webpack_require__(432);\n// This entry module used 'exports' so it can't be inlined\n"],"sourceRoot":""}