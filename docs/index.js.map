{"version":3,"sources":["webpack://hexel-art/../glib/src/buffer/color-buffer.ts","webpack://hexel-art/../glib/src/buffer/mat2d-buffer.ts","webpack://hexel-art/../glib/src/buffer/struct-buffer.ts","webpack://hexel-art/../glib/src/buffer/vec2-buffer.ts","webpack://hexel-art/../glib/src/event/pointer-event.ts","webpack://hexel-art/../glib/src/event/wheel-event.ts","webpack://hexel-art/../glib/src/index.ts","webpack://hexel-art/../glib/src/model/ellipse-model.ts","webpack://hexel-art/../glib/src/model/mesh.ts","webpack://hexel-art/../glib/src/model/model.ts","webpack://hexel-art/../glib/src/model/polygon-mesh.ts","webpack://hexel-art/../glib/src/model/polygon-model.ts","webpack://hexel-art/../glib/src/program/ellipse-program.ts","webpack://hexel-art/../glib/src/program/ellipse-shader.ts","webpack://hexel-art/../glib/src/program/fill-program.ts","webpack://hexel-art/../glib/src/program/fill-shader.ts","webpack://hexel-art/../glib/src/program/program-util.ts","webpack://hexel-art/../glib/src/program/program.ts","webpack://hexel-art/../glib/src/rendering/camera.ts","webpack://hexel-art/../glib/src/rendering/renderer.ts","webpack://hexel-art/../glib/src/rendering/surface.ts","webpack://hexel-art/../glib/src/struct/color.ts","webpack://hexel-art/../glib/src/struct/colorf.ts","webpack://hexel-art/../glib/src/struct/ellipse.ts","webpack://hexel-art/../glib/src/struct/line-segment.ts","webpack://hexel-art/../glib/src/struct/mat2d.ts","webpack://hexel-art/../glib/src/struct/mat4.ts","webpack://hexel-art/../glib/src/struct/point.ts","webpack://hexel-art/../glib/src/struct/rect.ts","webpack://hexel-art/../glib/src/struct/util.ts","webpack://hexel-art/../glib/src/struct/vec2.ts","webpack://hexel-art/../glib/src/tool/pan-tool.ts","webpack://hexel-art/../glib/src/tool/pinch-zoom-tool.ts","webpack://hexel-art/../glib/src/tool/stroke.ts","webpack://hexel-art/../glib/src/tool/wheel-zoom-tool.ts","webpack://hexel-art/./src/graphics/bit.ts","webpack://hexel-art/./src/graphics/struct/rect.ts","webpack://hexel-art/./src/graphics/structify/buf.ts","webpack://hexel-art/./src/graphics/structify/struct.ts","webpack://hexel-art/./src/hexel/cube.ts","webpack://hexel-art/./src/hexel/hexel-grid.ts","webpack://hexel-art/./src/hexel/scene.ts","webpack://hexel-art/./src/index.ts","webpack://hexel-art/./src/program/hexel-program.ts","webpack://hexel-art/./src/program/hexel-shader.ts","webpack://hexel-art/./src/tool/brush.ts","webpack://hexel-art/./src/tool/tool.ts","webpack://hexel-art/./src/toolbar/brush-size-slider.ts","webpack://hexel-art/./src/toolbar/color-picker.ts","webpack://hexel-art/./src/toolbar/settings.ts","webpack://hexel-art/./src/toolbar/tool-selector.ts","webpack://hexel-art/webpack/bootstrap","webpack://hexel-art/webpack/startup"],"names":["withLength","n","this","Uint8Array","getComponent","value","setComponent","newStruct","data","ColorBuffer","StructBuffer","Float32Array","Mat2dBuffer","dataPosition","componentLength","index","assertValidIndex","length","at","position","get","getStructData","begin","end","subarray","Rect","empty","measureBounds","p0","bounds","dimensions","x","y","i","unionPoint","Vec2Buffer","containsPoint","p","offset","count","inside","x1","y1","x2","y2","id","status","surface","isPrimary","isDown","activePointers","Pointer","wherePointer","onPointerDown","onPointerMove","onPointerUp","onPointerCancel","PointerEventListener","listeners","e","pointer","addPointer","dispatchEvent","l","removePointer","startListening","canvasEl","addEventListener","stopListening","removeEventListener","addListener","listener","push","removeListener","filter","invokeFn","forEach","getPointerIndex","pointerId","newPointer","setPointerCapture","mapScreenPointToWorld","releasePointerCapture","splice","PointerEventDetector","deltaY","Wheel","onWheel","preventDefault","wheel","WheelEventDetector","matrix","EllipseProgram","mesh","measureBoundaries","a","b","tx","c","d","ty","a2","b2","c2","d2","m","phi","Math","atan2","cos2","pow","cos","sin2","sin","s1","s2","sqrt","sx2","sy2","copy","left","right","top","bottom","EllipseModel","dst","transform","Mat2d","rectToRect","contains","modelPoint","mapPointToModelSpace","Vec2","length2","PolygonModel","Mesh","vertices","indices","c3r1","c3r2","mapPointToWorldSpace","out","mapPoint","worldPoint","invert","concat","translate","v","scale","pivot","center","stretch","factor","rotate","radians","Model","miters","PolygonMesh","regularPolygon","flatTop","regularVertices","regularIndices","angle","PI","rotation","Uint16Array","rectangle","r","rectangleVertices","topLeft","bottomLeft","bottomRight","topRight","star","ratio","starVertices","starIndices","points","innerIndexCount","outerIndexCount","first","second","third","lastIndex","prev","curr","line1","fromPointToPoint","line2","miter","identity","vertexAt","scaleToFit","stf","stretchAcross","p1","p2","cx","centerX","t","s","stretchRotateToPoint","create","util","program","location","createProgramFromSources","Shader","vertex","fragment","uniforms","getUniformLocationMap","uniformRenaming","attribs","getAttributeLocationMap","attributeRenaming","positionBuffer","createArrayBuffer","matrixBuffer","createBuffer","onAttach","gl","angleExt","c1","model","c3","enable","BLEND","bindBuffer","ARRAY_BUFFER","enableVertexAttribArray","vertexAttribPointer","FLOAT","vertexAttribDivisorANGLE","onDetach","draw","renderer","matrices","camera","useProgram","loadProjection","loadMatrices","loadFillColor","loadStrokeColor","loadLineWidth","drawArraysInstancedANGLE","TRIANGLE_FAN","projection","uniformMatrix4fv","bufferData","DYNAMIC_DRAW","uniform4fv","fillColor","strokeColor","uniform1f","lineWidth","Program","meshes","FillProgram","indexBuffer","createIndexBuffer","createVertexBuffer","dynamicBuffer","column1","column2","column3","ELEMENT_ARRAY_BUFFER","loadColor","loadVertices","drawElementsInstancedANGLE","TRIANGLES","UNSIGNED_SHORT","indexBufferOffset","drawTriangleStrip","loadLineVertices","TRIANGLE_STRIP","color","vertexBufferOffset","size","usage","STATIC_DRAW","buffer","createElementBuffer","sizeOfVertexBuffer","bufferSubData","byteLength","reduce","total","sizeOfIndexBuffer","createMiterBuffer","sizeOfStrokeVertexBuffer","miterBufferOffset","createStrokeIndexBuffer","indexCount","lengthOfStrokeIndexArray","vertexCount","strokeIndexCount","strokeIndexBufferOffset","createStrokeVertexBuffer","strokeVertexBufferOffset","vertexShaderSource","fragmentShaderSource","vs","compileShader","VERTEX_SHADER","fs","FRAGMENT_SHADER","createProgramFromShaders","vertexShader","fragmentShader","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","shaderSource","shaderType","shader","createShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","renamed","getUniformLocation","ACTIVE_UNIFORMS","getActiveUniform","getAttribLocation","ACTIVE_ATTRIBUTES","getActiveAttrib","ProgramUtil","world","minZoom","maxZoom","view","zoom","setViewport","vw","vh","vr","wr","aspect","scaleX","scaleY","updateMatrix","desiredOffset","target","add","mapRect","far","rotate180","actualOffset","zoomIn","desiredScaleFactor","actualScaleFactor","targetZoom","zoomToPoint","focus","normX","width","normY","height","aft","Mat4","ortho","Camera","getExtension","onSurfaceChange","viewport","currentProgram","attachProgram","Renderer","scene","clientRect","getBoundingClientRect","hasRenderRequest","checkRender","resize","onAnimationFrame","requestAnimationFrame","startRenderLoop","requestRender","clientWidth","clientHeight","startDetectingPointerEvents","detector","startDetectingWheelEvents","pan","actual","zoomOut","mapScreenPointToCanvas","screenPoint","clientX","clientY","mapScreenPointToNdc","mapCanvasPointToNdc","mapNdcToWorld","canvasPoint","ndc","Surface","fromRgbaInt","rgba","g","rgb","argb","parseInt","substr","pad","toString","randomByte","undefined","src","alpha","invAlpha","isTransparent","abs","random","rx","ry","Point","sx","sy","e1","e2","equals","midpoint","distance","epsilon","len2","dot","closest","multiply","distance2","LineSegment","det","determinant","c1r1","c2r1","c1r2","c2r2","conjugate","conjugator","sinCos","getScaleToFitPoint","start","v1","v2","l1","l2","n1","divide","n2","cross","origin","srcPoint","dstPoint","min","corners","corner","m1","m2","clip","near","depth","w","h","centerY","isEmpty","isValid","union","max","intersects","intersect","inset","offsetX","offsetY","dx","dy","cy","k","containsX","containsY","sort","vFlipped","hFlipped","randomInt","floor","str","normalize","rotate90","boundX","targetX","side","boundY","targetY","miterLimit","direction","previous","toPrevious","PanTool","line","measureLine","previousSpan","previousFocus","PinchZoomTool","moveTo","thickness","halfThickness","bot","lineTo","nextIndex","prevCen","getPreviousPoint","prevLine","prevPrevCen","subtract","currIndex","prevTop","prevBot","Stroke","scaleFactor","WheelZoomTool","byteIndex","bitShift","set","clear","callback","byte","j","bit","BitArray","make","unionPoint$","Obj","ltrb","createBitArray","BinaryImage","forEachSetBit","dstWidth","base","capacity","byteCount","ArrayBuffer","_this","other","set$","add$","subtract$","mulScalar","divScalar","equalsScalar","epsilonEquals","epsilonEqualsScalar","setLtrb","setLbrt","setLrbt","setLtwh","setLbwh","area","centerTop","centerBottom","centerLeft","centerRight","setUnionOfPoints","unionPoints","setUnionOfPoints$","unionPoints$","containsPoint$","shrinkToSquare","expandToSquare","topCopy","rightCopy","create$","lbrt","lrbt","ltwh","lbwh","unionOfPoints","unionOfPoints$","Struct","Buf","structLength","dataPos","put$","$set","$set$","$add","$add$","$subtract","$subtract$","$mulScalar","$divScalar","$equals","$equalsScalar","$epsilonEquals","$epsilonEqualsScalar","$toString","$setLtrb","$setLbrt","$setLrbt","$setLtwh","$setLbwh","$isEmpty","$isValid","$width","$height","$area","$centerX","$centerY","$center","$centerTop","$centerBottom","$centerLeft","$centerRight","$bottomLeft","$bottomRight","$topLeft","$topRight","$empty","$setUnionOfPoints","$setUnionOfPoints$","$contains","$containsPoint","$containsPoint$","$intersects","$intersect","$union","$unionPoint","$unionPoint$","$unionPoints","$unionPoints$","$inset","$offset","$scale","$stretch","$shrinkToSquare","$expandToSquare","$sort","hasValidPosition","moveToPosition","moveToFirst","moveToNext","moveToPrevous","moveToLast","setBuffer","srcPos","dstPos","len","setEach","dstLen","srcLen","put","putBuffer","StructureBuffer","q","Cube","getNeighbor","Directions","getDirection","neighbor","diff","round","cq","cr","cs","q_diff","r_diff","s_diff","H_WIDTH","H_HEIGHT","H_RIGHT","H_UP","cols","rows","hexels","Uint8ClampedArray","hasHexelChanges","hasLayoutChanges","hasGradient","cubeAtIndex","pointAtIndex","pout","cout","pointAtCube","indexAtPoint","cube","cubeAtPoint","indexAtCube","r_offset","hexelAtPoint","forEachCubicCoordinate","forEachOffsetCoordinate","Color","addBinaryImage","img","addLine","record","bitArray","addEllipse","ellipse","addShape","shape","forEachHexelInRange","radius","lower","upper","forEachHexelInRing","forEachCubeInLine","step","floodFill","floodFillScanLine","newColor","oldColor","HexelGrid","ctx","getImageData","pixels","pixel","hexel","blend","clearColor","canvas","imageData","ImageData","clearRect","putImageData","grid","COLOR_BUFFER_BIT","CULL_FACE","cullFace","BACK","blendFunc","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","Scene","document","getElementById","getContext","fromRgbInt","hexMesh","hexelProgram","HexelProgram","settings","Settings","pointerEvents","toolSelector","ToolSelector","addTool","Brush","initControls","ColorPicker","BrushSizeSlider","hex","offsetBuffer","colorBuffer","gradientBuffer","getGradient","g1","g3","enableIndexBuffer","enablePositionBuffer","enableOffsetBuffer","enableColorBuffer","enableGradientBuffer","hexelColor","UNSIGNED_BYTE","gradient","loadHexels","loadLayout","brushRadius","current","appendHexagon","last","eventListener","onInit","btnEl","classList","addClickListener","onSelect","setAttribute","onDeselect","remove","removeAttribute","Tool","el","querySelector","valueAsNumber","slider","Slider","tooltip","on","getValue","onChange","tinycolor","setAlpha","toHex8String","$","spectrum","fromArgbString","onHide","resetAlpha","initPicker","initSlider","$picker","toArgbString","flat","showInput","showInitial","allowEmpty","showAlpha","disabled","showPalette","showPaletteOnly","togglePaletteOnly","showSelectionPalette","clickoutFiresChange","hideAfterPaletteSelect","preferredFormat","palette","change","hide","getAlpha","controls","control","tools","initTool","tool","setTool","select","deselect","selectedTool","__webpack_module_cache__","__webpack_require__","moduleId","exports","module","__webpack_modules__","call"],"mappings":"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","file":"index.js","sourcesContent":["import { Color, StructBuffer } from '..';\nimport { TypedArray } from './typed-array';\n\nexport type ColorfBuffer = ColorBuffer<Float32Array>;\n\nexport class ColorBuffer<T extends TypedArray> extends StructBuffer<T, Color.Like> implements Color.Like {\n\n    /** Creates a color buffer large enough to hold the specified number of colors. */\n    static withLength(n: number) {\n        return new this(new Uint8Array(n * 4));\n    }\n\n    get componentLength() {\n        return 4;\n    }\n\n    get r() { \n        return this.getComponent(0);\n    }\n\n    set r(value: number) {\n        this.setComponent(0, value);\n    }\n\n    get g() { \n        return this.getComponent(1);\n    }\n\n    set g(value: number) {\n        this.setComponent(1, value);\n    }\n\n    get b() { \n        return this.getComponent(2);\n    }\n\n    set b(value: number) {\n        this.setComponent(2, value);\n    }\n\n    get a() { \n        return this.getComponent(3);\n    }\n\n    set a(value: number) {\n        this.setComponent(3, value);\n    }\n\n    protected newStruct(data: T): Color.Like {\n        return new ColorBuffer(data);\n    }\n} \n","import { Mat2d, StructBuffer } from '..';\n\nexport class Mat2dBuffer extends StructBuffer<Float32Array, Mat2d.Like> implements Mat2d.Like {\n\n    /** Creates a mat2d buffer large enough to hold the specified number of mat2ds. */\n    static withLength(n: number) {\n        return new this(new Float32Array(n * 6));\n    }\n\n    get componentLength() {\n        return 6;\n    }\n\n    get c1r1() { \n        return this.getComponent(0);\n    }\n\n    set c1r1(value: number) {\n        this.setComponent(0, value);\n    }\n\n    get c1r2() { \n        return this.getComponent(1);\n    }\n\n    set c1r2(value: number) {\n        this.setComponent(1, value);\n    }\n\n    get c2r1() { \n        return this.getComponent(2);\n    }\n\n    set c2r1(value: number) {\n        this.setComponent(2, value);\n    }\n\n    get c2r2() { \n        return this.getComponent(3);\n    }\n\n    set c2r2(value: number) {\n        this.setComponent(3, value);\n    }\n\n    get c3r1() { \n        return this.getComponent(4);\n    }\n\n    set c3r1(value: number) {\n        this.setComponent(4, value);\n    }\n\n    get c3r2() { \n        return this.getComponent(5);\n    }\n\n    set c3r2(value: number) {\n        this.setComponent(5, value);\n    }\n\n    protected newStruct(data: Float32Array): Mat2d.Like {\n        return new Mat2dBuffer(data);\n    }\n} \n","import { TypedArray } from \"..\";\n\n\nexport abstract class StructBuffer<T extends TypedArray, S> {\n\n    private dataPosition = 0;\n\n    constructor(  \n        /** The primitive array data backing the Structs in this buffer.*/\n        public readonly data: T,\n    ) {}\n\n    /** The current position of this buffer */\n    get position() {\n        return this.dataPosition / this.componentLength;\n    }\n\n    set position(index: number) {\n        this.assertValidIndex(index);\n        this.dataPosition = index * this.componentLength;\n    }\n\n    private assertValidIndex(index: number) {\n        if (index < 0 || index >= this.length) {\n            throw \"Index \" + index + \" is out of bounds\";\n        }\n    }\n\n    /** @returns this buffer positioned at the specified index */\n    at(index: number): this {\n        this.position = index;\n        return this;\n    }\n\n    /** The number of structs in this buffer */\n    get length() {\n        return this.data.length / this.componentLength;\n    }\n\n    /** The number of components making up each struct. */\n    abstract get componentLength();\n\n    protected getComponent(index: number) {\n        return this.data[this.dataPosition + index];\n    }\n\n    protected setComponent(index: number, value: number) {\n        return this.data[this.dataPosition + index] = value;\n    }\n\n    /** Gets the struct at the specified index. */\n    get(index: number): S {\n        this.assertValidIndex(index);\n        let data = this.getStructData(index);\n        return this.newStruct(data);\n    }\n\n    protected abstract newStruct(data: T): S\n\n    private getStructData(index: number) {\n        let begin = index * this.componentLength;\n        let end = begin + this.componentLength;\n        return <T> this.data.subarray(begin, end);\n    }\n}","import { Point, Vec2, StructBuffer, Rect } from '..';\n\nexport class Vec2Buffer extends StructBuffer<Float32Array, Vec2.Like> implements Vec2.Like {\n\n    /** Creates a vec2 buffer large enough to hold the specified number of vec2s. */\n    static withLength(n: number) {\n        return new this(new Float32Array(n * 2));\n    }\n\n    get componentLength() {\n        return 2;\n    }\n\n    get x() { \n        return this.getComponent(0);\n    }\n\n    set x(value: number) {\n        this.setComponent(0, value);\n    }\n\n    get y() {\n        return this.getComponent(1);\n    }\n\n    set y(value: number) {\n        this.setComponent(1, value);\n    }\n\n    get bounds(): Rect\n    {\n        return this.length == 0 ? Rect.empty() : this.measureBounds(this.at(0));\n    }\n\n    /** Algorithm used when buffer contains at least one point (p0) */\n    private measureBounds(p0: Point.Like)\n    {\n        let bounds = Rect.dimensions(p0.x, p0.y, 0, 0);\n        for (let i = 1; i < this.length; i++) {\n            bounds.unionPoint(this.at(i));\n        }\n        return bounds;\n    }\n\n    protected newStruct(data: Float32Array): Vec2.Like {\n        return new Vec2Buffer(data);\n    }\n\n    /**\n     * Checks if a polygon (specified by a subset of vertices in this buffer) contains the specified point.\n     * @param x the x coordinate of the point to check.\n     * @param y the y coordinate of the point to check.\n     * @param offset the offset of the first polygon vertex. Defaults to zero.\n     * @param count the number of polygon vertices. Defaults to the number of vertices in this buffer.\n     */\n    containsPoint(p: Point.Like, offset = 0, count = this.length - offset) {\n        // Assume the point is not inside the polygon\n        let inside = false;\n\n        // Check point against each side of the polygon \n        let {x: x1, y: y1} = this.at(offset + count - 1);\n        while(count-- > 0){\n            let {x: x2, y: y2 } = this.at(offset++);\n            if((y1 > p.y) !== (y2 > p.y) && p.x < (x2 - x1) * (p.y - y1) / (y2 - y1) + x1){\n                inside = !inside; \n            }\n            x1 = x2; y1 = y2;\n        }\n\n        return inside;\n    }\n}\n","import { Surface, Point } from '..';\n\nexport const enum PointerStatus {\n    Down, Move, Up, Cancel,\n}\n\nexport class Pointer {\n    constructor(\n        public readonly id: number,\n        public readonly status: PointerStatus,\n        public readonly surface: Surface,\n        public readonly position: Point.Like,\n        public readonly isPrimary: boolean,\n        public readonly isDown: boolean,\n        public readonly activePointers: Pointer[],\n    ) {}\n}\n\nexport abstract class PointerEventListener {\n    wherePointer(p: Pointer) { return true; }\n    onPointerDown(p: Pointer) {}\n    onPointerMove(p: Pointer) {}\n    onPointerUp(p: Pointer) {}\n    onPointerCancel(p: Pointer) { this.onPointerUp(p); }\n}\n\nexport class PointerEventDetector {\n\n    public readonly activePointers = <Pointer[]> [];\n    private listeners = <PointerEventListener[]> [];\n\n    constructor(\n        private surface: Surface\n    ) {}\n\n    startListening() {\n        let { canvasEl } = this.surface;\n        canvasEl.addEventListener('pointerdown', this.onPointerDown);\n        canvasEl.addEventListener('pointermove', this.onPointerMove);\n        canvasEl.addEventListener('pointerup', this.onPointerUp);\n        canvasEl.addEventListener('pointercancel', this.onPointerCancel);\n    }\n\n    stopListening() {\n        let { canvasEl } = this.surface;\n        canvasEl.removeEventListener('pointerdown', this.onPointerDown);\n        canvasEl.removeEventListener('pointermove', this.onPointerMove);\n        canvasEl.removeEventListener('pointerup', this.onPointerUp);\n        canvasEl.removeEventListener('pointercancel', this.onPointerCancel);\n    }\n\n    addListener(listener: PointerEventListener) {\n        this.listeners.push(listener);\n    }\n\n    removeListener(listener: PointerEventListener) {\n        this.listeners = this.listeners.filter(l => l !== listener);\n    }\n\n    private onPointerDown = (e: PointerEvent) => {\n        let pointer = this.addPointer(e, PointerStatus.Down);\n        this.dispatchEvent(pointer, l => l.onPointerDown(pointer));\n    }\n\n    private onPointerMove = (e: PointerEvent) => {\n        let pointer = this.addPointer(e, PointerStatus.Move);\n        this.dispatchEvent(pointer, l => l.onPointerMove(pointer));\n    }\n  \n    private onPointerUp = (e: PointerEvent) => {\n        let pointer = this.addPointer(e, PointerStatus.Up);\n        this.dispatchEvent(pointer, l => l.onPointerUp(pointer));\n        this.removePointer(pointer);\n    }\n\n    private onPointerCancel = (e: PointerEvent) => {\n        let pointer = this.addPointer(e, PointerStatus.Cancel);\n        this.dispatchEvent(pointer, l => l.onPointerCancel(pointer));\n        this.removePointer(pointer);\n    }\n\n    private dispatchEvent(p: Pointer, invokeFn: (listener: PointerEventListener) => any) {\n        this.listeners.filter(l => l.wherePointer(p)).forEach(invokeFn);\n    }\n\n    private addPointer(e: PointerEvent, status: PointerStatus) {\n        let index = this.getPointerIndex(e.pointerId);\n        let isDown = status == PointerStatus.Down || !!this.activePointers[index]?.isDown;\n        let pointer = this.newPointer(e, status, isDown);\n        this.surface.canvasEl.setPointerCapture(pointer.id);\n        this.activePointers[index] = pointer;\n        return pointer;\n    }\n\n    private newPointer(e: PointerEvent, status: PointerStatus, isDown: boolean) {\n        return new Pointer(\n            e.pointerId, status, this.surface, \n            this.surface.mapScreenPointToWorld(e),\n            e.isPrimary, isDown, this.activePointers\n        );\n    }\n\n    private getPointerIndex(pointerId: number): number {\n        for (let i = 0; i < this.activePointers.length; i++) {\n            if (this.activePointers[i].id == pointerId) {\n                return i;\n            }\n        }\n        return this.activePointers.length;\n    }\n\n    private removePointer(pointer: Pointer) {\n        this.surface.canvasEl.releasePointerCapture(pointer.id);\n        this.activePointers.splice(this.getPointerIndex(pointer.id), 1);\n    }\n}","import { Surface, Point } from '..';\n\nexport const enum WheelStatus {\n    Down, Move, Up, Cancel,\n}\n\nexport class Wheel {\n    constructor(\n        public readonly deltaY,\n        public readonly surface: Surface,\n        public readonly position: Point.Like,\n    ) {}\n}\n\nexport interface WheelEventListener {\n    onWheel(w: Wheel);\n}\n\nexport class WheelEventDetector {\n\n    private listeners = <WheelEventListener[]> [];\n\n    constructor(\n        private surface: Surface\n    ) {}\n\n    startListening() {\n        this.surface.canvasEl.addEventListener('wheel', this.onWheel);\n    }\n\n    stopListening() {\n        this.surface.canvasEl.removeEventListener('wheel', this.onWheel);\n    }\n\n    addListener(listener: WheelEventListener) {\n        this.listeners.push(listener);\n    }\n\n    private onWheel = (e: WheelEvent) => {\n        e.preventDefault(); // TODO: maybe only prevent default if the onWheel function returns true?\n        let wheel = new Wheel(e.deltaY, this.surface, this.surface.mapScreenPointToWorld(e));\n        this.listeners.forEach(l => l.onWheel(wheel));\n    }\n}","export * as Color from './struct/color';\nexport * as ColorF from './struct/colorf';\nexport * as Ellipse from './struct/ellipse';\nexport * from './struct/line-segment';\nexport * as Mat2d from './struct/mat2d';\nexport * as Point from './struct/point';\nexport * from './struct/rect';\nexport * as Vec2 from './struct/vec2';\nexport * as Mat4 from './struct/mat4';\nexport * from './buffer/struct-buffer';\nexport * from './buffer/color-buffer';\nexport * from './buffer/mat2d-buffer';\nexport * from './buffer/typed-array';\nexport * from './buffer/vec2-buffer';\nexport * from './drawable/drawable';\nexport * from './model/mesh';\nexport * from './model/polygon-mesh';\nexport * from './program/program-util';\nexport * from './program/program';\nexport * from './program/fill-program';\nexport * from './model/model';\nexport * from './model/polygon-model';\nexport * from './model/ellipse-model';\nexport * from './event/screen-point';\nexport * from './rendering/camera';\nexport * from './rendering/renderer';\nexport * from './rendering/surface';\nexport * from './event/pointer-event';\nexport * from './event/wheel-event';\nexport * from './tool/stroke';\nexport * from './tool/wheel-zoom-tool';\nexport * from './tool/pan-tool';\nexport * from './tool/pinch-zoom-tool';","import { Mat2d, Rect, Renderer, PolygonModel, Point, Vec2 } from '..';\nimport { EllipseProgram } from '../program/ellipse-program';\n\nexport class EllipseModel extends PolygonModel {\n\n    /**\n     * Measures the boundaries of a unit circle transformed to an ellipse by the specified matrix.\n     * @param matrix the transformation matrix.\n     */\n    static measureBoundaries(matrix: Mat2d.Like): Rect {\n        // Performs singular value decomposition of the model matrix to extract\n        // (1) The length of the semi-x axis (sx), which is equal to the first singular value in the Sigma matrix\n        // (2) The length of the semi-y axis (sy), which is equal to the second singular value in the Sigma matrix\n        // (3) The rotation angle (phi), from -PI/2 to PI/2, which is equal to the angle used to form the U matrix\n        // Boundaries are then meausure with the formula:\n        // x = (sx)^2 * (cos(phi)^2) + (sy)^2*(sin(phi)^2)\n        // y = (sx)^2 * (sin(phi)^2) + (sy)^2*(cos(phi)^2)\n        // left = tx - x, right = tx + x, bottom = ty - y, top = ty + y\n        let { c1r1: a, c2r1: b, c3r1: tx, c1r2: c, c2r2: d, c3r2: ty } = matrix;\n\n        // Helper variables:\n        let a2 = a*a;\n        let b2 = b*b;\n        let c2 = c*c;\n        let d2 = d*d;\n        let m = a*c + b*d;\n        let n = a2 + b2 - c2 - d2;\n\n        // Cos and sin of angle squared:\n        let phi = 0.5 * Math.atan2(2*m, n);\n        let cos2 = Math.pow(Math.cos(phi), 2);\n        let sin2 = Math.pow(Math.sin(phi), 2);\n\n        // Length of axes squared:\n        let s1 = a2 + b2 + c2 + d2;\n        let s2 = Math.sqrt(n*n + 4*m*m);\n        let sx2 = 0.5 * (s1 + s2);\n        let sy2 = 0.5 * (s1 - s2);\n\n        // Boundaries:\n        let x = Math.sqrt(sx2*cos2 + sy2*sin2);\n        let y = Math.sqrt(sx2*sin2 + sy2*cos2);\n        return Rect.copy({ \n            left: tx - x, right: tx + x, \n            top: ty + y, bottom: ty - y \n        });\n    }\n\n    constructor(matrix?: Mat2d.Like) {\n        super(EllipseProgram.mesh, matrix);\n    }\n\n    get bounds(): Rect {\n        return EllipseModel.measureBoundaries(this.matrix);\n    }\n\n    set bounds(dst: Rect) { // Preserves orientation\n        this.transform(Mat2d.rectToRect(this.bounds, dst));\n    }\n\n    /** Checks if this ellipse contains the specified point. */\n    contains(p: Point.Like) {\n        let modelPoint = this.mapPointToModelSpace(p);\n        if(this.mesh.bounds.containsPoint(modelPoint)){\n            return Vec2.length2(modelPoint) <= 1;\n        } \n        return false;\n    }\n}\n","import { Point, Rect, Vec2, Vec2Buffer } from \"..\";\n\n/** Stores static vertex and index data that multiple graphics can share. */\nexport abstract class Mesh {\n\n    public readonly bounds = this.vertices.bounds;\n\n    public miters?: Vec2Buffer;\n\n    /** The byte offset of this mesh's vertex data in a vertex buffer (if any). */\n    public vertexBufferOffset?: number;\n\n    /** The byte offset of this mesh's index data in an element buffer (if any). */\n    public indexBufferOffset?: number;\n\n    /** The byte offset of this mesh's stroke vertex data in a vertex buffer (if any). */\n    public strokeVertexBufferOffset?: number;\n\n    /** The byte offset of this mesh's stroke index data in an element buffer (if any). */\n    public strokeIndexBufferOffset?: number;\n\n    /** The number of indices used to render the stroke (if any). */\n    public strokeIndexCount?: number;\n\n    /** The byte offset of this mesh's miter data in an element buffer (if any). */\n    public miterBufferOffset?: number;\n\n    constructor(\n        /** Vertices in model space, centered at the origin */\n        public readonly vertices: Vec2Buffer,\n        /** Triangle indices for this mesh */\n        public readonly indices?: Uint16Array,\n    ) {}\n\n    /** Checks if this mesh contains the specified point */\n    abstract containsPoint(p: Point.Like): boolean;\n}","import { Drawable, Mat2d, Point, Rect, Vec2, Renderer } from \"..\";\n\n/** A graphic that can be transformed by altering its 2d model matrix. */\nexport abstract class Model {\n\n    constructor(\n        /** 2d matrix that maps this graphic from model space to world space. */\n        public readonly matrix: Mat2d.Like\n    ) {}\n\n    /** \n     * Measures the position of this graphic's center point in world space. \n     * Assumes the model for the graphic is centered at the origin.\n     **/\n    get center(): Point.Like {\n        return { x: this.matrix.c3r1, y: this.matrix.c3r2 };\n    }\n\n    /**\n     * Centers this graphic at the specified point in world space.\n     * Assumes the model for the graphic is centered at the origin.\n     */\n    set center({x, y}: Point.Like) {\n        this.matrix.c3r1 = x;\n        this.matrix.c3r2 = y;\n    }\n\n    /** Measures the boundaries of this graphic in world space. */\n    abstract get bounds(): Rect;\n\n    /** Converts a point in this graphic's model space to a point in world space. */\n    mapPointToWorldSpace(modelPoint: Point.Like, out = <Point.Like> {}) {\n        return Mat2d.mapPoint(this.matrix, modelPoint, out);\n    }\n\n    /** Converts a point in world space to a point in this graphic's model space. */\n    mapPointToModelSpace(worldPoint: Point.Like, out = <Point.Like> {}){\n        return Mat2d.mapPoint(Mat2d.invert(this.matrix), worldPoint, out);\n    }\n\n    /** Checks if this graphic contains the specified point. */\n    abstract containsPoint(p: Point.Like): boolean;\n   \n    /** Transforms this graphic by the specified matrix. */\n    transform(m: Mat2d.Like) {\n        Mat2d.concat(m, this.matrix, this.matrix);\n    }\n\n    /** Translates this graphic by the specified vector. */\n    translate(v: Vec2.Like) {\n        this.transform(Mat2d.translate(v));\n    }\n\n    /** Scales this graphic by the specified vector, with a pivot point at its center.  */\n    scale(v: Vec2.Like){\n        this.transform(Mat2d.pivot(Mat2d.scale(v), this.center));\n    }\n\n    /** Stretches this graphic by the specified factor, with a pivot point at its center. */\n    stretch(factor: number){\n        this.transform(Mat2d.pivot(Mat2d.stretch(factor), this.center))\n    }\n\n    /** Rotates this graphic by the specified angle, with a pivot point at its center. */\n    rotate(radians: number){\n        this.transform(Mat2d.pivot(Mat2d.rotate(radians), this.center));\n    }\n}","import { Point, Mat2d, Vec2, Vec2Buffer, Mesh, Rect } from '..';\n\nexport class PolygonMesh extends Mesh {\n\n    static regularPolygon(n: number, flatTop = false) {\n        return new PolygonMesh(this.regularVertices(n, flatTop), this.regularIndices(n));\n    }\n\n    /**\n     * Generates the vertices for a regular polygon centered at (0,0).\n     * @param n how many sides the polygon should have.\n     * @param isFlatTopped whether the polygon is flat-topped (true) or pointy-topped (false). Defaults to false.\n     */\n    static regularVertices(n: number, flatTop = false) {\n        // Create a buffer large enough to hold the n vertices\n        let vertices = Vec2Buffer.withLength(n);\n        // Create a matrix to rotate from vertex to vertex\n        let angle = 2 * Math.PI / n;\n        let rotation = Mat2d.rotate(angle)\n        // Begin with the vertex (0,1), rotating for flat top polygon if requested\n        let v = vertices.get(0); v.y = 1;\n        if (flatTop) {\n            Mat2d.mapPoint(Mat2d.rotate(angle / 2), v, v);\n        }\n        // Keep rotating the point and adding to buffer till it is full\n        for (let i = 1; i < n; i++) {\n            Mat2d.mapPoint(rotation, vertices.get(i - 1), vertices.at(i));\n        }\n        return vertices;\n    }\n\n    /**\n     * Generates the indices for a regular polygon with n sides.\n     * The resulting index array will have have 3*(n-2) indices.\n     * @param n how many sides the mesh should have.\n     */\n    static regularIndices(n: number) {\n        let indices = new Uint16Array(3 * (n - 2));\n        for (let i = 0; i < n; i++) {\n            indices[3 * i + 1] = i + 1;\n            indices[3 * i + 2] = i + 2;\n        }\n        return indices;\n    }\n\n    /**\n     * Creates the mesh for a rectangle\n     * @param id an optional id for the mesh.\n     */\n    static rectangle(r: Rect) {\n        let vertices = PolygonMesh.rectangleVertices(r);\n        let indices = PolygonMesh.regularIndices(4);\n        return new PolygonMesh(vertices, indices);\n    }\n\n    /**\n      * Extracts the vertices from the specified rect into a new vertex buffer.\n      * @param rect the rect from which to extract the vertices.\n      */\n    static rectangleVertices(r: Rect) {\n        let vertices = Vec2Buffer.withLength(4);\n        r.topLeft(vertices.at(0));\n        r.bottomLeft(vertices.at(1));\n        r.bottomRight(vertices.at(2));\n        r.topRight(vertices.at(3));\n        return vertices;\n    }\n\n    /**\n     * Creates the mesh for a star with n points and the specified inner and outer radii.\n     * @param n how many points the star should have.\n     * @param ratio ratio of the inner radius to the outer radius.\n     */\n    static star(n: number, ratio: number) {\n        let vertices = PolygonMesh.starVertices(n, ratio);\n        let indices = PolygonMesh.starIndices(n);\n        return new PolygonMesh(vertices, indices);\n    }\n\n    /**\n     * Generates the vertices for a star centered at (0,0).\n     * @param points how many points the star should have.\n     * @param ratio ratio of the inner radius to the outer radius.\n     */\n    static starVertices(points: number, ratio: number) {\n        // Create vertex buffer big enough to hold the n inner vertices and n outer vertices\n        let vertices = Vec2Buffer.withLength(points + points);\n        // Calculate the rotation angle\n        let angle = 2 * Math.PI / points;\n        let rotation = Mat2d.rotate(angle);\n        // Start with (0, 1) as the outer vertex\n        vertices.y = 1;\n        // Scale by the specified ratio and rotate by half the angle to get the first inner vertex\n        Mat2d.mapPoint(Mat2d.rotate(0.5 * angle), { x: 0, y: ratio }, vertices.at(1));\n        // Keep rotating the inner and outer vertices and adding them to the buffer until it is full.\n        for (let i = 2; i < vertices.length; i++) {\n            Mat2d.mapPoint(rotation, vertices.get(i - 2), vertices.at(i));\n        }\n        return vertices;\n    }\n\n    /**\n     * Generates the indices for a star with n points.\n     * The star will have 3*(n-2) inner indices and 3n outer indices.\n     * @param n how many points the star should have.\n     */\n    static starIndices(n: number) {\n        // Create an array big enough to hold all the indices\n        let innerIndexCount = 3 * (n - 2);\n        let outerIndexCount = 3 * n;\n        let indices = new Uint16Array(innerIndexCount + outerIndexCount);\n        // Compute inner indices and add to array\n        let first = 1, second = 3, third = 5;\n        for (let i = 0; i < innerIndexCount; second += 2, third += 2) {\n            indices[i++] = first;\n            indices[i++] = second;\n            indices[i++] = third;\n        }\n        // Computer outer indices and add to array\n        first = 2 * n - 1; second = 0; third = 1;\n        for (let i = 0; i < outerIndexCount; i++, first = third++, second = third++) {\n            indices[i++] = first;\n            indices[i++] = second;\n            indices[i++] = third;\n        }\n        // Return the indices\n        return indices;\n    }\n\n    static miters(vertices: Vec2Buffer){\n        let length = vertices.length, lastIndex = length - 1;\n        let miters = Vec2Buffer.withLength(length);\n        let prev = Vec2.copy(vertices.at(lastIndex));\n        let curr = Vec2.copy(vertices.at(0));\n        let line1 = Vec2.fromPointToPoint(prev, curr);\n        let line2 = <Vec2.Like> {};\n        for (let i = 0; i < length; i++) {\n            Vec2.copy(curr, prev);\n            Vec2.copy(vertices.at((i + 1) % lastIndex), curr);\n            Vec2.fromPointToPoint(prev, curr, line2);\n            Vec2.miter(line1, line2, 1, 3, miters.at(i));\n            Vec2.copy(line2, line1);\n        }\n        return miters;\n    }\n\n    public readonly miters = PolygonMesh.miters(this.vertices);\n\n    containsPoint(p: Point.Like): boolean {\n        return this.vertices.containsPoint(p);\n    }\n}\n\n","import { Model, Mesh, Mat2d, Rect, Point, LineSegment, Vec2 } from \"..\";\n\n/** Shape defined by matrix transformation of a mesh. */\nexport class PolygonModel extends Model {\n    \n    /**\n     * Creates a shape with the specified mesh data and initial transformation matrix.\n     * @param mesh the static vertex and index data data for this shape.\n     * @param matrix the initial transformation matrix. Defaults to identiy.\n     */\n    constructor(\n        public readonly mesh: Mesh, matrix = Mat2d.identity()){\n        super(matrix);\n    }\n\n    get bounds(): Rect {\n        let { vertices } = this.mesh;\n        let { x, y } = this.mapPointToWorldSpace(vertices.at(0));\n        let bounds = Rect.dimensions(x, y, 0, 0);\n        for (let i = 1; i < vertices.length; i++) {\n            bounds.unionPoint(this.mapPointToWorldSpace(vertices.at(i)));\n        }\n        return bounds;\n    }\n\n    set bounds(dst: Rect) { // Preserves orientation\n        this.transform(Mat2d.rectToRect(this.bounds, dst));\n    }\n\n    /** Get the position of the vertex at the specified index */\n    vertexAt(index: number, out = <Vec2.Like> {}) {\n        return this.mapPointToWorldSpace(this.mesh.vertices.at(index), out);\n    }\n\n    containsPoint(p: Point.Like): boolean {\n        return this.mesh.containsPoint(this.mapPointToModelSpace(p));\n    }\n\n    /** Scales this shape to fit inside the destination rect using the specified scale to fit option */\n    scaleToFit(dst: Rect, stf = Mat2d.ScaleToFit.Fill) {\n        Mat2d.rectToRect(this.mesh.bounds, dst, stf, this.matrix);\n    }\n\n    /** Stretch-rotates this shape across the specified line segment */\n    stretchAcross({p1, p2}: LineSegment) {\n        // Translate center top to p1\n        let b = this.mesh.bounds;\n        let cx = b.centerX;\n        let v = Vec2.fromPointToPoint({ x: cx, y: b.top }, p1);\n        let t = Mat2d.translate(v, this.matrix);\n        \n        // Stretch rotate from (translated) center bottom to p2, with pivot point at p1\n        let c = Mat2d.mapPoint(t, {x: cx, y: b.bottom});\n        let s = Mat2d.stretchRotateToPoint(c, p2, p1);\n        this.transform(s);\n    }\n}","import { ColorfBuffer, Mat2dBuffer, Program, ProgramUtil, PolygonMesh, Rect, Renderer } from '..';\nimport * as Shader from './ellipse-shader'\n\n/** Program for rendering ellipses. */\nexport class EllipseProgram extends Program<Shader.Uniforms, Shader.Attributes> {\n\n    static readonly mesh = PolygonMesh.rectangle(Rect.dimensions(-1, 1, 2, 2));\n\n    private positionBuffer: WebGLBuffer;\n    private matrixBuffer: WebGLBuffer;\n\n    public fillColor: ColorfBuffer;\n    public strokeColor: ColorfBuffer;\n    public lineWidth: number;\n    \n    static create(util: ProgramUtil) {\n        let program = new EllipseProgram;\n        program.location = util.createProgramFromSources(Shader.vertex, Shader.fragment);\n        program.uniforms = util.getUniformLocationMap(program.location, Shader.uniformRenaming) as Shader.Uniforms;\n        program.attribs = util.getAttributeLocationMap(program.location, Shader.attributeRenaming) as Shader.Attributes;\n        program.positionBuffer = util.createArrayBuffer(EllipseProgram.mesh.vertices.data);\n        program.matrixBuffer = util.createBuffer();\n        return program;\n    }\n\n    onAttach({gl, angleExt}: Renderer) {\n        let c1 = this.attribs.model;\n        let c2 = c1 + 1;\n        let c3 = this.attribs.offset;\n\n        // Enable blending (for transparency)\n        gl.enable(gl.BLEND);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n        gl.enableVertexAttribArray(this.attribs.position);\n        gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 0, 0);\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.matrixBuffer);\n\n        gl.enableVertexAttribArray(c1);\n        gl.enableVertexAttribArray(c2);\n        gl.enableVertexAttribArray(c3);\n        \n        angleExt.vertexAttribDivisorANGLE(c1, 1);\n        angleExt.vertexAttribDivisorANGLE(c2, 1);\n        angleExt.vertexAttribDivisorANGLE(c3, 1);\n    }\n\n    onDetach({angleExt}: Renderer) {\n        let c1 = this.attribs.model;\n        let c2 = c1 + 1;\n        let c3 = this.attribs.offset;\n\n        angleExt.vertexAttribDivisorANGLE(c1, 0);\n        angleExt.vertexAttribDivisorANGLE(c2, 0);\n        angleExt.vertexAttribDivisorANGLE(c3, 0);       \n    }\n\n    draw(renderer: Renderer, matrices: Mat2dBuffer) {\n        let {gl, angleExt, camera } = renderer;\n        renderer.useProgram(this);\n        this.loadProjection(gl, camera.matrix);\n        this.loadMatrices(gl, matrices);\n        this.loadFillColor(gl);\n        this.loadStrokeColor(gl);\n        this.loadLineWidth(gl);\n        angleExt.drawArraysInstancedANGLE(gl.TRIANGLE_FAN, 0, 4, matrices.length);\n    }\n\n    private loadProjection(gl: WebGLRenderingContext, projection: Float32Array) {\n        gl.uniformMatrix4fv(this.uniforms.projection, false, projection);\n    }\n\n    /** Sets the matrix for each ellipse instance.*/\n    private loadMatrices(gl: WebGLRenderingContext, matrices: Mat2dBuffer) {\n        // Note: assumes \n        // (1) matrix buffer is already bound\n        // (2) attrib arrays are already enabled\n        // (3) attrib divisors have already been specified\n        let c1 = this.attribs.model;\n        let c2 = c1 + 1;\n        let c3 = this.attribs.offset;\n        \n        // Load data into WebGL\n        gl.bufferData(gl.ARRAY_BUFFER, matrices.data, gl.DYNAMIC_DRAW);\n\n        // Set first column vector (part of mat2)\n        gl.vertexAttribPointer(c1, 2, gl.FLOAT, false, 24, 0);\n        \n        // Set second column vector (part of mat2)\n        gl.vertexAttribPointer(c2, 2, gl.FLOAT, false, 24, 8);\n\n        // Set third column vector (separate vec2)\n        gl.vertexAttribPointer(c3, 2, gl.FLOAT, false, 24, 16);\n    }\n\n    /** Loads the fill color for the ellipse batch into this program. */\n    private loadFillColor(gl: WebGLRenderingContext) {\n        gl.uniform4fv(this.uniforms.fillColor, this.fillColor.data);\n    }\n\n    /** Loads the stroke color for the ellipse batch into this program. */\n    private loadStrokeColor(gl: WebGLRenderingContext) {\n        gl.uniform4fv(this.uniforms.strokeColor, this.strokeColor.data);\n    }\n\n    /** Loads the width of the lines making up the stroke. */\n    private loadLineWidth(gl: WebGLRenderingContext) {\n        gl.uniform1f(this.uniforms.lineWidth, this.lineWidth);\n    }\n}","export interface Uniforms {\n    readonly [name: string]: WebGLUniformLocation;\n    projection: WebGLUniformLocation;\n    lineWidth: WebGLUniformLocation;\n    fillColor: WebGLUniformLocation;\n    strokeColor: WebGLUniformLocation;\n}\n\nexport interface Attributes {\n    readonly [name: string]: number;\n    model: number;\n    offset: number;\n    position: number;\n}\n\nexport type Variables = Uniforms|Attributes;\n\nexport const vertex = \"precision mediump float;uniform mat4 z;uniform float s;attribute mat2 c;attribute vec2 v,h;varying vec2 f,e;mat2 i(float a){float b=sin(a),d=cos(a);return mat2(d,b,-b,d);}void main(){float j=c[0].x,k=c[1].x,l=c[0].y,m=c[1].y,a=(j+m)/2.,b=(j-m)/2.,d=(l+k)/2.,g=(l-k)/2.,n=sqrt(a*a+g*g),o=sqrt(b*b+d*d),A=n+o,p=n-o,q=atan(d,b),r=atan(g,a),w=(r-q)/2.,x=(r+q)/2.;mat2 t=i(x),u=i(w);t[1]*=sign(p),p=abs(p);vec2 y=t*(s*(u*h)),B=c*h+v+y;gl_Position=z*vec4(B,1.,1.),e=u*h,f=e*(1.+s/vec2(A,p));}\", fragment = \"precision mediump float;uniform vec4 C,D;varying vec2 f,e;void main(){bool a=dot(f,f)<1.,b=dot(e,e)<1.;gl_FragColor=a?C:b?D:vec4(0.);}\", attributeRenaming = {\"model\":\"c\",\"offset\":\"v\",\"position\":\"h\"}, uniformRenaming = {\"projection\":\"z\",\"lineWidth\":\"s\",\"fillColor\":\"C\",\"strokeColor\":\"D\"};\n","import { Program, ColorfBuffer, Mesh, Renderer, ProgramUtil, Mat2dBuffer, Vec2Buffer } from \"..\";\nimport * as Shader from './fill-shader'\n\n/**  Program for rendering polygons filled with a uniform color. */\nexport class FillProgram extends Program<Shader.Uniforms, Shader.Attributes> {\n\n    public color: ColorfBuffer;\n\n    private indexBuffer: WebGLBuffer;\n    private positionBuffer: WebGLBuffer;\n    private matrixBuffer: WebGLBuffer;\n    private dynamicBuffer: WebGLBuffer;\n    \n    static create(util: ProgramUtil, meshes: Mesh[]) {\n        let program = new FillProgram;\n        program.location = util.createProgramFromSources(Shader.vertex, Shader.fragment);\n        program.uniforms = util.getUniformLocationMap(program.location, Shader.uniformRenaming) as Shader.Uniforms;\n        program.attribs = util.getAttributeLocationMap(program.location, Shader.attributeRenaming) as Shader.Attributes;\n        program.indexBuffer = util.createIndexBuffer(meshes);\n        program.positionBuffer = util.createVertexBuffer(meshes);\n        program.matrixBuffer = util.createBuffer();\n        program.dynamicBuffer = util.createBuffer();\n        return program;\n    }\n\n    onAttach({ gl, angleExt }: Renderer) {\n        let column1 = this.attribs.model;\n        let column2 = column1 + 1;\n        let column3 = this.attribs.offset;\n\n        gl.enable(gl.BLEND);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n        gl.enableVertexAttribArray(this.attribs.position);\n\n        // Enable a separate array for each column of the 3x2 model matrix\n        gl.enableVertexAttribArray(column1);\n        gl.enableVertexAttribArray(column2); \n        gl.enableVertexAttribArray(column3);\n        \n        // Only change the model matrix when the instance changes\n        angleExt.vertexAttribDivisorANGLE(column1, 1); \n        angleExt.vertexAttribDivisorANGLE(column2, 1);\n        angleExt.vertexAttribDivisorANGLE(column3, 1);\n    }\n\n    onDetach({angleExt}: Renderer){\n        let column1 = this.attribs.model;\n        let column2 = column1 + 1;\n        let column3 = this.attribs.offset;\n\n        // Disable instancing of 3x2 model matrix (because it affects global state)\n        angleExt.vertexAttribDivisorANGLE(column1, 0);\n        angleExt.vertexAttribDivisorANGLE(column2, 0);\n        angleExt.vertexAttribDivisorANGLE(column3, 0);    \n    }\n\n    draw(renderer: Renderer, mesh: Mesh, matrices: Mat2dBuffer) {\n        let {gl, angleExt} = renderer;\n        renderer.useProgram(this);\n        this.loadProjection(gl, renderer.camera.matrix);\n        this.loadColor(gl);\n        this.loadVertices(gl, mesh);\n        this.loadMatrices(gl, matrices);\n        if (mesh.indices) {\n            angleExt.drawElementsInstancedANGLE(gl.TRIANGLES, mesh.indices.length, gl.UNSIGNED_SHORT, mesh.indexBufferOffset, matrices.length)\n        } else {\n            angleExt.drawArraysInstancedANGLE(gl.TRIANGLES, 0, mesh.vertices.length, matrices.length);\n        }\n    }\n\n    drawTriangleStrip(renderer: Renderer, vertices: Vec2Buffer, matrices: Mat2dBuffer) {\n        let { gl, angleExt } = renderer;\n        renderer.useProgram(this);\n        this.loadProjection(gl, renderer.camera.matrix);\n        this.loadColor(gl);\n        this.loadLineVertices(gl, vertices);\n        this.loadMatrices(gl, matrices);\n        angleExt.drawArraysInstancedANGLE(gl.TRIANGLE_STRIP, 0, vertices.length, matrices.length);\n    }\n\n    private loadProjection(gl: WebGLRenderingContext, projection: Float32Array) {\n        gl.uniformMatrix4fv(this.uniforms.projection, false, projection);\n    }\n\n    /** Loads the fill color into this program. */\n    private loadColor(gl: WebGLRenderingContext) {\n        gl.uniform4fv(this.uniforms.color, this.color.data);\n    }\n\n    private loadVertices(gl: WebGLRenderingContext, mesh: Mesh) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n        gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 0, mesh.vertexBufferOffset);\n    }\n\n    private loadLineVertices(gl: WebGLRenderingContext, vertices: Vec2Buffer) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.dynamicBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, vertices.data, gl.DYNAMIC_DRAW);\n        gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 0, 0);\n    }\n\n    /** Sets the matrix for each ellipse instance.*/\n    private loadMatrices(gl: WebGLRenderingContext, matrices: Mat2dBuffer) {\n        let column1 = this.attribs.model;\n        let column2 = column1 + 1;\n        let column3 = this.attribs.offset;\n\n        // Load data into WebGL\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.matrixBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, matrices.data, gl.DYNAMIC_DRAW);\n\n        // Set each column of the 3x2 model matrix\n        gl.vertexAttribPointer(column1, 2, gl.FLOAT, false, 24, 0);\n        gl.vertexAttribPointer(column2, 2, gl.FLOAT, false, 24, 8);\n        gl.vertexAttribPointer(column3, 2, gl.FLOAT, false, 24, 16);\n    }\n}\n","export interface Uniforms {\n    readonly [name: string]: WebGLUniformLocation;\n    projection: WebGLUniformLocation;\n    color: WebGLUniformLocation;\n}\n\nexport interface Attributes {\n    readonly [name: string]: number;\n    model: number;\n    offset: number;\n    position: number;\n}\n\nexport type Variables = Uniforms|Attributes;\n\nexport const vertex = \"precision mediump float;uniform mat4 d;attribute mat2 a;attribute vec2 b,c;void main(){vec2 e=a*c+b;gl_Position=d*vec4(e,1.,1.);}\", fragment = \"precision mediump float;uniform vec4 f;void main(){gl_FragColor=f;}\", attributeRenaming = {\"model\":\"a\",\"offset\":\"b\",\"position\":\"c\"}, uniformRenaming = {\"projection\":\"d\",\"color\":\"f\"};\n","import { AttributeLocationMap, UniformLocationMap, Mesh, TypedArray } from \"..\";\n\nexport type ArraySize = number | BufferSource;\nexport type ElementArraySize = number | ArrayBuffer | Uint8Array | Uint16Array;\n\n/** Maps the name of a uniform or attribute to it's minified renaming. */\nexport interface Renaming {\n    [key: string]: string;\n}\n\n/** Contains convenience functions for creating programs and loading data into them. */\nexport class ProgramUtil {\n\n    constructor(public gl: WebGLRenderingContext) { }\n\n    createBuffer() {\n        return this.gl.createBuffer();\n    }\n\n    /**\n     * Creates an array buffer with the specified size.\n     * @param size the size of the array buffer, or the initial data for the buffer.\n     * @param usage one of gl.STATIC_DRAW (often used, seldom changed), gl.DYNAMIC_DRAW (often used, often changed), or gl.STREAM_DRAW (seldom used).\n     */\n    createArrayBuffer(size: ArraySize, usage = this.gl.STATIC_DRAW) {\n        let gl = this.gl, buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, <any>size, usage);\n        return buffer;\n    }\n\n    /**\n     * Creates an element buffer with the specified size.\n     * @param size the size of the element buffer, or the initial data for the buffer.\n     * @param usage one of gl.STATIC_DRAW (often used, seldom changed), gl.DYNAMIC_DRAW (often used, often changed), or gl.STREAM_DRAW (seldom used).\n     */\n    createElementBuffer(size: ElementArraySize, usage = this.gl.STATIC_DRAW) {\n        let gl = this.gl, buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, <any>size, usage);\n        return buffer;\n    }\n\n    /** Packs mesh vertices into a single vertex buffer, saving the offsets. */\n    createVertexBuffer(meshes: Mesh[]) {\n        // Create an array buffer big enough to hold all the vertices\n        let gl = this.gl;\n        let size = this.sizeOfVertexBuffer(meshes);\n        let buffer = this.createArrayBuffer(size, gl.STATIC_DRAW);\n\n        // Pack the vertices into the buffer, saving the byte offsets\n        let offset = 0;\n        for (let mesh of meshes) {\n            let data = mesh.vertices.data;\n            gl.bufferSubData(gl.ARRAY_BUFFER, offset, data);\n            mesh.vertexBufferOffset = offset;\n            offset += data.byteLength;\n        }\n\n        return buffer;\n    }\n\n    private sizeOfVertexBuffer(meshes: Mesh[]) {\n        return meshes.reduce((total: number, mesh: Mesh) => total + mesh.vertices.data.byteLength, 0);\n    }\n\n    /** Packs mesh indices into a single buffer, saving the offsets. */\n    createIndexBuffer(meshes: Mesh[]) {\n\n        // Create an array buffer big enough to hold all the indices\n        let gl = this.gl;\n        let size = this.sizeOfIndexBuffer(meshes)\n        let buffer = this.createElementBuffer(size, gl.STATIC_DRAW);\n\n        // Pack the indices into the buffer, saving the byte offsets\n        let offset = 0;\n        for (let mesh of meshes) {\n            let data = mesh.indices;\n            gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, offset, data);\n            mesh.indexBufferOffset = offset;\n            offset += data.byteLength;\n        }\n\n        return buffer;\n    }\n\n    private sizeOfIndexBuffer(meshes: Mesh[]) {\n        return meshes.reduce((total: number, mesh: Mesh) => total + mesh.indices.byteLength, 0);\n    }\n\n    createMiterBuffer(meshes: Mesh[]) {\n        // Create an array buffer big enough to hold all the miters, including the \"zero\" miters used on the inner vertices\n        let gl = this.gl;\n        let size = this.sizeOfStrokeVertexBuffer(meshes);\n        let buffer = this.createArrayBuffer(size);\n\n        // Pack the vertices into the buffer, saving the byte offsets\n        let offset = 0;\n        let data: Float32Array;\n        for (let mesh of meshes) {\n            mesh.miterBufferOffset = offset;\n            offset += mesh.vertices.data.byteLength; // leave zeros for miters applied to inner vertices\n            data = mesh.miters.data;\n            gl.bufferSubData(gl.ARRAY_BUFFER, offset, data);\n            offset += data.byteLength; \n        }\n\n        return buffer;\n    }\n\n    createStrokeIndexBuffer(meshes: Mesh[]) {\n        // Ex: Let polygon p = [v0,v1,v2]\n        // -> indexCount =  2 * (p.length + 1) = 2 * 2 * (3 + 1) = 8\n        // -> indices = [[0,3], [1,4], [2,5], [0,3]]\n        // -> size = sizeof(short) * indexCount = 2 bytes * 8 = 16 bytes\n\n        // Create a Uint16Array big enough to hold all the indices\n        let indexCount = this.lengthOfStrokeIndexArray(meshes);\n        let indices = new Uint16Array(indexCount);\n        let position = 0;\n\n        for(let mesh of meshes){\n            let vertexCount = mesh.vertices.length; \n            mesh.strokeIndexCount = 2 * (vertexCount + 1);\n            mesh.strokeIndexBufferOffset = position * 2; // sizeof(short)\n            // Line to each point on path\n            for(let i = 0; i < vertexCount; i++){\n                indices[position++] = i + vertexCount;\n                indices[position++] = i;\n            }\n            // Close path\n            indices[position++] = vertexCount;\n            indices[position++] = 0;\n        }\n\n        return this.createElementBuffer(indices, this.gl.STATIC_DRAW);\n    }\n\n    private lengthOfStrokeIndexArray(meshes: Mesh[]) {\n        return meshes.reduce((total: number, mesh: Mesh) => total + (2 * (mesh.vertices.length + 1)), 0);\n    }\n\n    createStrokeVertexBuffer(meshes: Mesh[]){\n        // Create an array buffer big enough to hold all the vertices and all the miters\n        let gl = this.gl;\n        let size = this.sizeOfStrokeVertexBuffer(meshes);\n        let buffer = this.createArrayBuffer(size);\n\n        // Pack the vertices into the buffer, saving the byte offsets\n        let offset = 0;\n        for (let mesh of meshes) {\n            // Inner vertices (will be offset by a \"zero\" miter)\n            let data = mesh.vertices.data;\n            gl.bufferSubData(gl.ARRAY_BUFFER, offset, data);\n            mesh.strokeVertexBufferOffset = offset;\n            // Outer vertices (will be offset by miter)\n            offset += data.byteLength;\n            gl.bufferSubData(gl.ARRAY_BUFFER, offset, data);\n            offset += data.byteLength;\n        }\n\n        return buffer;\n    }\n\n    private sizeOfStrokeVertexBuffer(meshes: Mesh[]) {\n        let innerVertexSize = this.sizeOfStrokeVertexBuffer(meshes);\n        let outerVertexSize = meshes.reduce((total: number, m: Mesh) => total + m.miters.data.byteLength, 0);\n        return innerVertexSize + outerVertexSize;\n    }\n\n    /**\n     * Creates a program from 2 shaders.\n     * @param  vertexShaderSource string containing code for the vertex shader.\n     * @param  fragmentShaderSource string containing code for the fragment shader.\n     * @returns the program.\n     */\n    createProgramFromSources(vertexShaderSource: string, fragmentShaderSource: string) {\n        // Compile vertex and fragment shader\n        let vs = this.compileShader(vertexShaderSource, this.gl.VERTEX_SHADER);\n        let fs = this.compileShader(fragmentShaderSource, this.gl.FRAGMENT_SHADER);\n        // Create program and return\n        return this.createProgramFromShaders(vs, fs);\n    };\n\n    /**\n     * Creates a program from 2 shaders.\n     * @param  vertexShader a compiled vertex shader.\n     * @param  fragmentShader a compiled fragment shader.\n     * @returns the program.\n     */\n    createProgramFromShaders(vertexShader: WebGLShader, fragmentShader: WebGLShader) {\n        // create a program.\n        let gl = this.gl, program = gl.createProgram();\n\n        // attach the shaders.\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n\n        // link the program.\n        gl.linkProgram(program);\n\n        // Check if it linked.\n        var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n        if (!success) {\n            // something went wrong with the link\n            throw (\"program filed to link:\" + gl.getProgramInfoLog(program));\n        }\n\n        return program;\n    };\n\n    /**\n     * Creates and compiles a shader.\n     * @param shaderSource the GLSL source code for the shader.\n     * @param shaderType the type of shader, VERTEX_SHADER or FRAGMENT_SHADER.\n     * @returns the shader.\n     */\n    compileShader(shaderSource: string, shaderType: number) {\n        // Create the shader object\n        let gl = this.gl, shader = gl.createShader(shaderType);\n\n        // Set the shader source code.\n        gl.shaderSource(shader, shaderSource);\n\n        // Compile the shader\n        gl.compileShader(shader);\n\n        // Check if it compiled\n        var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n        if (!success) {\n            // Something went wrong during compilation; get the error\n            throw \"could not compile shader:\" + gl.getShaderInfoLog(shader);\n        }\n\n        return shader;\n    }\n\n    /** Gets the location of each of the uniforms associated with the specified program. */\n    getUniformLocationMap(program: WebGLProgram, renamed?: Renaming) {\n        let gl = this.gl, uniforms = <UniformLocationMap>{};\n        if (renamed) {\n            for (let name in renamed) {\n                uniforms[name] = gl.getUniformLocation(program, renamed[name]);\n            }\n        } else {\n            let count = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n            for (let i = 0; i < count; i++) {\n                let { name } = gl.getActiveUniform(program, i);\n                uniforms[name] = gl.getUniformLocation(program, name);\n            }\n        }\n        return uniforms;\n    }\n\n    /** Gets the location of each of the attributes associated with the specified program. */\n    getAttributeLocationMap(program: WebGLProgram, renamed?: Renaming) {\n        let gl = this.gl, attribs = <AttributeLocationMap>{};\n        if (renamed) {\n            for (let name in renamed) {\n                attribs[name] = gl.getAttribLocation(program, renamed[name]);\n            }\n        } else {\n            let count = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n            for (let i = 0; i < count; i++) {\n                let { name } = gl.getActiveAttrib(program, i);\n                attribs[name] = gl.getAttribLocation(program, name);\n            }\n        }\n        return attribs;\n    }\n}\n","import { Renderer } from '..';\n\n/** Maps the name of a uniform to its location in a WebGL program. */\nexport interface UniformLocationMap {\n    [key: string]: WebGLUniformLocation;\n}\n\n/** Maps the name of an attribute to its location in a WebGL program. */\nexport interface AttributeLocationMap {\n    [key: string]: number;\n}\nexport abstract class Program<U = UniformLocationMap, A = AttributeLocationMap> {\n\n    /** The location of this program in WebGL. */\n    location: WebGLProgram;\n\n    /** The locations of the uniforms associated with this program, keyed by the uniform name. */\n    uniforms: U;\n\n    /** The locations of the attributes associated with this program, keyed by the attribute name. */\n    attribs: A;\n\n    /** Called whenever this program is attached to the renderer. */\n    abstract onAttach(renderer: Renderer): any;\n\n    /** Called whenever this program is detached from the renderer. */\n    abstract onDetach(renderer: Renderer): any;\n}\n","import { Rect, Vec2, Mat4, Mat2d, Point } from '..';\n\n/** Defines an orthographic projection from world space to clip space. */\nexport class Camera {\n\n    /** The orthographic projection matrix that puts the world in view. */\n    public readonly matrix = new Float32Array(16);\n\n    /** The area of the world that is currently in view. */\n    public readonly view = Rect.copy(this.world);\n\n    /** The current position of the camera in relation to the center of the world. */\n    public readonly position = <Vec2.Like> {x: 0, y: 0};\n\n    /** The current zoom setting for this camera. */\n    public zoom = 1;\n\n    constructor(\n        /** The area that can be viewed by this camera */\n        public readonly world: Rect,\n        /** The min-allowed zoom setting for this camera. */\n        public readonly minZoom: number,\n        /** The max-allowed zoom setting for this camera. */\n        public readonly maxZoom: number\n    ) {}\n\n    /**\n     * Sets the size of the viewport in which the camera image will be displayed.\n     * The resulting image will be centered inside the viewport and will match the aspect of the camera. \n     * @param vw the new width of the viewport.\n     * @param vh the new height of the viewport.\n     */\n    setViewport(vw: number, vh: number) {\n        // Reset view\n        Rect.copy(this.world, this.view);\n\n        // Scale width or height of view to match aspect of viewport\n        let vr = vw / vh, wr = this.world.aspect;\n        if (wr < vr) {\n            this.view.scaleX(vr / wr);\n        } else {\n            this.view.scaleY(wr / vr);\n        }\n    \n        // Apply our other camera settings on top\n        this.view.stretch(1 / this.zoom);\n        this.view.offset(this.position);\n\n        // Update matrix to reflect changes to view\n        this.updateMatrix();\n    }\n\n    /**\n     * Sends a request to offset this camera by the desired vector.\n     * Note: the desired offset may be adjusted to keep the camera from viewing anything outside of the world area.\n     * @param desiredOffset the desired offset. \n     * @returns the actual offset.\n     */\n    offset(desiredOffset: Vec2.Like) {\n        let target = Vec2.add(desiredOffset, this.position);\n        let ratio = (this.zoom - this.minZoom) / this.zoom;\n        let size = Mat2d.mapRect(Mat2d.stretch(ratio), this.world); // Max allowable size given zoom\n        let far = Rect.copy(size); far.offset(Vec2.rotate180(size.center())); // Center at origin so we know how far we can go in any direction\n\n        let actualOffset = Vec2.copy(desiredOffset);\n        // If world position is too far left\n        if (target.x < far.left) {\n            // Adjust offset so that offset.x + position.x = far.left\n            actualOffset.x = far.left - this.position.x;\n        }\n        // If world position is too far right\n        else if (target.x > far.right) {\n            // Adjust offset so that offset.x + position.x = far.right\n            actualOffset.x = far.right - this.position.x;\n        }\n        // If world position is too far down\n        if (target.y < far.bottom) {\n            // Adjust offset so that offset.y + position.y = far.bottom\n            actualOffset.y = far.bottom - this.position.y;\n        }\n        // If world position is too far up\n        else if (target.y > far.top) {\n            // Adjust offset so that offset.y + position.y = far.top\n            actualOffset.y = far.top - this.position.y;\n        }\n\n        // Now we can safely apply the offset\n        this.view.offset(actualOffset);\n        Vec2.add(this.position, actualOffset, this.position);\n        this.updateMatrix();\n        return actualOffset;\n    }\n\n    /**\n     * Sends a request to zoom in this camera by the desired scale factor.\n     * Note: the desired scale factor is automatically adjusted to keep the camera from viewing anything outside of the world area. \n     * @param desiredScaleFactor the desired scale factor.\n     * @returns the actual scale factor.\n     */\n    zoomIn(desiredScaleFactor: number) {\n        let targetZoom = this.zoom * desiredScaleFactor;\n        let actualScaleFactor: number;\n        if (targetZoom < this.minZoom) {\n            // Adjust scale factor so that zoom * changeInZoom = minZoom\n            actualScaleFactor = this.minZoom / this.zoom;\n            this.zoom = this.minZoom;\n        } else if (targetZoom > this.maxZoom) {\n            // Adjust scale factor so that zoom * changeInZoom = maxZoom\n            actualScaleFactor = this.maxZoom / this.zoom;\n            this.zoom = this.maxZoom;\n        } else {\n            // No need to adjust scale factor\n            actualScaleFactor = desiredScaleFactor;\n            this.zoom = targetZoom;\n        }\n        this.view.stretch(1 / actualScaleFactor);\n        this.updateMatrix();\n        return actualScaleFactor;\n    }\n\n    /**\n     * Sends a request to zoom this camera by the desired scale factor.\n     * Note: the desired scale factor is automatically adjusted to keep the camera from viewing anything outside of the world area. \n     * @param desired the desired scale factor.\n     * @param focus the focus point. \n     * @returns the actual scale factor and offset.\n     */\n    zoomToPoint(desiredScaleFactor: number, focus: Point.Like) {\n        let view = this.view\n        // Convert (x,y) coordinates to [0,1] space\n        let normX = (focus.x - view.left) / view.width;\n        let normY = (focus.y - view.bottom) / view.height;\n        // Apply scale factor\n        let actualScaleFactor = this.zoomIn(desiredScaleFactor);\n        // Determine position of focus point after change in zoom\n        let aft: Vec2.Like = {\n            x: view.left + (normX * view.width),\n            y: view.bottom + (normY * view.height)\n        }\n        // Compute offset back to focus point\n        let offset = Vec2.fromPointToPoint(aft, focus);\n        // Apply the offset\n        let actualOffset = this.offset(offset);\n        // Return actual scale factor and offset so caller can check if they differ from desired\n        return {scale: actualScaleFactor, offset: actualOffset};\n    }\n\n    /** Recalculates the projection matrix to reflect changes in the camera settings.*/\n    private updateMatrix() {\n        Mat4.ortho(this.view, 0.1, 10, this.matrix);\n    }\n}","import { Camera, Program } from '..';\n\n/** Helper class for rendering graphics with WebGL. */\nexport class Renderer {\n\n    public readonly angleExt = this.gl.getExtension('ANGLE_instanced_arrays');\n\n    /** The location of the currently bound program. */\n    private currentProgram: Program;\n\n    constructor(\n        public readonly gl: WebGLRenderingContext, \n        public readonly camera: Camera,\n    ) {}\n\n    /**\n     * Called whenever the canvas size changes.\n     * @param width the new width of the canvas.\n     * @param height the new height of the canvas.\n     */\n    onSurfaceChange(width: number, height: number) {\n        // Update the viewport to match the new dimensions of the drawing buffer\n        this.gl.viewport(0, 0, width, height);\n        // Adjust camera to viewport\n        this.camera.setViewport(width, height);\n    }\n\n    /** Binds the specified program to the WebGL rendering context, if not already bound. */\n    useProgram(program: Program) {\n        if (this.currentProgram !== program) {\n            this.attachProgram(program);\n        }\n    }\n\n    private attachProgram(program: Program) {\n        this.gl.useProgram(program.location);\n        // Notify detached program\n        if(this.currentProgram){ this.currentProgram.onDetach(this); }\n        // Notify attached program\n        program.onAttach(this);\n        // Keep track of the current program\n        this.currentProgram = program;\n    }\n};","import { Drawable, Point, Renderer, Rect, Vec2, ScreenPoint, PointerEventListener } from '..';\nimport { PointerEventDetector } from '../event/pointer-event';\nimport { WheelEventDetector } from '../event/wheel-event';\n\n/** A rendering surface linked to an HTMLCanvasElement (the drawing buffer). */\nexport class Surface {\n\n    /** The drawing buffer's bounding client rect. */\n    clientRect = this.canvasEl.getBoundingClientRect();\n\n    /*** True if a request has been made to re-render this surface. */\n    hasRenderRequest = false;\n\n    constructor(\n        public readonly canvasEl: HTMLCanvasElement, \n        public readonly renderer: Renderer,\n        public readonly scene: Drawable\n    ) {}\n\n    startRenderLoop() {\n        this.requestRender();\n        this.checkRender();\n    }\n\n    /** Checks each frame if the surface needs to be re-rendered. */\n    private checkRender = () => {\n        // Resize surface if necessary\n        this.resize()\n        // Notify surface of animation frame\n        this.onAnimationFrame()\n        // Keep calling this function every frame\n        requestAnimationFrame(this.checkRender);\n    }\n\n    /**\n     * Requests that this surface be re-rendered.\n     */\n    requestRender() {\n        this.hasRenderRequest = true;\n    }\n\n    /**\n     * Re-renders this surface if it has a render request.\n     */\n    onAnimationFrame() {\n        if(this.hasRenderRequest || this.scene.hasRenderRequest()){\n            this.scene.draw(this.renderer);\n            this.hasRenderRequest = false;\n        }\n    }\n\n    /** Resizes this surface to match the specified width/height dimensions. */\n    resize(width = this.canvasEl.clientWidth, height = this.canvasEl.clientHeight) {\n        // If width or height has changed\n        if (this.canvasEl.width !== width || this.canvasEl.height !== height) {\n            // Resize canvas to specified dimensions\n            this.canvasEl.width = width;\n            this.canvasEl.height = height;\n            // Get new bounding box\n            this.clientRect = this.canvasEl.getBoundingClientRect();\n            // Notify renderer of surface change\n            this.renderer.onSurfaceChange(width, height);\n            // Request render to show changes\n            this.requestRender();\n        }\n    }\n\n    startDetectingPointerEvents() {\n        let detector = new PointerEventDetector(this);\n        detector.startListening();\n        return detector;\n    }\n\n    startDetectingWheelEvents() {\n        let detector = new WheelEventDetector(this);\n        detector.startListening();\n        return detector;\n    }\n\n    /** Sends a request to pan the image displayed by this surface. */\n    pan(desiredOffset: Vec2.Like) {\n        let camera = this.renderer.camera;\n        let actual = camera.offset(desiredOffset);\n        if (Vec2.length2(actual) != 0) {\n            this.requestRender();\n        }\n        return actual;\n    }\n\n    /** Sends a request to zoom into the image displayed by this surface. */\n    zoomIn(desiredScaleFactor: number){\n        let camera = this.renderer.camera;\n        let actual = camera.zoomIn(desiredScaleFactor);\n        if(actual != 1){\n            this.requestRender();\n        }\n    }\n\n    /** Sends a request to zoom out of the image displayed by this surface. */\n    zoomOut(desiredScaleFactor: number){\n        this.zoomIn(1/desiredScaleFactor);\n    }\n\n    /** Sends a request to zoom into the image displayed by this surface while fixing the specified focus point. */\n    zoomToPoint(desiredScaleFactor: number, focus: Point.Like) {\n        let camera = this.renderer.camera;\n        let actual = camera.zoomToPoint(desiredScaleFactor, focus);\n        if(actual.scale != 1 || Vec2.length2(actual.offset) != 0){\n            this.requestRender();\n        }\n        return actual;\n    }\n\n    /** Maps a screen point to canvas space. */\n    mapScreenPointToCanvas(screenPoint: ScreenPoint): Point.Like {\n        return {\n            x: screenPoint.clientX - this.clientRect.left,\n            y: screenPoint.clientY - this.clientRect.top\n        };\n    }\n\n    /** Maps a screen point to NDC space [0,1].*/\n    mapScreenPointToNdc(screenPoint: ScreenPoint) {\n        return this.mapCanvasPointToNdc(this.mapScreenPointToCanvas(screenPoint));\n    }\n\n    /** Maps a screen point to clip space. */\n    mapScreenPointToWorld(screenPoint: ScreenPoint) {\n        return this.mapNdcToWorld(this.mapScreenPointToNdc(screenPoint));\n    }\n\n    /** Maps a canvas coordinate to NDC space [0,1]. */\n    mapCanvasPointToNdc(canvasPoint: Point.Like) {\n        let {width, height} = this.clientRect;\n        let x = canvasPoint.x / width;\n        let y = (height - canvasPoint.y) / height; // Flip in y axis\n        return {x: x, y: y};\n    }\n\n    /** Maps a normalized device coordinate (NDC) to world space. */\n    mapNdcToWorld(ndc: Point.Like) {\n        let view = this.renderer.camera.view; // Depends on what is currently in view\n        let x = view.left + (ndc.x * view.width);\n        let y = view.bottom + (ndc.y * view.height);\n        return {x: x, y: y};\n    }\n};\n","import { pad, randomByte } from \"./util\";\n\nexport interface Like {\n    /** The red component of this color, a value between 0 and 0xff */\n    r: number;\n    /** The green component of this color, a value between 0 and 0xff */\n    g: number;\n    /** The blue component of this, a value between 0 and 0xff */\n    b: number;\n    /** The alpha component of this color, a value between 0 and 0xff */\n    a: number;\n}\n\n/** Copies a color */\nexport function copy(c: Like, out = <Like> {}) {\n    out.r = c.r;\n    out.g = c.g;\n    out.b = c.b;\n    out.a = c.a;\n    return out;\n}\n\n/** Converts an 0xrrggbbaa int to a color */\nexport function fromRgbaInt(rgba: number, out = <Like> {}) {\n    out.r = (rgba >> 24) & 0xff;\n    out.g = (rgba >> 16) & 0xff;\n    out.b = (rgba >> 8) & 0xff;\n    out.a = (rgba >> 0) & 0xff;\n    return out;\n}\n\n/** Converts an 0xrrggbb int to a (fully opaque) color */\nexport function fromRgbInt(rgb: number, out = <Like> {}) {\n    return fromRgbaInt((rgb << 8) | 0xff, out);\n}\n\n/** Converts a color to an 0xrrggbbaa int */\nexport function toRgbaInt(c: Like) {\n    let r = c.r << 24;\n    let g = c.g << 16;\n    let b = c.b << 8;\n    let a = c.a << 0;\n    return (r | g | b | a) >>> 0; // Convert to unsigned\n}\n\n/** Converts an #aarrggbb string to a color. The leading # is optional. */\nexport function fromArgbString(argb: string, out = <Like> {}) {\n    let i = argb[0] == '#' ? 1 : 0;\n    out.a = parseInt(argb.substr(i, 2), 16);\n    out.r = parseInt(argb.substr(i + 2, 2), 16);\n    out.g = parseInt(argb.substr(i + 4, 2), 16);\n    out.b = parseInt(argb.substr(i + 6, 2), 16);\n    return out;\n}\n\n/** Converts a color to an #aarrggbb string. */\nexport function toArgbString(c: Like) {\n    let a = pad(c.a.toString(16)); // aa\n    let r = pad(c.r.toString(16)); // rr\n    let g = pad(c.g.toString(16)); // gg\n    let b = pad(c.b.toString(16)); // bb\n    return '#' + a + r + g + b; // #aarrggbb\n}\n\n/** Creates a random color. Preserves the alpha value of the out param if specified; otherwise defaults to fully opaque */\nexport function random(out = <Like> {}) {\n    out.r = randomByte();\n    out.g = randomByte();\n    out.b = randomByte();\n    out.a = out.a === undefined ? 0xff : out.a;\n    return out;\n}\n\n/** Blends src into dst using (src.alpha, 1-src.alpha) blend mode */\nexport function blend(src: Like, dst: Like, out = <Like> {}) {\n    let alpha = src.a + 1, invAlpha = 256 - src.a;\n    out.r = (alpha * src.r + invAlpha * dst.r) >> 8; // divide by 2^8\n    out.g = (alpha * src.g + invAlpha * dst.g) >> 8;\n    out.b = (alpha * src.b + invAlpha * dst.b) >> 8;\n    out.a = dst.a;\n    return out;\n}\n\n/** Checks if a color is fully opaque */\nexport function isOpaque(c: Like) {\n    return c.a === 0xff;\n}\n\n/** Checks if a color is fully transparent */\nexport function isTransparent(c: Like) {\n    return c.a === 0;\n}\n\n/** Checks if c1 and c2 are equal */\nexport function equals(c1: Like, c2: Like) {\n    return c1.r == c2.r\n        && c1.g == c2.g\n        && c1.b == c2.b\n        && c1.a == c2.a;\n}","import { Color  } from '..';\n\n// These functions are the same\nexport { copy, isTransparent, Like } from './color'; \n\n/** Checks if c1 and c2 are approximately equal */\nexport function equals(c1: Color.Like, c2: Color.Like, e = 0) {\n    return Math.abs(c1.r - c2.r) <= e\n        && Math.abs(c1.g - c2.g) <= e\n        && Math.abs(c1.b - c2.b) <= e;\n}\n\n/** Converts a byte-based rgba color to a float-based rgba color */\nexport function fromColor(src: Color.Like, out = <Color.Like> {}){\n    out.r = src.r / 0xff;\n    out.g = src.g / 0xff;\n    out.b = src.b / 0xff;\n    out.a = src.a / 0xff;\n    return out;\n}\n\n/** Converts a float-based rgba color to a byte-based rgba color */\nexport function toColor(src: Color.Like, out = <Color.Like> {}){\n    out.r = (src.r * 0xff) >> 0;\n    out.g = (src.g * 0xff) >> 0;\n    out.b = (src.b * 0xff) >> 0;\n    out.a = (src.a * 0xff) >> 0;\n    return out;\n}\n\n/** Creates a random color. Preserves the alpha value of the out param if specified; otherwise defaults to fully opaque */\nexport function random(out = <Color.Like> {}) {\n    out.r = Math.random();\n    out.g = Math.random();\n    out.b = Math.random();\n    out.a = out.a === undefined ? 1 : out.a;\n    return out;\n}\n\n/** Checks if a color is fully opaque */\nexport function isOpaque(c: Color.Like) {\n    return c.a === 1;\n}\n\n/** Premultiplies the (r,g,b) components of a color by it's alpha component */\nexport function premultiplyAlpha(c: Color.Like, out = <Color.Like> {}) {\n    out.r = c.r * c.a;\n    out.g = c.g * c.a;\n    out.b = c.b * c.a;\n    out.a = 1;\n    return out;\n}","import { Point, Rect, Vec2 } from \"..\";\n\nexport interface Like {\n    /** The semi x axis of this ellipse, that is, the distance from the center of this ellipse to its left and right vertices. */\n    rx: number;\n    /**  The semi y axis of this ellipse, that is, the distance from the center of this ellipse to its top and bottom vertices. */\n    ry: number;\n    /** The point at the center of this ellipse. */\n    c: Point.Like;\n}\n\n/** Copies an ellipse */\nexport function copy(e: Like, out = <Like> {}) {\n    out.rx = e.rx;\n    out.ry = e.ry;\n    out.c = Point.copy(e.c, out.c);\n    return out;\n}\n\n/** Creates a circle with radius r centered at point c */\nexport function circle(r: number, c: Point.Like, out = <Like> {}) {\n    return copy({rx: r, ry: r, c: c}, out);\n}\n\n/** Creates an ellipse with the specified boundaries */\nexport function fromRect(r: Rect, out = <Like> {}) {\n    return copy({rx: r.width / 2, ry: r.height / 2, c: r.center()}, out);\n}\n\n/** Check if an ellipse contains the specified point */\nexport function containsPoint(e: Like, p: Point.Like) {\n    // Similar to point in circle problem, but need to account for x/y axes\n    let d = Vec2.fromPointToPoint(p, e.c); \n    let sx = d.x / e.rx;\n    let sy = d.y / e.ry;\n    return (sx * sx) + (sy * sy) <= 1;\n}\n\n/** Checks if e1 and e2 are approximately equal */\nexport function equals(e1: Like, e2: Like, e = 0) {\n    return Math.abs(e1.rx - e2.rx) <= e\n        && Math.abs(e1.ry - e2.ry) <= e\n        && Point.equals(e1.c, e2.c, e);\n}\n ","import { Point, Vec2 } from \"..\";\n\nexport class LineSegment {\n    constructor(\n        /** The point at one end of this line segment */\n        public p1: Point.Like, \n        /** The point at the other end of this line segment */\n        public p2: Point.Like\n    ) {}\n\n    get midpoint() {\n        return Point.midpoint(this.p1, this.p2);\n    }\n\n    get length() {\n        return Point.distance(this.p1, this.p2);\n    }\n\n    /** Checks if the distance from this line to (x,y) is less than or equal to epsilon  */\n    containsPoint(p: Point.Like, epsilon = 0) {\n        // Paramaterize the line segment to a + bt, 0<=t<=1\n        let a = this.p1,\n            b = Vec2.fromPointToPoint(this.p1, this.p2),\n            t = -1;\n\n        // Find the value of t that produces a point closest to point p (using vector projection)\n        let v = Vec2.fromPointToPoint(a, p);\n        let len2 = Vec2.length2(b);\n        if (len2 != 0) { //in case of 0 length line\n            t = Vec2.dot(b, v) / len2;\n        }\n\n        // If t does not produce a point on our line segment, then then the line segment does not contain the point\n        if (t < 0 || t > 1) {\n            return false;\n        }\n\n        // The distance between the given point and specified point must be less than epsilon\n        // As an optimization, we check distance squared to avoid having to take the square root\n        let closest = Vec2.add(a, Vec2.multiply(b, t));\n        let dist2 = Point.distance2(closest, p);\n        return dist2 <= (epsilon * epsilon);\n    }\n\n    /** Copies a line segment */\n    copy() {\n        return new LineSegment(Point.copy(this.p1), Point.copy(this.p2));\n    }\n\n    /** Checks if l1 and l2 are approximately equal */\n    equals(l: LineSegment, e = 0) {\n        return Point.equals(this.p1, l.p1, e) \n            && Point.equals(this.p2, l.p2, e);\n    }\n}\n","import { Point, Rect, Vec2 } from \"..\";\n\nexport interface Like {\n    /** The first entry in the first column of this Mat2d */\n    c1r1: number;\n    /** The second entry in the first column of this Mat2d */\n    c1r2: number;\n    /** The first entry in the second column of this Mat2d */\n    c2r1: number;\n    /** The second entry in the second column of this Mat2d */\n    c2r2: number;\n    /** The first entry in the third column of this Mat2d */\n    c3r1: number;\n    /** The second entry in the third column of this Mat2d */\n    c3r2: number;\n}\n\n/** Copies a 2d matrix */\nexport function copy(m: Like, out = <Like> {}) {\n    out.c1r1 = m.c1r1; out.c2r1 = m.c2r1; out.c3r1 = m.c3r1;\n    out.c1r2 = m.c1r2; out.c2r2 = m.c2r2; out.c3r2 = m.c3r2;\n    return out;\n}\n\n/** Inverts a 2d matrix. */\nexport function invert(m: Like, out = <Like> {}){\n    let det = determinant(m);\n    let { c1r1, c2r1, c3r1, c1r2, c2r2, c3r2 } = m;\n    out.c1r1 = c2r2 / det;\n    out.c2r1 = -c2r1 / det;\n    out.c3r1 = ((c2r1 * c3r2) - (c3r1 * c2r2)) / det;\n    out.c1r2 = -c1r2 / det;\n    out.c2r2 = c1r1 / det;\n    out.c3r2 = ((c1r2 * c3r1) - (c1r1 * c3r2)) / det;\n    return out;\n}\n\n/** Computes the determinant of a 2d matrix. */\nexport function determinant(m: Like) {\n    return (m.c1r1 * m.c2r2) - (m.c2r1 * m.c1r2);\n}\n\n/** Concatenates 2 matrices together by multiplication: left * right */\nexport function concat(left: Like, right: Like, out = <Like> {}) {\n    // Calculate the first row, fixing the first left hand row\n    // and moving across each of the right hand columns\n    let c1r1 = left.c1r1 * right.c1r1 + left.c2r1 * right.c1r2;\n    let c2r1 = left.c1r1 * right.c2r1 + left.c2r1 * right.c2r2;\n    let c3r1 = left.c1r1 * right.c3r1 + left.c2r1 * right.c3r2 + left.c3r1;\n    // Calculate the second row, fixing the second left hand row\n    // and moving across each of the right hand columns\n    let c1r2 = left.c1r2 * right.c1r1 + left.c2r2 * right.c1r2;\n    let c2r2 = left.c1r2 * right.c2r1 + left.c2r2 * right.c2r2;\n    let c3r2 = left.c1r2 * right.c3r1 + left.c2r2 * right.c3r2 + left.c3r2;\n    // Output the result\n    out.c1r1 = c1r1; out.c2r1 = c2r1; out.c3r1 = c3r1;\n    out.c1r2 = c1r2; out.c2r2 = c2r2; out.c3r2 = c3r2;\n    return out;\n}\n\n/** Pivots the fixed point of a matrix by the specified vector */\nexport function pivot(m: Like, v: Point.Like, out = <Like> {}) {\n    return conjugate(m, translate(v), out);\n}\n\n/** Conjugates a matrix by the specified conjugator matrix */\nexport function conjugate(m: Like, conjugator: Like, out = <Like> {}) {\n    return concat(conjugator, concat(m, invert(conjugator)), out);\n}\n\n/** Creates an identity matrix */\nexport function identity(out = <Like> {}) {\n    out.c1r1 = 1; out.c2r1 = 0; out.c3r1 = 0;\n    out.c1r2 = 0; out.c2r2 = 1; out.c3r2 = 0;\n    return out;\n}\n\n/** Creates a matrix to translate by the specified vector */\nexport function translate({x, y}: Vec2.Like, out = <Like> {}) {\n    out.c1r1 = 1; out.c2r1 = 0; out.c3r1 = x;\n    out.c1r2 = 0; out.c2r2 = 1; out.c3r2 = y;\n    return out;\n}\n\n/** Creates a matrix to scale by the specified vector */\nexport function scale({x, y}: Vec2.Like, out = <Like> {}) {\n    out.c1r1 = x; out.c2r1 = 0; out.c3r1 = 0;\n    out.c1r2 = 0; out.c2r2 = y; out.c3r2 = 0;\n    return out;\n}\n\n/** Creates a matrix to scale from the specified start point to the specified end point, with a pivot point at p. */\nexport function scaleToPoint(start: Point.Like, end: Point.Like, p: Point.Like, out = <Like> {}) {\n    let v1 = Vec2.fromPointToPoint(p, start);\n    let v2 = Vec2.fromPointToPoint(p, end);\n    let s = scale({x: v2.x / v1.x, y: v2.y / v1.y}, out);\n    return pivot(s, p, out);\n}\n\n/** Creates a matrix to scale by the specified factor */\nexport function stretch(factor: number, out = <Like> {}) {\n    return scale({x: factor, y: factor}, out); \n}\n\n/** Creates a matrix to rotate by the specified number of radians */\nexport function rotate(radians: number, out = <Like> {}) {\n    return sinCos(Math.sin(radians), Math.cos(radians), out);\n}\n\n/** Creates a matrix to stretch and rotate from the specified start point to the specified end point, with a pivot point at p. */\nexport function stretchRotateToPoint(start: Point.Like, end: Point.Like, p: Point.Like, out = <Like> {}) {\n    // Determine the stretch ratio\n    let v1 = Vec2.fromPointToPoint(p, start);\n    let v2 = Vec2.fromPointToPoint(p, end);\n    let l1 = Vec2.length(v1);\n    let l2 = Vec2.length(v2);\n    let s = stretch(l2 / l1);\n\n    // Determine the sin and cos of the rotation angle\n    let n1 = Vec2.divide(v1, l1);\n    let n2 = Vec2.divide(v2, l2);\n    let sin = Vec2.cross(n1, n2);\n    let cos = Vec2.dot(n1, n2);\n    let r = sinCos(sin, cos);\n\n    // Rotate first, then stretch\n    return pivot(concat(s, r), p, out);\n}\n\n/** Creates a matrix to rotate by the specified sine and cosine values */\nexport function sinCos(sin: number, cos: number, out = <Like> {}) {\n    out.c1r1 = cos; out.c2r1 = -sin; out.c3r1 = 0;\n    out.c1r2 = sin; out.c2r2 = cos; out.c3r2 = 0;\n    return out;\n}\n\n/** Scale to fit options for a rect-to-rect matrix. */\nexport const enum ScaleToFit {\n    /** Stretches the src rect to fit inside dst, then centers the src rect inside the dst rect */\n    Center,\n    /** Stretches the src rect to fit inside dst, then translates the src rect to the bottom right corner of the dst rect */\n    End,\n    /** Scales the src rect to fit inside dst exactly, then translates src to dst */\n    Fill,\n    /** Stretches the src rect to fit inside dst, then translates the src rect to top left corner of the dst rect*/\n    Start\n};\n\n/** Creates a matrix to map src into dst using the specifed scale to fit option  */\nexport function rectToRect(src: Rect, dst: Rect, stf = ScaleToFit.Fill, out = <Like> {}) {\n    // Translate to origin\n    let origin = {x: 0, y: 0};\n    let srcPoint = getScaleToFitPoint(src, stf);\n    let dstPoint = getScaleToFitPoint(dst, stf);\n    translate(Vec2.fromPointToPoint(srcPoint, origin), out); \n\n    // Apply the scale\n    let sx = dst.width / src.width;\n    let sy = dst.height / src.height;\n    let scaleMatrix = stf == ScaleToFit.Fill ? scale({x: sx, y: sy}) : stretch(Math.min(sx, sy));\n    concat(scaleMatrix, out, out);\n\n    // Translate to destination point\n    let translation = translate(Vec2.fromPointToPoint(origin, dstPoint));\n    return concat(translation, out, out);\n}\n\n/** Determine which point to match based on the scale to fit option. */\nfunction getScaleToFitPoint(r: Rect, stf: ScaleToFit): Point.Like {\n    switch (stf) {\n        case ScaleToFit.Center:\n            return r.center();\n        case ScaleToFit.End:\n            return r.bottomRight();\n        default:\n            return r.topLeft();\n    }\n}\n\n/** Maps a point by the specified matrix */\nexport function mapPoint(m: Like, {x, y}: Point.Like, out = <Point.Like> {}) {\n    out.x = m.c1r1 * x + m.c2r1 * y + m.c3r1;\n    out.y = m.c1r2 * x + m.c2r2 * y + m.c3r2;\n    return out;\n}\n\n/** Maps a rect by the specified matrix */\nexport function mapRect(m: Like, r: Rect, out = Rect.empty()) {\n    let {x, y} = mapPoint(m, r.topLeft()); \n    let corners = [r.bottomLeft(), r.bottomRight(), r.topRight()];\n    out.left = out.right = x; \n    out.top = out.bottom = y;\n    for (let corner of corners) {\n        out.unionPoint(mapPoint(m, corner));\n    }\n    return out;\n}\n\n/** Checks if two matrices are approximately equal */\nexport function equals(m1: Like, m2: Like, e = 0) {\n    return Math.abs(m1.c1r1 - m2.c1r1) <= e\n        && Math.abs(m1.c1r2 - m2.c1r2) <= e\n        && Math.abs(m1.c2r1 - m2.c2r1) <= e\n        && Math.abs(m1.c2r2 - m2.c2r2) <= e\n        && Math.abs(m1.c3r1 - m2.c3r1) <= e\n        && Math.abs(m1.c3r2 - m2.c3r2) <= e\n}","import { Rect } from '..';\n\n/**\n * Creates an othogonal transformation matrix.\n * @param clip the near clipping plane viewport.\n * @param near the depth (negative z coordinate) of the near clipping plane.\n * @param far the depth (negative z coordinate) of the far clipping plane.\n */\nexport function ortho(clip: Rect, near: number, far: number, out: Float32Array) {\n    let width = clip.width,\n        height = clip.height,\n        depth = near - far;\n\n    out[0] = 2 / width;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n\n    out[4] = 0;\n    out[5] = 2 / height;\n    out[6] = 0;\n    out[7] = 0;\n\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1 / depth;\n    out[11] = 0;\n\n    out[12] = -(clip.right + clip.left) / width;\n    out[13] = -(clip.top + clip.bottom) / height;\n    out[14] = -near / depth;\n    out[15] = 1;\n}\n","import { Vec2 } from \"..\";\n\nexport interface Like {\n    x: number;\n    y: number;\n}\n\n/** Copies a point */\nexport function copy(p: Like, out = <Like> {}) {\n    out.x = p.x;\n    out.y = p.y;\n    return out;\n}\n\n/** Computes the midpoint of p1 and p2 */\nexport function midpoint(p1: Like, p2: Like, out = <Like> {}) {\n    return Vec2.multiply(Vec2.add(p1, p2, out), 0.5, out);\n}\n\n/** Computes the distance between p1 and p2 */\nexport function distance(p1: Like, p2: Like) {\n    return Math.sqrt(distance2(p1, p2));\n}\n\n/** Computes the distance squared between p1 and p2 */\nexport function distance2(p1: Like, p2: Like) {\n    return Vec2.length2(Vec2.fromPointToPoint(p1, p2));\n}\n\n/** Checks if p1 and p2 are approximately equal */\nexport function equals(p1: Like, p2: Like, e = 0) {\n    return Math.abs(p1.x - p2.x) <= e\n        && Math.abs(p1.y - p2.y) <= e;\n}","import { Point, Vec2 } from \"..\";\n\nexport interface RectLike {\n    /** The left boundary of this Rect */\n    left: number;\n    /** The top boundary of this Rect */\n    top: number;\n    /** The right boundary of this Rect */\n    right: number;\n    /** The bottom boundary of this Rect */\n    bottom: number;\n}\nexport class Rect implements RectLike {\n\n    static copy(r: RectLike, out = Rect.empty()) {\n        out.left = r.left;\n        out.top = r.top;\n        out.right = r.right;\n        out.bottom = r.bottom;\n        return out;\n    }\n\n    /** Creates an empty rect */\n    static empty() {\n        return new Rect(0, 0, 0, 0);\n    }\n\n    /** Creates this rect with the specified dimensions */\n    static dimensions(left: number, top: number, width: number, height: number) {\n        return new Rect(left, top, left + width, top - height);\n    }\n\n    constructor(\n        public left: number,\n        public top: number,\n        public right: number,\n        public bottom: number\n    ) {}\n\n    /** Measures the width of this rect */\n    get width() {\n        return this.right - this.left;\n    }\n\n    set width(w: number) {\n        this.right = this.left + w;\n    }\n\n    /** Measures the height of this rect */\n    get height() {\n        return this.top - this.bottom;\n    }\n\n    set height(h: number) {\n        this.bottom = this.top - h;\n    }\n\n    get aspect() {\n        return this.width / this.height;\n    }\n\n    /** Measures the area of this rect */\n    get area() {\n        return this.width * this.height;\n    }\n\n    /** Gets the point at the center of this rect */\n    center(out = <Point.Like> {}) {\n        out.x = this.centerX;\n        out.y = this.centerY;\n        return out;\n    }\n\n    /** Measures the x-coordinate of the point at the center of this rect */\n    get centerX() {\n        return 0.5 * (this.left + this.right);\n    }\n\n    /** Measures the y-coordinate of the point at the center of this rect */\n    get centerY() {\n        return 0.5 * (this.bottom + this.top);\n    }\n\n    /** Gets the point at the top left corner of this rect */\n    topLeft(out = <Point.Like> {}) {\n        out.x = this.left;\n        out.y = this.top;\n        return out;\n    }\n\n    /** Gets the point at the bottom left corner of this rect */\n    bottomLeft(out = <Point.Like> {}) {\n        out.x = this.left;\n        out.y = this.bottom;\n        return out;\n    }\n\n    /** Gets the point at the bottom right corner of this rect */\n    bottomRight(out = <Point.Like> {}) {\n        out.x = this.right;\n        out.y = this.bottom;\n        return out;\n    }\n\n    /** Gets the point at the top right corner of this rect */\n    topRight(out = <Point.Like> {}) {\n        out.x = this.right;\n        out.y = this.top;\n        return out;\n    }\n\n    /** Checks if this rect is empty. True if left >= right or bottom >= top. */\n    isEmpty() {\n        return this.left >= this.right || this.bottom >= this.top;\n    }\n\n    /** Checks if the boundaries of this Rect represent a valid rectangle. True if right >= left and top >= bottom. */\n    isValid() {\n        return this.right >= this.left && this.top >= this.bottom;\n    }\n\n    /** Expands this rect to include the other rect */\n    union(r: RectLike) {\n        this.left = Math.min(this.left, r.left);\n        this.right = Math.max(this.right, r.right);\n        this.bottom = Math.min(this.bottom, r.bottom);\n        this.top = Math.max(this.top, r.top);\n    }\n\n    /** Expands this rect to enclose the specified point */\n    unionPoint({x, y}: Point.Like) {\n        this.left = Math.min(x, this.left);\n        this.top = Math.max(y, this.top);\n        this.right = Math.max(x, this.right);\n        this.bottom = Math.min(y, this.bottom);\n    }\n\n    /** Checks if this rect intersects the other rect */\n    intersects(r: RectLike) {\n        return this.right >= r.left && r.right >= this.left && this.top >= r.bottom && r.top >= this.bottom;\n    }\n\n    /** Finds the intersection of this rect with the other rect */\n    intersect(r: RectLike) {\n        this.left = Math.max(this.left, r.left);\n        this.right = Math.min(this.right, r.right);\n        this.bottom = Math.max(this.bottom, r.bottom);\n        this.top = Math.min(this.top, r.top);\n    }\n\n    /** Insets the boundaries of this rect by the specified vector. */\n    inset({x, y}: Vec2.Like) {\n        this.left += x;\n        this.top -= y;\n        this.right -= x;\n        this.bottom += y;\n    }\n\n    /** Offsets the position of this rect by the specified vector */\n    offset({x, y}: Vec2.Like) {\n        this.offsetX(x);\n        this.offsetY(y);\n    }\n\n    /** Offsets the position of this rect by the specified change in x (dx) */\n    offsetX(dx: number) {\n        this.left += dx;\n        this.right += dx;\n    }\n\n    /** Offsets the position of this rect by the specified change in y (dy) */\n    offsetY(dy: number) {\n        this.top += dy;\n        this.bottom += dy;\n    }\n\n    /** Scales this rect out from it's center by the specified (x,y) percentages. */\n    scale({x, y}: Vec2.Like) {\n        this.scaleX(x);\n        this.scaleY(y);\n    }\n\n    /** Scales this rect horizontally out from its center */\n    scaleX(dx: number) {\n        let cx = this.centerX;\n        this.offsetX(-cx);\n        this.left *= dx;\n        this.right *= dx;\n        this.offsetX(cx);\n    }\n\n    /** Scales this rect vertically out from its center */\n    scaleY(dy: number) {\n        let cy = this.centerY;\n        this.offsetY(-cy);\n        this.top *= dy;\n        this.bottom *= dy;\n        this.offsetY(cy);\n    }\n\n    /** Stretches this rect out from its center */\n    stretch(k: number) {\n        this.scaleX(k);\n        this.scaleY(k);\n    }\n\n    /** Checks if this rect contains the other rect */\n    contains(r: RectLike) {\n        return this.left <= r.left && r.right <= this.right &&\n            this.bottom <= r.bottom && r.top <= this.top;\n    }\n\n    /** Checks if this rect contains the specified point */\n    containsPoint({x, y}: Point.Like) {\n        return this.containsX(x) && this.containsY(y);\n    }\n\n    /** Checks if this rect contains any point with the specified x coordinate  */\n    containsX(x: number) {\n        return this.left <= x && x <= this.right;\n    }\n\n    /** Checks if this rect contains any point with the specified y coordinate  */\n    containsY(y: number) {\n        return this.bottom <= y && y <= this.top;\n    }\n\n    /** Swaps the top/bottom or left/right boundaries of this rect if they are flipped, meaning left > right and/or top > bottom */\n    sort() {\n        let {top, left, bottom, right} = this;\n        let vFlipped = bottom > top;\n        let hFlipped = left > right;\n        this.top = vFlipped ? bottom : top;\n        this.left = hFlipped ? right : left;\n        this.bottom = vFlipped ? top : bottom;\n        this.right = hFlipped ? left : right;\n    }\n\n    /** Checks if this rect is approximately equal to the other rect */\n    equals(r: RectLike, e = 0) {\n        return Math.abs(this.left - r.left) <= e\n            && Math.abs(this.top - r.top) <= e\n            && Math.abs(this.right - r.right) <= e\n            && Math.abs(this.bottom - r.bottom) <= e;\n    }\n}\n","export function pad(str: string) {\n    return (str.length == 1) ? '0' + str : str;\n}\n\n/** Returns a random integer between min (inclusive) and max (inclusive) */\nexport function randomInt(min: number, max: number) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n/** Returns a random byte value between 0 and 0xff */\nexport function randomByte() {\n    return randomInt(0, 0xff);\n}","import { Point, Rect } from \"..\";\n\n/** A two-dimensional vector with (x,y) components */\nexport interface Like {\n    x: number;\n    y: number;\n}\n\n/** Copies a */\nexport function copy(v: Like, out = <Like> {}) {\n    out.x = v.x;\n    out.y = v.y;\n    return out;\n}\n\n/** Returns v1 + v2 (component-wise addition) */\nexport function add(v1: Like, v2: Like, out = <Like> {}) {\n    out.x = v1.x + v2.x;\n    out.y = v1.y + v2.y;\n    return out;\n}\n\n/** Returns v1 - v2 (component-wise subtraction) */\nexport function subtract(v1: Like, v2: Like, out = <Like> {}) {\n    out.x = v1.x - v2.x;\n    out.y = v1.y - v2.y;\n    return out;\n}\n\n/** Multiplies each component of a vector by the specified factor */\nexport function multiply({x, y}: Like, factor: number, out = <Like> {}) {\n    out.x = x * factor;\n    out.y = y * factor;\n    return out;\n}\n\n/** Divides each component of a vector by the specified factor */\nexport function divide({x, y}: Like, factor: number, out = <Like> {}) {\n    out.x = x / factor;\n    out.y = y / factor;\n    return out;\n}\n\n/** Measures the length of a vector */\nexport function length(v: Like) {\n    return Math.sqrt(length2(v));\n}\n\n/** Measures the length squared of a vector */\nexport function length2({x, y}: Like) {\n    return x * x + y * y;\n}\n\n/** Computes the dot product of v1 and v2 */\nexport function dot(v1: Like, v2: Like) {\n    return v1.x * v2.x + v1.y * v2.y;\n}\n\n/** Computes the cross product of v1 with v2. */\nexport function cross(v1: Like, v2: Like) {\n    return (v1.x * v2.y) - (v2.x * v1.y);\n}\n \n/* Normalizes a vector so that it has a length of 1 */\nexport function normalize(v: Like, out = <Like> {}) {\n    return divide(v, length(v), out);\n}\n\n/** Rotates a vector 90 degrees CCW (to the right) */\nexport function rotate90({x, y}: Like, out = <Like> {}) {\n    out.x = y;\n    out.y = -x;\n    return out;\n}\n\n/** Rotates a vector 180 degrees CCW (flipping it) */\nexport function rotate180({x, y}: Like, out = <Like> {}) {\n    out.x = -x;\n    out.y = -y;\n    return out;\n}\n\n/** Rotates a vector 270 degrees CCW (90 degree to the left) */\nexport function rotate270({x, y}: Like, out = <Like> {}) {\n    out.x = -y;\n    out.y = x;\n    return out;\n}\n\n/** Measures the vector from p1 (initial point) to p2 (terminal point) */\nexport function fromPointToPoint(p1: Point.Like, p2: Point.Like, out = <Like> {}) {\n    out.x = p2.x - p1.x;\n    out.y = p2.y - p1.y;\n    return out;\n}\n\n/** Bounds a translation vector to prevent it from mapping point p outside of bounds r */\nexport function bound(v: Like, p: Point.Like, b: Rect, out = <Like> {}) {\n    out.x = boundX(v.x, p.x, b);\n    out.y = boundY(v.y, p.y, b);\n    return out;\n}\n\n/** Bounds the x-component of a translation vector to prevent it from mapping the x-coordinate of a point outside of bounds b */\nexport function boundX(dx: number, x: number, b: Rect) {\n    let targetX = dx + x;\n    let side = dx < 0 ? b.left : b.right;\n    return b.containsX(targetX) ? dx : side - x;\n}\n\n/** Bounds the y-component of a translation vector to prevent it from mapping the y-coordinate of a point outside of bounds b */\nexport function boundY(dy: number, y: number, b: Rect) {\n    let targetY = dy + y;\n    let side = dy < 0 ? b.bottom : b.top;\n    return b.containsY(targetY) ? dy : side - y;\n}\n\n/**\n * Finds the miter vector needed to join the two specified lines. Assumes the lines are measured from points listed in CCW order.\n * @param line1 The nonzero vector from the start of the first line to the end of the first line. \n * @param line2 The nonzero vector from the start of the second line to the end of the second line. \n * @param lineWidth The width of the second line (or half the width, if joining at the center of the lines).\n * @param miterLimit The maximum allowable miter length before a bevel is applied. Usually some multiple of lineWidth.\n */\nexport function miter(line1: Like, line2: Like, lineWidth: number, miterLimit: number, out = <Like> {}){\n    let n1 = normalize(rotate90(line1));\n    let n2 = normalize(rotate90(line2));\n    let direction = normalize(add(n1, n2));\n    let length = Math.min(miterLimit, lineWidth / dot(direction, n2));\n    return multiply(direction, length, out);\n}\n\n/** Checks if v1 and v2 are approximately equal */\nexport function equals(v1: Like, v2: Like, e = 0) {\n    return Math.abs(v1.x - v2.x) <= e\n        && Math.abs(v1.y - v2.y) <= e;\n}","import { Point, Pointer, PointerEventListener, Vec2 } from \"..\";\n\nexport class PanTool extends PointerEventListener {\n\n    private previous?: Point.Like;\n\n    wherePointer(p: Pointer) {\n        return p.isDown;\n    }\n\n    onPointerDown(p: Pointer) {\n        if (p.activePointers.length == 1) {\n            this.previous = p.position;\n        }\n    }\n\n    onPointerMove(p: Pointer) {\n        if (p.activePointers.length > 1) {\n            this.previous = null; // Invalidate\n        } else if (!this.previous) {\n            this.previous = p.position; // Reset\n        } else {\n            this.pan(p);\n        }\n    }\n\n    private pan({position, surface}: Pointer) {\n        let toPrevious = Vec2.fromPointToPoint(position, this.previous); \n        let actual = surface.pan(toPrevious);\n        Vec2.add(actual, position, this.previous);\n    }\n}\n   ","import { LineSegment, Point, Pointer, PointerEventListener, Vec2 } from \"..\";\n\nexport class PinchZoomTool extends PointerEventListener {\n\n    private previousSpan: number;\n    private previousFocus: Point.Like;\n\n    wherePointer(p: Pointer) {\n        return p.isDown && p.activePointers.length == 2;\n    }\n\n    onPointerDown(p: Pointer) {\n        let line = this.measureLine(p);\n        this.previousSpan = line.length;\n        this.previousFocus = line.midpoint;\n    }\n\n    onPointerMove(p: Pointer) {\n        let line = this.measureLine(p);\n        let scale = line.length / this.previousSpan;\n        let focus = Point.midpoint(line.midpoint, this.previousFocus);\n        let actual = p.surface.zoomToPoint(scale, focus);\n        this.previousSpan = line.length / actual.scale;\n        this.previousFocus = Vec2.add(actual.offset, this.previousFocus);\n    }\n\n    private measureLine({activePointers}: Pointer) {\n        let p1 = activePointers[0].position;\n        let p2 = activePointers[1].position;\n        return new LineSegment(p1, p2);\n    }\n}\n  ","\nimport { Vec2, Point } from '..';\n\nexport class Stroke {\n\n    public readonly vertices = <Point.Like[]> [];\n\n    /**\n     * Begins this stroke at the specified point.\n     * @param p where to begin the stroke.\n     * @param thickness the thickness of the initial line.\n     */\n    moveTo({x, y}: Point.Like, thickness: number) {\n        let halfThickness = thickness * 0.5;\n        let top = {x: x, y: y + halfThickness};\n        let bot = {x: x, y: y - halfThickness};\n        this.vertices.push(top, bot);\n    }\n\n   /**\n     * Adds a line to the specified point.\n     * @param point the point at the end of the line.\n     * @param thickness the thickness of the line.\n     */\n    lineTo(p: Point.Like, thickness: number) {\n        let nextIndex = this.vertices.length;\n        if (nextIndex < 2) {\n            throw \"Must make a call to moveTo() before making a call to lineTo()\"\n        }\n\n        let halfThickness = 0.5 * thickness\n        let prevCen = this.getPreviousPoint(nextIndex);\n        let line = Vec2.fromPointToPoint(prevCen, p);\n        let prevLine = null;\n        \n        // Merge with previous line if the length of either line is less than half of the desired thickness\n        if (nextIndex >= 4) {\n            let prevPrevCen = this.getPreviousPoint(nextIndex - 2);\n            prevLine = Vec2.fromPointToPoint(prevPrevCen, prevCen);\n            if(Vec2.length(line) <= halfThickness && Vec2.length(prevLine) <= halfThickness){\n                nextIndex -= 2;\n                prevCen = prevPrevCen;\n                line = Vec2.fromPointToPoint(prevCen, p);\n                prevLine = nextIndex >= 4 ? this.getPreviousPoint(nextIndex - 2) : null;\n            }\n        }\n\n        // If there are more than two line segments (with non-zero length), use a miter vector to join them. \n        // Otherwise use the ortho vector to compute the top and bottom left vertices of the line segment.\n        let ortho = Vec2.multiply(Vec2.normalize(Vec2.rotate90(line)), halfThickness);\n        let useMiter = prevLine !== null && Vec2.length(prevLine) > thickness / 8; \n        let miter = useMiter ? Vec2.miter(prevLine, line, halfThickness, thickness) : ortho;\n\n        // Join to previous line\n        this.vertices[nextIndex - 2] = Vec2.add(prevCen, miter);\n        this.vertices[nextIndex - 1] = Vec2.subtract(prevCen, miter);\n        this.vertices[nextIndex + 0] = Vec2.add(p, ortho);\n        this.vertices[nextIndex + 1] = Vec2.subtract(p, ortho);\n    }\n\n    private getPreviousPoint(currIndex: number) {\n        let vertices = this.vertices;\n        let prevTop = vertices[currIndex - 2];\n        let prevBot = vertices[currIndex - 1];\n        return Point.midpoint(prevTop, prevBot);\n    }\n}\n","import {Wheel, WheelEventListener} from '..'\n\n/** Tool for zooming in and out of a surface based on scroll events and cursor position. */\nexport class WheelZoomTool implements WheelEventListener {\n\n    constructor(\n        /** The scale applied to the surface when zooming in. The inverse is applied when zooming out. */\n        public scaleFactor: number\n    ){}\n\n    onWheel(wheel: Wheel) {\n        let scale = wheel.deltaY < 0 ? this.scaleFactor : 1 / this.scaleFactor;\n        let actual = wheel.surface.zoomToPoint(scale, wheel.position);\n    }\n}","import * as Color from './struct/color'\nimport * as Rect from './struct/rect'\n\nexport type bit = 0 | 1;\n\n/**\n * Array of bits backed by an array buffer.\n */\nexport class BitArray {\n\n    /**\n     * Byte view of the backing data for this array.\n     */\n    public data: Uint8Array;\n\n    /**\n     * The number of bits in this array. Fixed at construction and thus readonly.\n     */\n    public length: number;\n\n    /**\n     * Creates a bit array backed by the specified array buffer.\n     * @param buffer the backing data for the array.\n     */\n    constructor(buffer: ArrayBuffer) {\n        this.data = new Uint8Array(buffer);\n        this.length = buffer.byteLength << 3; // or * 8\n    }\n\n    /**\n     * Gets the bit at the specified index of this array.\n     * @param index The index of the bit in this array.\n     */\n    get(index: number): bit {\n        // Ex: index = 0b10011 (20th bit)\n        let byteIndex = index >> 3;              // 0b10 (2) -> third byte\n        let bitShift = index & 0b111;            // 0b11 (3) -> fourth bit\n        let byte = this.data[byteIndex];         // Assume byte = 0b10101\n        return <bit> ((byte >> bitShift) & 0b1); // Then fourth bit = 0\n    }\n\n    /**\n     * Sets the bit at the specified index of this array (to one).\n     * @param index The index of the bit to set.\n     */\n    set(index: number) {\n        // Ex: index = byte3 = 0b10011 (20th bit)\n        let byteIndex = index >> 3;            // 0b10 (2) -> third byte\n        let bitShift = index & 0b111;          // 0b11 (3) -> fourth bit\n        this.data[byteIndex] |= (1 << bitShift); // 0b11011\n    }\n\n    /**\n     * Clears the bit at the specified index of this array (to zero).\n     * @param index The index of the bit to clear.\n     */\n    clear(index: number) {\n        // Ex: index = byte3 = 0b10011 (20th bit)\n        let byteIndex = index >> 3;               // 0b10 (2) -> third byte\n        let bitShift = index & 0b111;             // 0b11 (3) -> fourth bit\n        this.data[byteIndex] &= ~(1 << bitShift); // 0b10011\n    }\n\n    /**\n     * Invokes the callback on each of the bits in this array.\n     * @param callback The callback to invoke.\n     */\n    forEach(callback: (bit: bit) => void) {\n        for (let i = 0; i < this.data.length; i++) {\n            let byte = this.data[i];\n            for (let j = 0; j < 8; j++) {\n                callback(<bit>((byte >> j) & 0b1));\n            }\n        }\n    }\n\n    /**\n     * Converts this bit array to a string of ones and zeros.\n     */\n    toString() {\n        let str = \"\";\n        this.forEach((bit) => {\n            str += bit;\n        });\n        return str;\n    }\n}\n\nexport class BinaryImage {\n\n    /**\n     * The bit array backing this image.\n     */\n    readonly data: BitArray;\n\n    /**\n     * The color referenced by the '1's in the bit array.\n     */\n    readonly color: Color.Struct;\n\n    /**\n     * The bounded area where all the '1's in this image reside.\n     */\n    readonly bounds: Rect.Obj;\n\n    constructor(data: BitArray, bounds: Rect.Obj, color: Color.Struct) {\n        this.data = data;\n        this.color = color;\n        this.bounds = bounds;\n    }\n\n    static make(data: BitArray, width: number, height: number, color: Color.Struct) {\n        // Find smallest rect containing all the '1's in the backing array\n        let bounds: Rect.Obj;\n        for (let y = 0, i = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                if (data.get(i++)) { // Nonzero\n                    if (bounds) {\n                        bounds.unionPoint$(x, y);\n                    } else {\n                        bounds = Rect.Obj.ltrb(x, y, x, y);\n                    }\n                }\n            }\n        }\n\n        // Return null if image consists entirely of zeros\n        if (!bounds) return null\n\n        // Get number of colums and rows in bounded area\n        let cols = Rect.width(bounds) + 1, rows = Rect.height(bounds) + 1;\n\n        // Make bit array enough to hold data from the bounded area\n        let dst = createBitArray(cols * rows);\n\n        // Copy bit data into dst\n        for (let y = bounds.bottom, i = 0; y <= bounds.top; y++) {\n            for (let x = bounds.left; x <= bounds.right; x++ , i++) {\n                if (data.get(y * width + x)) {\n                    dst.set(i);\n                }\n            }\n        }\n\n        // Pass compressed data to new instance and return\n        return new BinaryImage(dst, bounds, color);\n    }\n\n    /**\n     * Invokes the specified callback on the index of each of the set bits in this array.\n     * @param callback the callback to invoke.\n     */\n    forEachSetBit(dstWidth: number, callback: (index: number) => void) {\n        let x = this.bounds.left,\n            base = this.bounds.bottom * dstWidth;\n        // For each of the bits in the array\n        this.data.forEach((bit) => {\n            // If the bit is set\n            if (bit) {\n                // Send bit index\n                callback(base + x)\n            }\n            // Update x position and base index\n            if (++x > this.bounds.right) {\n                x = this.bounds.left;\n                base += dstWidth;\n            }\n        })\n    }\n\n}\n\n/**\n * Creates an array with the specified bit capacity, rounded up to the nearest multiple of 8.\n */\nexport function createBitArray(capacity: number) {\n    let byteCount = capacity >> 3;     // Divide by 8 \n    if (capacity & 0b111) byteCount++; // Round up\n    return new BitArray(new ArrayBuffer(byteCount)); \n}  \n\n\n\n\n\n","// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\nimport * as Point from \"./point\";\nimport Structure from \"../structify/struct\";\nimport StructureBuffer from \"../structify/buf\";\n\n/**\n * A rectangle with (left, top, right, bottom) boundaries.\n */\ninterface Rect {\n    /**\n     * The left boundary of this Rect.\n     */\n    left: number;\n    /**\n     * The top boundary of this Rect.\n     */\n    top: number;\n    /**\n     * The right boundary of this Rect.\n     */\n    right: number;\n    /**\n     * The bottom boundary of this Rect.\n     */\n    bottom: number;\n}\nexport { Rect as _};\n/**\n * Sets each component of this Rect to that of the other Rect.\n */\nexport function set(_this: Rect, other: Rect) {\n    _this.left = other.left;\n    _this.top = other.top;\n    _this.right = other.right;\n    _this.bottom = other.bottom;\n}\n\n/**\n * Sets each component of this Rect.\n */\nexport function set$(_this: Rect, left: number, top: number, right: number, bottom: number) {\n    _this.left = left;\n    _this.top = top;\n    _this.right = right;\n    _this.bottom = bottom;\n}\n\n/**\n * Adds the other Rect to this Rect componentwise.\n */\nexport function add(_this: Rect, other: Rect) {\n    _this.left += other.left;\n    _this.top += other.top;\n    _this.right += other.right;\n    _this.bottom += other.bottom;\n}\n\n/**\n * Adds the specified values to this Rect componentwise.\n */\nexport function add$(_this: Rect, left: number, top: number, right: number, bottom: number) {\n    _this.left += left;\n    _this.top += top;\n    _this.right += right;\n    _this.bottom += bottom;\n}\n\n/**\n * Subtracts the other Rect from this Rect componentwise.\n */\nexport function subtract(_this: Rect, other: Rect) {\n    _this.left -= other.left;\n    _this.top -= other.top;\n    _this.right -= other.right;\n    _this.bottom -= other.bottom;\n}\n\n/**\n * Subtracts the specified values from this Rect componentwise.\n */\nexport function subtract$(_this: Rect, left: number, top: number, right: number, bottom: number) {\n    _this.left -= left;\n    _this.top -= top;\n    _this.right -= right;\n    _this.bottom -= bottom;\n}\n\n/**\n * Multiplies each component of this Rect by the specified scalar.\n */\nexport function mulScalar(_this: Rect, k: number) {\n    _this.left *= k;\n    _this.top *= k;\n    _this.right *= k;\n    _this.bottom *= k;\n}\n\n/**\n * Divides each component of this Rect by the specified scalar.\n */\nexport function divScalar(_this: Rect, k: number) {\n    _this.left /= k;\n    _this.top /= k;\n    _this.right /= k;\n    _this.bottom /= k;\n}\n\n/**\n * Checks if each component of this Rect is equal to that of the other Rect.\n */\nexport function equals(_this: Rect, other: Rect) {\n    return _this.left === other.left && _this.top === other.top && _this.right === other.right && _this.bottom === other.bottom;\n}\n\n/**\n * Checks if each component of this Rect is equal to the specified scalar.\n */\nexport function equalsScalar(_this: Rect, k: number) {\n    return _this.left === k && _this.top === k && _this.right === k && _this.bottom === k;\n}\n\n/**\n * Checks if each component of this Rect is approximately equal to that of the other Rect.\n */\nexport function epsilonEquals(_this: Rect, other: Rect, e: number) {\n    return Math.abs(_this.left - other.left) <= e && Math.abs(_this.top - other.top) <= e && Math.abs(_this.right - other.right) <= e && Math.abs(_this.bottom - other.bottom) <= e;\n}\n\n/**\n * Checks if each component of this Rect is approximately equal to the specified scalar.\n */\nexport function epsilonEqualsScalar(_this: Rect, k: number, e: number) {\n    return Math.abs(_this.left - k) <= e && Math.abs(_this.top - k) <= e && Math.abs(_this.right - k) <= e && Math.abs(_this.bottom - k) <= e;\n}\n\n/**\n * Returns a string representation of this Rect.\n */\nexport function toString(_this: Rect) {\n    return `{ left: ${_this.left}, top: ${_this.top}, right: ${_this.right}, bottom: ${_this.bottom} }`\n}\n\n/**\n * Sets the boundaries of this Rect in left-top-right-bottom order.\n */\nexport function setLtrb(_this: Rect, left: number, top: number, right: number, bottom: number) {\n    _this.left = left;\n    _this.top = top;\n    _this.right = right;\n    _this.bottom = bottom;\n}\n\n/**\n * Sets the boundaries of this Rect in left-bottom-right-top order.\n */\nexport function setLbrt(_this: Rect, left: number, bottom: number, right: number, top: number) {\n    _this.left = left;\n    _this.top = top;\n    _this.right = right;\n    _this.bottom = bottom;\n}\n\n/**\n * Sets the boundaries of this Rect in left-right-bottom-top order.\n */\nexport function setLrbt(_this: Rect, left: number, right: number, bottom: number, top: number) {\n    _this.left = left;\n    _this.top = top;\n    _this.right = right;\n    _this.bottom = bottom;\n}\n\n/**\n * Sets the dimensions of this rect in left-top-width-height order.\n */\nexport function setLtwh(_this: Rect, left: number, top: number, width: number, height: number) {\n    _this.left = left;\n    _this.top = top;\n    _this.right = left + width;\n    _this.bottom = top - height;\n}\n\n/**\n * Sets the dimensions of this rect in left-bottom-width-height order.\n */\nexport function setLbwh(_this: Rect, left: number, bottom: number, width: number, height: number) {\n    _this.left = left;\n    _this.top = bottom + height;\n    _this.right = left + width;\n    _this.bottom = bottom;\n}\n\n/**\n * Checks if this Rect is empty. True if left >= right or bottom >= top.\n */\nexport function isEmpty(_this: Rect) {\n    return _this.left >= _this.right || _this.bottom >= _this.top;\n}\n\n/**\n * Checks if the boundaries of this Rect represent a valid rectangle. True if right >= left and top >= bottom.\n */\nexport function isValid(_this: Rect) {\n    return _this.right >= _this.left && _this.top >= _this.bottom;\n}\n\n/**\n * Computes the width of this Rect.\n */\nexport function width(_this: Rect) {\n    return _this.right - _this.left;\n}\n\n/**\n * Computes the height of this Rect.\n */\nexport function height(_this: Rect) {\n    return _this.top - _this.bottom;\n}\n\n/**\n * Computes the area of this Rect.\n */\nexport function area(_this: Rect) {\n    return width(_this, ) * height(_this, );\n}\n\n/**\n * Finds the x-coordinate of the point at the center of this Rect.\n */\nexport function centerX(_this: Rect) {\n    return 0.5 * (_this.left + _this.right);\n}\n\n/**\n * Finds the y-coordinate of the point at the center of this Rect.\n */\nexport function centerY(_this: Rect) {\n    return 0.5 * (_this.bottom + _this.top);\n}\n\n/**\n * Sets the specified point to the point at the center of this Rect\n */\nexport function center(_this: Rect, dst: Point._) {\n    dst.x = centerX(_this, );\n    dst.y = centerY(_this, );\n    return dst;\n}\n\n/**\n * Sets the specified point to the point between the top left and top right corners of this Rect.\n */\nexport function centerTop(_this: Rect, dst: Point._) {\n    dst.x = centerX(_this, );\n    dst.y = _this.top;\n    return dst;\n}\n\n/**\n *  Sets the specified point to the point between the bottom left and bottom right corners of this Rect.\n */\nexport function centerBottom(_this: Rect, dst: Point._) {\n    dst.x = centerX(_this, );\n    dst.y = _this.bottom;\n    return dst;\n}\n\n/**\n * Sets the specified point to the point between the top and bottom left corners of this Rect.\n */\nexport function centerLeft(_this: Rect, dst: Point._) {\n    dst.x = _this.left;\n    dst.y = centerY(_this, );\n    return dst;\n}\n\n/**\n * Sets the specified point to the point between the top and bottom right corners of this Rect.\n */\nexport function centerRight(_this: Rect, dst: Point._) {\n    dst.x = _this.left;\n    dst.y = centerY(_this, );\n    return dst;\n}\n\n/**\n * Sets the specified point to the point at the bottom left corner of this Rect.\n */\nexport function bottomLeft(_this: Rect, dst: Point._) {\n    dst.x = _this.left;\n    dst.y = _this.bottom;\n    return dst;\n}\n\n/**\n * Sets the specified point to the point at the bottom right corner of this Rect.\n */\nexport function bottomRight(_this: Rect, dst: Point._) {\n    dst.x = _this.right;\n    dst.y = _this.bottom;\n    return dst;\n}\n\n/**\n * Sets the specified point to the point at the top left corner of this Rect.\n */\nexport function topLeft(_this: Rect, dst: Point._) {\n    dst.x = _this.left;\n    dst.y = _this.top;\n    return dst;\n}\n\n/**\n * Sets the specified point to the point at the top right corner of this Rect.\n */\nexport function topRight(_this: Rect, dst: Point._) {\n    dst.x = _this.right;\n    dst.y = _this.top;\n    return dst;\n}\n\n/**\n * Sets this Rect to the empty rect (0,0,0,0).\n */\nexport function empty(_this: Rect) {\n    _this.left = 0;\n    _this.top = 0;\n    _this.right = 0;\n    _this.bottom = 0;\n}\n\n/**\n * Sets this Rect to the smallest rectangle containing the two specified points.\n */\nexport function setUnionOfPoints(_this: Rect, points: Point._[], offset = 0, count = points.length) {\n    _this.left = _this.right = points[offset].x;\n    _this.top = _this.bottom = points[offset].y;\n    unionPoints(_this, points, offset + 1, count - 1);\n}\n\n/**\n * Sets this Rect to the smallest rectangle containing a subset of points in the specified array.\n * @param points array of points entered as a series of (x,y) coordinates.\n * @param offset offset of the first point in the subset.\n * @param count number of points in the subset.\n */\nexport function setUnionOfPoints$(_this: Rect, points: Float32Array, offset = 0, count = points.length >> 1) {\n    _this.left = _this.right = points[offset++];\n    _this.top = _this.bottom = points[offset++];\n    unionPoints$(_this, points, offset, count - 1);\n}\n\n/**\n * Checks if this Rect contains the other Rect.\n */\nexport function contains(_this: Rect, other: Rect) {\n    return _this.left <= other.left && other.right <= _this.right &&\n                _this.bottom <= other.bottom && other.top <= _this.top;\n}\n\n/**\n * Checks if this Rect contains the specified point.\n */\nexport function containsPoint(_this: Rect, p: Point._) {\n    return containsPoint$(_this, p.x, p.y);\n}\n\n/**\n * Checks if this Rect contains the point (x,y).\n */\nexport function containsPoint$(_this: Rect, x: number, y: number) {\n    return _this.left <= x && x <= _this.right && _this.bottom <= y && y <= _this.top;\n}\n\n/**\n * Checks if this Rect intersects the other Rect.\n */\nexport function intersects(_this: Rect, other: Rect) {\n    return _this.right >= other.left && other.right >= _this.left\n                && _this.top >= other.bottom && other.top >= _this.bottom;\n}\n\n/**\n * Sets this Rect to the intersection of itself with the other Rect.\n */\nexport function intersect(_this: Rect, other: Rect) {\n    _this.left = Math.max(_this.left, other.left);\n    _this.right = Math.min(_this.right, other.right);\n    _this.bottom = Math.max(_this.bottom, other.bottom);\n    _this.top = Math.min(_this.top, other.top);\n}\n\n/**\n * Expands this Rect to enclose the other Rect.\n */\nexport function union(_this: Rect, other: Rect) {\n    _this.left = Math.max(_this.left, other.left);\n    _this.right = Math.min(_this.right, other.right);\n    _this.bottom = Math.max(_this.bottom, other.bottom);\n    _this.top = Math.min(_this.top, other.top);\n}\n\n/**\n * Expands this Rect to enclose the specified point.\n */\nexport function unionPoint(_this: Rect, p: Point._) {\n    unionPoint$(_this, p.x, p.y);\n}\n\n/**\n * Expands this Rect to enclose the point (x,y).\n */\nexport function unionPoint$(_this: Rect, x: number, y: number) {\n    _this.left = Math.min(x, _this.left);\n    _this.top = Math.max(y, _this.top);\n    _this.right = Math.max(x, _this.right);\n    _this.bottom = Math.min(y, _this.bottom);\n}\n\n/**\n * Expands this Rect to enclose the specified points\n * @param points array of points.\n * @param offset offset of the first point in the subset.\n * @param count number of points in the subset.\n */\nexport function unionPoints(_this: Rect, points: Point._[], offset = 0, count = points.length) {\n    while (count-- > 0) {\n                //Expand _this Rect to enclose the point\n                unionPoint(_this, points[offset++]);\n            }\n}\n\n/**\n * Expands this Rect to enclose the specified points\n * @param points array of points entered as a series of (x,y) coordinates.\n * @param offset offset of the first point in the subset.\n * @param count number of points in the subset.\n */\nexport function unionPoints$(_this: Rect, points: Float32Array, offset = 0, count = points.length >> 1) {\n    while (count-- > 0) {\n                //Expand _this Rect to enclose the point\n                unionPoint$(_this, points[offset++], points[offset++]);\n            }\n}\n\n/**\n * Insets the boundaries of this Rect by the vector (dx,dy).\n */\nexport function inset(_this: Rect, dx: number, dy: number) {\n    _this.left += dx;\n    _this.top -= dy;\n    _this.right -= dx;\n    _this.bottom += dy;\n}\n\n/**\n * Offsets the boundaries of this Rect by the vector (dx,dy).\n */\nexport function offset(_this: Rect, dx: number, dy: number) {\n    _this.left += dx;\n    _this.top += dy;\n    _this.right += dx;\n    _this.bottom += dy;\n}\n\n/**\n * Scales this Rect out from it's center by the specified (sx,sy) percentages.\n * @param r the Rect to scale.\n * @param sx the percentage by which to scale in the horizontal direction.\n * @param sy the percentage by which to scale in the vertical direction.\n */\nexport function scale(_this: Rect, sx: number, sy: number) {\n    let cx = centerX(_this, );\n    let cy = centerY(_this, );\n    offset(_this, -cx, -cy);\n    _this.left *= sx;\n    _this.right *= sx;\n    _this.bottom *= sy;\n    _this.top *= sy;\n    offset(_this, cx, cy);\n}\n\n/**\n * Stretches this Rect out from it's center by the specified ratio, maintaining aspect.\n * @param ratio the percentage by which to stretch in all directions.\n */\nexport function stretch(_this: Rect, ratio: number) {\n    scale(_this, ratio, ratio);\n}\n\n/**\n * Shrinks this Rect to a square with the same center point.\n */\nexport function shrinkToSquare(_this: Rect) {\n    let w = width(_this, ), h = height(_this, );\n    if (h > w) {\n                // Cut off top and bottom edges by scaling\n                scale(_this, 1, w / h);\n            }\n            // Otherwise, if _this Rect is wider than it is tall\n            else if (w > h) {\n                // Cut off left and right edges by scaling\n                scale(_this, h / w, 1);\n            }\n}\n\n/**\n * Expands this Rect to a square with the same center point.\n */\nexport function expandToSquare(_this: Rect) {\n    let w = width(_this, ), h = height(_this, );\n    if (h > w) {\n                // Scale left and right edges so width=height\n                scale(_this, h / w, 1);\n            }\n            // Otherwise, if _this Rect is wider than it is tall\n            else if (w > h) {\n                // Scale top and bottom edges so width=height\n                scale(_this, 1, w / h);\n            }\n}\n\n/**\n * Swaps the top/bottom or left/right boundaries of this Rect if they are flipped, meaning left > right and/or top > bottom.\n */\nexport function sort(_this: Rect) {\n    if (_this.bottom > _this.top) {\n                //Swap top and bottom\n                let topCopy = _this.top;\n                _this.top = _this.bottom;\n                _this.bottom = topCopy;\n            }\n    if (_this.left > _this.right) {\n                //Swap left and right\n                let rightCopy = _this.right;\n                _this.right = _this.left;\n                _this.left = rightCopy;\n            }\n}\n\n/**\n * A rectangle with (left, top, right, bottom) boundaries.\n */\nexport class Obj {\n    static create(other: Rect) {\n        let Rect = new Obj();\n        Rect.set(other);\n        return Rect;\n    }\n\n    static create$(left: number, top: number, right: number, bottom: number) {\n        let Rect = new Obj();\n        Rect.set$(left, top, right, bottom);\n        return Rect;\n    }\n\n    static ltrb(left: number, top: number, right: number, bottom: number) {\n        let Rect = new Obj();\n        Rect.setLtrb(left, top, right, bottom);\n        return Rect;\n    }\n\n    static lbrt(left: number, bottom: number, right: number, top: number) {\n        let Rect = new Obj();\n        Rect.setLbrt(left, bottom, right, top);\n        return Rect;\n    }\n\n    static lrbt(left: number, right: number, bottom: number, top: number) {\n        let Rect = new Obj();\n        Rect.setLrbt(left, right, bottom, top);\n        return Rect;\n    }\n\n    static ltwh(left: number, top: number, width: number, height: number) {\n        let Rect = new Obj();\n        Rect.setLtwh(left, top, width, height);\n        return Rect;\n    }\n\n    static lbwh(left: number, bottom: number, width: number, height: number) {\n        let Rect = new Obj();\n        Rect.setLbwh(left, bottom, width, height);\n        return Rect;\n    }\n\n    static unionOfPoints(points: Point._[], offset = 0, count = points.length) {\n        let Rect = new Obj();\n        Rect.setUnionOfPoints(points, offset, count);\n        return Rect;\n    }\n\n    static unionOfPoints$(points: Float32Array, offset = 0, count = points.length >> 1) {\n        let Rect = new Obj();\n        Rect.setUnionOfPoints$(points, offset, count);\n        return Rect;\n    }\n\n    /**\n     * The left boundary of this Rect.\n     */\n    left: number;\n    /**\n     * The top boundary of this Rect.\n     */\n    top: number;\n    /**\n     * The right boundary of this Rect.\n     */\n    right: number;\n    /**\n     * The bottom boundary of this Rect.\n     */\n    bottom: number;\n\n    /**\n     * Sets each component of this Rect to that of the other Rect.\n     */\n    set(other: Rect) {\n        return set(this, other);\n    }\n\n    /**\n     * Sets each component of this Rect.\n     */\n    set$(left: number, top: number, right: number, bottom: number) {\n        return set$(this, left, top, right, bottom);\n    }\n\n    /**\n     * Adds the other Rect to this Rect componentwise.\n     */\n    add(other: Rect) {\n        return add(this, other);\n    }\n\n    /**\n     * Adds the specified values to this Rect componentwise.\n     */\n    add$(left: number, top: number, right: number, bottom: number) {\n        return add$(this, left, top, right, bottom);\n    }\n\n    /**\n     * Subtracts the other Rect from this Rect componentwise.\n     */\n    subtract(other: Rect) {\n        return subtract(this, other);\n    }\n\n    /**\n     * Subtracts the specified values from this Rect componentwise.\n     */\n    subtract$(left: number, top: number, right: number, bottom: number) {\n        return subtract$(this, left, top, right, bottom);\n    }\n\n    /**\n     * Multiplies each component of this Rect by the specified scalar.\n     */\n    mulScalar(k: number) {\n        return mulScalar(this, k);\n    }\n\n    /**\n     * Divides each component of this Rect by the specified scalar.\n     */\n    divScalar(k: number) {\n        return divScalar(this, k);\n    }\n\n    /**\n     * Checks if each component of this Rect is equal to that of the other Rect.\n     */\n    equals(other: Rect) {\n        return equals(this, other);\n    }\n\n    /**\n     * Checks if each component of this Rect is equal to the specified scalar.\n     */\n    equalsScalar(k: number) {\n        return equalsScalar(this, k);\n    }\n\n    /**\n     * Checks if each component of this Rect is approximately equal to that of the other Rect.\n     */\n    epsilonEquals(other: Rect, e: number) {\n        return epsilonEquals(this, other, e);\n    }\n\n    /**\n     * Checks if each component of this Rect is approximately equal to the specified scalar.\n     */\n    epsilonEqualsScalar(k: number, e: number) {\n        return epsilonEqualsScalar(this, k, e);\n    }\n\n    /**\n     * Returns a string representation of this Rect.\n     */\n    toString() {\n        return toString(this);\n    }\n\n    /**\n     * Sets the boundaries of this Rect in left-top-right-bottom order.\n     */\n    setLtrb(left: number, top: number, right: number, bottom: number) {\n        return setLtrb(this, left, top, right, bottom);\n    }\n\n    /**\n     * Sets the boundaries of this Rect in left-bottom-right-top order.\n     */\n    setLbrt(left: number, bottom: number, right: number, top: number) {\n        return setLbrt(this, left, bottom, right, top);\n    }\n\n    /**\n     * Sets the boundaries of this Rect in left-right-bottom-top order.\n     */\n    setLrbt(left: number, right: number, bottom: number, top: number) {\n        return setLrbt(this, left, right, bottom, top);\n    }\n\n    /**\n     * Sets the dimensions of this rect in left-top-width-height order.\n     */\n    setLtwh(left: number, top: number, width: number, height: number) {\n        return setLtwh(this, left, top, width, height);\n    }\n\n    /**\n     * Sets the dimensions of this rect in left-bottom-width-height order.\n     */\n    setLbwh(left: number, bottom: number, width: number, height: number) {\n        return setLbwh(this, left, bottom, width, height);\n    }\n\n    /**\n     * Checks if this Rect is empty. True if left >= right or bottom >= top.\n     */\n    isEmpty() {\n        return isEmpty(this);\n    }\n\n    /**\n     * Checks if the boundaries of this Rect represent a valid rectangle. True if right >= left and top >= bottom.\n     */\n    isValid() {\n        return isValid(this);\n    }\n\n    /**\n     * Computes the width of this Rect.\n     */\n    width() {\n        return width(this);\n    }\n\n    /**\n     * Computes the height of this Rect.\n     */\n    height() {\n        return height(this);\n    }\n\n    /**\n     * Computes the area of this Rect.\n     */\n    area() {\n        return area(this);\n    }\n\n    /**\n     * Finds the x-coordinate of the point at the center of this Rect.\n     */\n    centerX() {\n        return centerX(this);\n    }\n\n    /**\n     * Finds the y-coordinate of the point at the center of this Rect.\n     */\n    centerY() {\n        return centerY(this);\n    }\n\n    /**\n     * Sets the specified point to the point at the center of this Rect\n     */\n    center(dst: Point._) {\n        return center(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point between the top left and top right corners of this Rect.\n     */\n    centerTop(dst: Point._) {\n        return centerTop(this, dst);\n    }\n\n    /**\n     *  Sets the specified point to the point between the bottom left and bottom right corners of this Rect.\n     */\n    centerBottom(dst: Point._) {\n        return centerBottom(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point between the top and bottom left corners of this Rect.\n     */\n    centerLeft(dst: Point._) {\n        return centerLeft(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point between the top and bottom right corners of this Rect.\n     */\n    centerRight(dst: Point._) {\n        return centerRight(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point at the bottom left corner of this Rect.\n     */\n    bottomLeft(dst: Point._) {\n        return bottomLeft(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point at the bottom right corner of this Rect.\n     */\n    bottomRight(dst: Point._) {\n        return bottomRight(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point at the top left corner of this Rect.\n     */\n    topLeft(dst: Point._) {\n        return topLeft(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point at the top right corner of this Rect.\n     */\n    topRight(dst: Point._) {\n        return topRight(this, dst);\n    }\n\n    /**\n     * Sets this Rect to the empty rect (0,0,0,0).\n     */\n    empty() {\n        return empty(this);\n    }\n\n    /**\n     * Sets this Rect to the smallest rectangle containing the two specified points.\n     */\n    setUnionOfPoints(points: Point._[], offset = 0, count = points.length) {\n        return setUnionOfPoints(this, points, offset, count);\n    }\n\n    /**\n     * Sets this Rect to the smallest rectangle containing a subset of points in the specified array.\n     * @param points array of points entered as a series of (x,y) coordinates.\n     * @param offset offset of the first point in the subset.\n     * @param count number of points in the subset.\n     */\n    setUnionOfPoints$(points: Float32Array, offset = 0, count = points.length >> 1) {\n        return setUnionOfPoints$(this, points, offset, count);\n    }\n\n    /**\n     * Checks if this Rect contains the other Rect.\n     */\n    contains(other: Rect) {\n        return contains(this, other);\n    }\n\n    /**\n     * Checks if this Rect contains the specified point.\n     */\n    containsPoint(p: Point._) {\n        return containsPoint(this, p);\n    }\n\n    /**\n     * Checks if this Rect contains the point (x,y).\n     */\n    containsPoint$(x: number, y: number) {\n        return containsPoint$(this, x, y);\n    }\n\n    /**\n     * Checks if this Rect intersects the other Rect.\n     */\n    intersects(other: Rect) {\n        return intersects(this, other);\n    }\n\n    /**\n     * Sets this Rect to the intersection of itself with the other Rect.\n     */\n    intersect(other: Rect) {\n        return intersect(this, other);\n    }\n\n    /**\n     * Expands this Rect to enclose the other Rect.\n     */\n    union(other: Rect) {\n        return union(this, other);\n    }\n\n    /**\n     * Expands this Rect to enclose the specified point.\n     */\n    unionPoint(p: Point._) {\n        return unionPoint(this, p);\n    }\n\n    /**\n     * Expands this Rect to enclose the point (x,y).\n     */\n    unionPoint$(x: number, y: number) {\n        return unionPoint$(this, x, y);\n    }\n\n    /**\n     * Expands this Rect to enclose the specified points\n     * @param points array of points.\n     * @param offset offset of the first point in the subset.\n     * @param count number of points in the subset.\n     */\n    unionPoints(points: Point._[], offset = 0, count = points.length) {\n        return unionPoints(this, points, offset, count);\n    }\n\n    /**\n     * Expands this Rect to enclose the specified points\n     * @param points array of points entered as a series of (x,y) coordinates.\n     * @param offset offset of the first point in the subset.\n     * @param count number of points in the subset.\n     */\n    unionPoints$(points: Float32Array, offset = 0, count = points.length >> 1) {\n        return unionPoints$(this, points, offset, count);\n    }\n\n    /**\n     * Insets the boundaries of this Rect by the vector (dx,dy).\n     */\n    inset(dx: number, dy: number) {\n        return inset(this, dx, dy);\n    }\n\n    /**\n     * Offsets the boundaries of this Rect by the vector (dx,dy).\n     */\n    offset(dx: number, dy: number) {\n        return offset(this, dx, dy);\n    }\n\n    /**\n     * Scales this Rect out from it's center by the specified (sx,sy) percentages.\n     * @param r the Rect to scale.\n     * @param sx the percentage by which to scale in the horizontal direction.\n     * @param sy the percentage by which to scale in the vertical direction.\n     */\n    scale(sx: number, sy: number) {\n        return scale(this, sx, sy);\n    }\n\n    /**\n     * Stretches this Rect out from it's center by the specified ratio, maintaining aspect.\n     * @param ratio the percentage by which to stretch in all directions.\n     */\n    stretch(ratio: number) {\n        return stretch(this, ratio);\n    }\n\n    /**\n     * Shrinks this Rect to a square with the same center point.\n     */\n    shrinkToSquare() {\n        return shrinkToSquare(this);\n    }\n\n    /**\n     * Expands this Rect to a square with the same center point.\n     */\n    expandToSquare() {\n        return expandToSquare(this);\n    }\n\n    /**\n     * Swaps the top/bottom or left/right boundaries of this Rect if they are flipped, meaning left > right and/or top > bottom.\n     */\n    sort() {\n        return sort(this);\n    }\n}\n\n/**\n * A Rect backed by a Float32Array.\n */\nexport class Struct extends Structure<Float32Array> {\n    static create(other: Rect) {\n        let Rect = new Struct();\n        Rect.set(other);\n        return Rect;\n    }\n\n    static create$(left: number, top: number, right: number, bottom: number) {\n        let Rect = new Struct();\n        Rect.set$(left, top, right, bottom);\n        return Rect;\n    }\n\n    static ltrb(left: number, top: number, right: number, bottom: number) {\n        let Rect = new Struct();\n        Rect.setLtrb(left, top, right, bottom);\n        return Rect;\n    }\n\n    static lbrt(left: number, bottom: number, right: number, top: number) {\n        let Rect = new Struct();\n        Rect.setLbrt(left, bottom, right, top);\n        return Rect;\n    }\n\n    static lrbt(left: number, right: number, bottom: number, top: number) {\n        let Rect = new Struct();\n        Rect.setLrbt(left, right, bottom, top);\n        return Rect;\n    }\n\n    static ltwh(left: number, top: number, width: number, height: number) {\n        let Rect = new Struct();\n        Rect.setLtwh(left, top, width, height);\n        return Rect;\n    }\n\n    static lbwh(left: number, bottom: number, width: number, height: number) {\n        let Rect = new Struct();\n        Rect.setLbwh(left, bottom, width, height);\n        return Rect;\n    }\n\n    static unionOfPoints(points: Point._[], offset = 0, count = points.length) {\n        let Rect = new Struct();\n        Rect.setUnionOfPoints(points, offset, count);\n        return Rect;\n    }\n\n    static unionOfPoints$(points: Float32Array, offset = 0, count = points.length >> 1) {\n        let Rect = new Struct();\n        Rect.setUnionOfPoints$(points, offset, count);\n        return Rect;\n    }\n\n    /**\n     * Creates a Rect struct.\n     */\n    constructor() {\n        super(new Float32Array(4));\n    }\n\n    /**\n     * The left boundary of this Rect.\n     */\n    get left() {\n        return this.data[0];\n    }\n\n    /**\n     * The left boundary of this Rect.\n     */\n    set left(value: number) {\n        this.data[0] = value;\n    }\n\n    /**\n     * The top boundary of this Rect.\n     */\n    get top() {\n        return this.data[1];\n    }\n\n    /**\n     * The top boundary of this Rect.\n     */\n    set top(value: number) {\n        this.data[1] = value;\n    }\n\n    /**\n     * The right boundary of this Rect.\n     */\n    get right() {\n        return this.data[2];\n    }\n\n    /**\n     * The right boundary of this Rect.\n     */\n    set right(value: number) {\n        this.data[2] = value;\n    }\n\n    /**\n     * The bottom boundary of this Rect.\n     */\n    get bottom() {\n        return this.data[3];\n    }\n\n    /**\n     * The bottom boundary of this Rect.\n     */\n    set bottom(value: number) {\n        this.data[3] = value;\n    }\n\n    /**\n     * Sets each component of this Rect to that of the other Rect.\n     */\n    set(other: Rect) {\n        return set(this, other);\n    }\n\n    /**\n     * Sets each component of this Rect.\n     */\n    set$(left: number, top: number, right: number, bottom: number) {\n        return set$(this, left, top, right, bottom);\n    }\n\n    /**\n     * Adds the other Rect to this Rect componentwise.\n     */\n    add(other: Rect) {\n        return add(this, other);\n    }\n\n    /**\n     * Adds the specified values to this Rect componentwise.\n     */\n    add$(left: number, top: number, right: number, bottom: number) {\n        return add$(this, left, top, right, bottom);\n    }\n\n    /**\n     * Subtracts the other Rect from this Rect componentwise.\n     */\n    subtract(other: Rect) {\n        return subtract(this, other);\n    }\n\n    /**\n     * Subtracts the specified values from this Rect componentwise.\n     */\n    subtract$(left: number, top: number, right: number, bottom: number) {\n        return subtract$(this, left, top, right, bottom);\n    }\n\n    /**\n     * Multiplies each component of this Rect by the specified scalar.\n     */\n    mulScalar(k: number) {\n        return mulScalar(this, k);\n    }\n\n    /**\n     * Divides each component of this Rect by the specified scalar.\n     */\n    divScalar(k: number) {\n        return divScalar(this, k);\n    }\n\n    /**\n     * Checks if each component of this Rect is equal to that of the other Rect.\n     */\n    equals(other: Rect) {\n        return equals(this, other);\n    }\n\n    /**\n     * Checks if each component of this Rect is equal to the specified scalar.\n     */\n    equalsScalar(k: number) {\n        return equalsScalar(this, k);\n    }\n\n    /**\n     * Checks if each component of this Rect is approximately equal to that of the other Rect.\n     */\n    epsilonEquals(other: Rect, e: number) {\n        return epsilonEquals(this, other, e);\n    }\n\n    /**\n     * Checks if each component of this Rect is approximately equal to the specified scalar.\n     */\n    epsilonEqualsScalar(k: number, e: number) {\n        return epsilonEqualsScalar(this, k, e);\n    }\n\n    /**\n     * Returns a string representation of this Rect.\n     */\n    toString() {\n        return toString(this);\n    }\n\n    /**\n     * Sets the boundaries of this Rect in left-top-right-bottom order.\n     */\n    setLtrb(left: number, top: number, right: number, bottom: number) {\n        return setLtrb(this, left, top, right, bottom);\n    }\n\n    /**\n     * Sets the boundaries of this Rect in left-bottom-right-top order.\n     */\n    setLbrt(left: number, bottom: number, right: number, top: number) {\n        return setLbrt(this, left, bottom, right, top);\n    }\n\n    /**\n     * Sets the boundaries of this Rect in left-right-bottom-top order.\n     */\n    setLrbt(left: number, right: number, bottom: number, top: number) {\n        return setLrbt(this, left, right, bottom, top);\n    }\n\n    /**\n     * Sets the dimensions of this rect in left-top-width-height order.\n     */\n    setLtwh(left: number, top: number, width: number, height: number) {\n        return setLtwh(this, left, top, width, height);\n    }\n\n    /**\n     * Sets the dimensions of this rect in left-bottom-width-height order.\n     */\n    setLbwh(left: number, bottom: number, width: number, height: number) {\n        return setLbwh(this, left, bottom, width, height);\n    }\n\n    /**\n     * Checks if this Rect is empty. True if left >= right or bottom >= top.\n     */\n    isEmpty() {\n        return isEmpty(this);\n    }\n\n    /**\n     * Checks if the boundaries of this Rect represent a valid rectangle. True if right >= left and top >= bottom.\n     */\n    isValid() {\n        return isValid(this);\n    }\n\n    /**\n     * Computes the width of this Rect.\n     */\n    width() {\n        return width(this);\n    }\n\n    /**\n     * Computes the height of this Rect.\n     */\n    height() {\n        return height(this);\n    }\n\n    /**\n     * Computes the area of this Rect.\n     */\n    area() {\n        return area(this);\n    }\n\n    /**\n     * Finds the x-coordinate of the point at the center of this Rect.\n     */\n    centerX() {\n        return centerX(this);\n    }\n\n    /**\n     * Finds the y-coordinate of the point at the center of this Rect.\n     */\n    centerY() {\n        return centerY(this);\n    }\n\n    /**\n     * Sets the specified point to the point at the center of this Rect\n     */\n    center(dst: Point._) {\n        return center(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point between the top left and top right corners of this Rect.\n     */\n    centerTop(dst: Point._) {\n        return centerTop(this, dst);\n    }\n\n    /**\n     *  Sets the specified point to the point between the bottom left and bottom right corners of this Rect.\n     */\n    centerBottom(dst: Point._) {\n        return centerBottom(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point between the top and bottom left corners of this Rect.\n     */\n    centerLeft(dst: Point._) {\n        return centerLeft(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point between the top and bottom right corners of this Rect.\n     */\n    centerRight(dst: Point._) {\n        return centerRight(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point at the bottom left corner of this Rect.\n     */\n    bottomLeft(dst: Point._) {\n        return bottomLeft(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point at the bottom right corner of this Rect.\n     */\n    bottomRight(dst: Point._) {\n        return bottomRight(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point at the top left corner of this Rect.\n     */\n    topLeft(dst: Point._) {\n        return topLeft(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point at the top right corner of this Rect.\n     */\n    topRight(dst: Point._) {\n        return topRight(this, dst);\n    }\n\n    /**\n     * Sets this Rect to the empty rect (0,0,0,0).\n     */\n    empty() {\n        return empty(this);\n    }\n\n    /**\n     * Sets this Rect to the smallest rectangle containing the two specified points.\n     */\n    setUnionOfPoints(points: Point._[], offset = 0, count = points.length) {\n        return setUnionOfPoints(this, points, offset, count);\n    }\n\n    /**\n     * Sets this Rect to the smallest rectangle containing a subset of points in the specified array.\n     * @param points array of points entered as a series of (x,y) coordinates.\n     * @param offset offset of the first point in the subset.\n     * @param count number of points in the subset.\n     */\n    setUnionOfPoints$(points: Float32Array, offset = 0, count = points.length >> 1) {\n        return setUnionOfPoints$(this, points, offset, count);\n    }\n\n    /**\n     * Checks if this Rect contains the other Rect.\n     */\n    contains(other: Rect) {\n        return contains(this, other);\n    }\n\n    /**\n     * Checks if this Rect contains the specified point.\n     */\n    containsPoint(p: Point._) {\n        return containsPoint(this, p);\n    }\n\n    /**\n     * Checks if this Rect contains the point (x,y).\n     */\n    containsPoint$(x: number, y: number) {\n        return containsPoint$(this, x, y);\n    }\n\n    /**\n     * Checks if this Rect intersects the other Rect.\n     */\n    intersects(other: Rect) {\n        return intersects(this, other);\n    }\n\n    /**\n     * Sets this Rect to the intersection of itself with the other Rect.\n     */\n    intersect(other: Rect) {\n        return intersect(this, other);\n    }\n\n    /**\n     * Expands this Rect to enclose the other Rect.\n     */\n    union(other: Rect) {\n        return union(this, other);\n    }\n\n    /**\n     * Expands this Rect to enclose the specified point.\n     */\n    unionPoint(p: Point._) {\n        return unionPoint(this, p);\n    }\n\n    /**\n     * Expands this Rect to enclose the point (x,y).\n     */\n    unionPoint$(x: number, y: number) {\n        return unionPoint$(this, x, y);\n    }\n\n    /**\n     * Expands this Rect to enclose the specified points\n     * @param points array of points.\n     * @param offset offset of the first point in the subset.\n     * @param count number of points in the subset.\n     */\n    unionPoints(points: Point._[], offset = 0, count = points.length) {\n        return unionPoints(this, points, offset, count);\n    }\n\n    /**\n     * Expands this Rect to enclose the specified points\n     * @param points array of points entered as a series of (x,y) coordinates.\n     * @param offset offset of the first point in the subset.\n     * @param count number of points in the subset.\n     */\n    unionPoints$(points: Float32Array, offset = 0, count = points.length >> 1) {\n        return unionPoints$(this, points, offset, count);\n    }\n\n    /**\n     * Insets the boundaries of this Rect by the vector (dx,dy).\n     */\n    inset(dx: number, dy: number) {\n        return inset(this, dx, dy);\n    }\n\n    /**\n     * Offsets the boundaries of this Rect by the vector (dx,dy).\n     */\n    offset(dx: number, dy: number) {\n        return offset(this, dx, dy);\n    }\n\n    /**\n     * Scales this Rect out from it's center by the specified (sx,sy) percentages.\n     * @param r the Rect to scale.\n     * @param sx the percentage by which to scale in the horizontal direction.\n     * @param sy the percentage by which to scale in the vertical direction.\n     */\n    scale(sx: number, sy: number) {\n        return scale(this, sx, sy);\n    }\n\n    /**\n     * Stretches this Rect out from it's center by the specified ratio, maintaining aspect.\n     * @param ratio the percentage by which to stretch in all directions.\n     */\n    stretch(ratio: number) {\n        return stretch(this, ratio);\n    }\n\n    /**\n     * Shrinks this Rect to a square with the same center point.\n     */\n    shrinkToSquare() {\n        return shrinkToSquare(this);\n    }\n\n    /**\n     * Expands this Rect to a square with the same center point.\n     */\n    expandToSquare() {\n        return expandToSquare(this);\n    }\n\n    /**\n     * Swaps the top/bottom or left/right boundaries of this Rect if they are flipped, meaning left > right and/or top > bottom.\n     */\n    sort() {\n        return sort(this);\n    }\n}\n\n/**\n * A Rect buffer backed by a Float32Array.\n */\nexport class Buf extends StructureBuffer<Float32Array> {\n    /**\n     * Creates an empty Rect buffer with the specified Rect capacity.\n     */\n    static create(capacity: number) {\n        return new Buf(new Float32Array(capacity * 4));\n    }\n\n    /**\n     * The left boundary of the current Rect.\n     */\n    get left() {\n        return this.data[this.dataPosition + 0];\n    }\n\n    /**\n     * The left boundary of the current Rect.\n     */\n    set left(value: number) {\n        this.data[this.dataPosition + 0] = value;\n    }\n\n    /**\n     * The top boundary of the current Rect.\n     */\n    get top() {\n        return this.data[this.dataPosition + 1];\n    }\n\n    /**\n     * The top boundary of the current Rect.\n     */\n    set top(value: number) {\n        this.data[this.dataPosition + 1] = value;\n    }\n\n    /**\n     * The right boundary of the current Rect.\n     */\n    get right() {\n        return this.data[this.dataPosition + 2];\n    }\n\n    /**\n     * The right boundary of the current Rect.\n     */\n    set right(value: number) {\n        this.data[this.dataPosition + 2] = value;\n    }\n\n    /**\n     * The bottom boundary of the current Rect.\n     */\n    get bottom() {\n        return this.data[this.dataPosition + 3];\n    }\n\n    /**\n     * The bottom boundary of the current Rect.\n     */\n    set bottom(value: number) {\n        this.data[this.dataPosition + 3] = value;\n    }\n\n    /**\n     * Gets the number of components in a Rect, namely 4.\n     */\n    structLength() {\n        return 4;\n    }\n\n    /**\n     * Sets each component of the Rect at the specified position.\n     */\n    set$(position: number, left: number, top: number, right: number, bottom: number) {\n        let dataPos = position * this.structLength();\n        this.data[dataPos++] = left;\n        this.data[dataPos++] = top;\n        this.data[dataPos++] = right;\n        this.data[dataPos++] = bottom;\n    }\n\n    /**\n     * Sets each component of the current Rect, then moves to the next position of this buffer.\n     */\n    put$(left: number, top: number, right: number, bottom: number) {\n        this.data[this.dataPosition++] = left;\n        this.data[this.dataPosition++] = top;\n        this.data[this.dataPosition++] = right;\n        this.data[this.dataPosition++] = bottom;\n    }\n\n    /**\n     * Sets each component of the current Rect to that of the other Rect.\n     */\n    $set(other: Rect) {\n        return set(this, other);\n    }\n\n    /**\n     * Sets each component of the current Rect.\n     */\n    $set$(left: number, top: number, right: number, bottom: number) {\n        return set$(this, left, top, right, bottom);\n    }\n\n    /**\n     * Adds the other Rect to the current Rect componentwise.\n     */\n    $add(other: Rect) {\n        return add(this, other);\n    }\n\n    /**\n     * Adds the specified values to the current Rect componentwise.\n     */\n    $add$(left: number, top: number, right: number, bottom: number) {\n        return add$(this, left, top, right, bottom);\n    }\n\n    /**\n     * Subtracts the other Rect from the current Rect componentwise.\n     */\n    $subtract(other: Rect) {\n        return subtract(this, other);\n    }\n\n    /**\n     * Subtracts the specified values from the current Rect componentwise.\n     */\n    $subtract$(left: number, top: number, right: number, bottom: number) {\n        return subtract$(this, left, top, right, bottom);\n    }\n\n    /**\n     * Multiplies each component of the current Rect by the specified scalar.\n     */\n    $mulScalar(k: number) {\n        return mulScalar(this, k);\n    }\n\n    /**\n     * Divides each component of the current Rect by the specified scalar.\n     */\n    $divScalar(k: number) {\n        return divScalar(this, k);\n    }\n\n    /**\n     * Checks if each component of the current Rect is equal to that of the other Rect.\n     */\n    $equals(other: Rect) {\n        return equals(this, other);\n    }\n\n    /**\n     * Checks if each component of the current Rect is equal to the specified scalar.\n     */\n    $equalsScalar(k: number) {\n        return equalsScalar(this, k);\n    }\n\n    /**\n     * Checks if each component of the current Rect is approximately equal to that of the other Rect.\n     */\n    $epsilonEquals(other: Rect, e: number) {\n        return epsilonEquals(this, other, e);\n    }\n\n    /**\n     * Checks if each component of the current Rect is approximately equal to the specified scalar.\n     */\n    $epsilonEqualsScalar(k: number, e: number) {\n        return epsilonEqualsScalar(this, k, e);\n    }\n\n    /**\n     * Returns a string representation of the current Rect.\n     */\n    $toString() {\n        return toString(this);\n    }\n\n    /**\n     * Sets the boundaries of the current Rect in left-top-right-bottom order.\n     */\n    $setLtrb(left: number, top: number, right: number, bottom: number) {\n        return setLtrb(this, left, top, right, bottom);\n    }\n\n    /**\n     * Sets the boundaries of the current Rect in left-bottom-right-top order.\n     */\n    $setLbrt(left: number, bottom: number, right: number, top: number) {\n        return setLbrt(this, left, bottom, right, top);\n    }\n\n    /**\n     * Sets the boundaries of the current Rect in left-right-bottom-top order.\n     */\n    $setLrbt(left: number, right: number, bottom: number, top: number) {\n        return setLrbt(this, left, right, bottom, top);\n    }\n\n    /**\n     * Sets the dimensions of this rect in left-top-width-height order.\n     */\n    $setLtwh(left: number, top: number, width: number, height: number) {\n        return setLtwh(this, left, top, width, height);\n    }\n\n    /**\n     * Sets the dimensions of this rect in left-bottom-width-height order.\n     */\n    $setLbwh(left: number, bottom: number, width: number, height: number) {\n        return setLbwh(this, left, bottom, width, height);\n    }\n\n    /**\n     * Checks if the current Rect is empty. True if left >= right or bottom >= top.\n     */\n    $isEmpty() {\n        return isEmpty(this);\n    }\n\n    /**\n     * Checks if the boundaries of the current Rect represent a valid rectangle. True if right >= left and top >= bottom.\n     */\n    $isValid() {\n        return isValid(this);\n    }\n\n    /**\n     * Computes the width of the current Rect.\n     */\n    $width() {\n        return width(this);\n    }\n\n    /**\n     * Computes the height of the current Rect.\n     */\n    $height() {\n        return height(this);\n    }\n\n    /**\n     * Computes the area of the current Rect.\n     */\n    $area() {\n        return area(this);\n    }\n\n    /**\n     * Finds the x-coordinate of the point at the center of the current Rect.\n     */\n    $centerX() {\n        return centerX(this);\n    }\n\n    /**\n     * Finds the y-coordinate of the point at the center of the current Rect.\n     */\n    $centerY() {\n        return centerY(this);\n    }\n\n    /**\n     * Sets the specified point to the point at the center of the current Rect\n     */\n    $center(dst: Point._) {\n        return center(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point between the top left and top right corners of the current Rect.\n     */\n    $centerTop(dst: Point._) {\n        return centerTop(this, dst);\n    }\n\n    /**\n     *  Sets the specified point to the point between the bottom left and bottom right corners of the current Rect.\n     */\n    $centerBottom(dst: Point._) {\n        return centerBottom(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point between the top and bottom left corners of the current Rect.\n     */\n    $centerLeft(dst: Point._) {\n        return centerLeft(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point between the top and bottom right corners of the current Rect.\n     */\n    $centerRight(dst: Point._) {\n        return centerRight(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point at the bottom left corner of the current Rect.\n     */\n    $bottomLeft(dst: Point._) {\n        return bottomLeft(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point at the bottom right corner of the current Rect.\n     */\n    $bottomRight(dst: Point._) {\n        return bottomRight(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point at the top left corner of the current Rect.\n     */\n    $topLeft(dst: Point._) {\n        return topLeft(this, dst);\n    }\n\n    /**\n     * Sets the specified point to the point at the top right corner of the current Rect.\n     */\n    $topRight(dst: Point._) {\n        return topRight(this, dst);\n    }\n\n    /**\n     * Sets the current Rect to the empty rect (0,0,0,0).\n     */\n    $empty() {\n        return empty(this);\n    }\n\n    /**\n     * Sets the current Rect to the smallest rectangle containing the two specified points.\n     */\n    $setUnionOfPoints(points: Point._[], offset: number, count: number) {\n        return setUnionOfPoints(this, points, offset, count);\n    }\n\n    /**\n     * Sets the current Rect to the smallest rectangle containing a subset of points in the specified array.\n     * @param points array of points entered as a series of (x,y) coordinates.\n     * @param offset offset of the first point in the subset.\n     * @param count number of points in the subset.\n     */\n    $setUnionOfPoints$(points: Float32Array, offset: number, count: number) {\n        return setUnionOfPoints$(this, points, offset, count);\n    }\n\n    /**\n     * Checks if the current Rect contains the other Rect.\n     */\n    $contains(other: Rect) {\n        return contains(this, other);\n    }\n\n    /**\n     * Checks if the current Rect contains the specified point.\n     */\n    $containsPoint(p: Point._) {\n        return containsPoint(this, p);\n    }\n\n    /**\n     * Checks if the current Rect contains the point (x,y).\n     */\n    $containsPoint$(x: number, y: number) {\n        return containsPoint$(this, x, y);\n    }\n\n    /**\n     * Checks if the current Rect intersects the other Rect.\n     */\n    $intersects(other: Rect) {\n        return intersects(this, other);\n    }\n\n    /**\n     * Sets the current Rect to the intersection of itself with the other Rect.\n     */\n    $intersect(other: Rect) {\n        return intersect(this, other);\n    }\n\n    /**\n     * Expands the current Rect to enclose the other Rect.\n     */\n    $union(other: Rect) {\n        return union(this, other);\n    }\n\n    /**\n     * Expands the current Rect to enclose the specified point.\n     */\n    $unionPoint(p: Point._) {\n        return unionPoint(this, p);\n    }\n\n    /**\n     * Expands the current Rect to enclose the point (x,y).\n     */\n    $unionPoint$(x: number, y: number) {\n        return unionPoint$(this, x, y);\n    }\n\n    /**\n     * Expands the current Rect to enclose the specified points\n     * @param points array of points.\n     * @param offset offset of the first point in the subset.\n     * @param count number of points in the subset.\n     */\n    $unionPoints(points: Point._[], offset: number, count: number) {\n        return unionPoints(this, points, offset, count);\n    }\n\n    /**\n     * Expands the current Rect to enclose the specified points\n     * @param points array of points entered as a series of (x,y) coordinates.\n     * @param offset offset of the first point in the subset.\n     * @param count number of points in the subset.\n     */\n    $unionPoints$(points: Float32Array, offset: number, count: number) {\n        return unionPoints$(this, points, offset, count);\n    }\n\n    /**\n     * Insets the boundaries of the current Rect by the vector (dx,dy).\n     */\n    $inset(dx: number, dy: number) {\n        return inset(this, dx, dy);\n    }\n\n    /**\n     * Offsets the boundaries of the current Rect by the vector (dx,dy).\n     */\n    $offset(dx: number, dy: number) {\n        return offset(this, dx, dy);\n    }\n\n    /**\n     * Scales the current Rect out from it's center by the specified (sx,sy) percentages.\n     * @param r the Rect to scale.\n     * @param sx the percentage by which to scale in the horizontal direction.\n     * @param sy the percentage by which to scale in the vertical direction.\n     */\n    $scale(sx: number, sy: number) {\n        return scale(this, sx, sy);\n    }\n\n    /**\n     * Stretches the current Rect out from it's center by the specified ratio, maintaining aspect.\n     * @param ratio the percentage by which to stretch in all directions.\n     */\n    $stretch(ratio: number) {\n        return stretch(this, ratio);\n    }\n\n    /**\n     * Shrinks the current Rect to a square with the same center point.\n     */\n    $shrinkToSquare() {\n        return shrinkToSquare(this);\n    }\n\n    /**\n     * Expands the current Rect to a square with the same center point.\n     */\n    $expandToSquare() {\n        return expandToSquare(this);\n    }\n\n    /**\n     * Swaps the top/bottom or left/right boundaries of the current Rect if they are flipped, meaning left > right and/or top > bottom.\n     */\n    $sort() {\n        return sort(this);\n    }\n}\n","import Structure from './struct'\nimport TypedArray from './typedarray'\n\n/**\n * Helper class for iterating through a list of Structs backed by a primitive array.\n */\nabstract class StructureBuffer<T extends TypedArray> {\n    \n    /**\n     * The primitive array data backing the Structs in this buffer.\n     */\n    public data: T;\n\n    /**\n     * The position of the current Struct in the backing array.\n     */\n    protected dataPosition: number;\n\n    /**\n     * Gets the current position of this buffer.\n     */\n    position() {\n        return (this.dataPosition / this.structLength()) >> 0;\n    }\n\n    /**\n     * Gets the maximum number of Structs this buffer can hold.\n     */\n    capacity() {\n        return (this.data.length / this.structLength()) >> 0;\n    }\n\n    /**\n     * Gets the number of components contained in each Struct of this buffer.\n     */\n    abstract structLength(): number;\n\n    /**\n     * Creates a buffer backed by the specified array data\n     * @param data the backing array.\n     * @param position the initial position of the buffer. Defaults to zero.\n     */\n    constructor(data: T, position = 0) {\n        this.data = data;\n        this.dataPosition = position * this.structLength();\n    }\n\n    /**\n     * Checks if the current position of this buffer is valid.\n     */\n    hasValidPosition() {\n        return 0 <= this.dataPosition && this.dataPosition < this.data.length;\n    }\n\n    /**\n     * Moves this buffer to the specified position.\n     * @returns true if an Struct exists at this position.\n     */\n    moveToPosition(position: number) {\n        this.dataPosition = position * this.structLength();\n        return this.hasValidPosition();\n    }\n\n    /**\n     * Moves to the first Struct in this buffer.\n     * @returns true if an Struct exists at this position.\n     */\n    moveToFirst() {\n        this.dataPosition = 0;\n        return this.dataPosition < this.data.length;\n    }\n\n    /**\n     * Moves to the next Struct in this buffer.\n     * @returns true if an Struct exists at this position.\n     */\n    moveToNext() {\n        this.dataPosition += this.structLength();\n        return this.hasValidPosition();\n    }\n\n    /**\n     * Moves to the previous Struct in this buffer.\n     * @returns true if an Struct exists at this position.\n     */\n    moveToPrevous() {\n        this.dataPosition -= this.structLength();\n        return this.hasValidPosition();\n    }\n\n    /**\n     * Moves to the last Struct in this buffer.\n     * @returns true if an Struct exists at this position.\n     */\n    moveToLast() {\n        if (this.data.length) {\n            // buffer has at least one Struct\n            this.dataPosition = this.data.length - this.structLength();\n            return true;\n        } else {\n            // buffer is empty\n            this.dataPosition = 0;\n            return false;\n        }\n    }\n\n    /**\n     * Copies data from the source buffer into this buffer beginning at the specified position.\n     * @param position the offset into this buffer where the data should be copied.\n     * @param src buffer pointing to the other Struct.\n     * @param length the number of Structs to copy from the src array.\n     */\n    setBuffer(position: number, src: this, length: number) {\n        let srcPos = src.dataPosition;\n        let dstPos = position * this.structLength();\n        while (length--) {\n            let structLength = this.structLength();\n            while (structLength--) {\n                this.data[dstPos++] = src.data[srcPos++];\n            }\n        }\n    }\n\n    /**\n     * Sets each component of the Struct at the specified position to that of the src Struct.\n     * @param position the offset into this buffer where the Struct should be copied.\n     * @param src buffer pointing to the other Struct.\n     */\n    set(position: number, src: Structure<T>) {\n        let len = this.structLength();\n        let srcPos = 0;\n        let dstPos = position * len;\n        while (len--) {\n            this.data[dstPos++] = src.data[srcPos++];\n        }\n    }\n\n    /**\n     * Sets each Struct of this buffer to the specified Struct.\n     * @param src buffer pointing to the Struct.\n     */\n    setEach(src: Structure<T>) {\n        let dstPos = 0;\n        let dstLen = this.data.length;\n        while (dstLen--) {\n            let srcPos = 0;\n            let srcLen = this.structLength();\n            while(srcLen--) {\n                this.data[dstPos++] = src.data[srcPos++];\n            }\n        }\n    }\n\n    /**\n     * Sets the current Struct to the src Struct, then moves to the next position of this buffer.\n     * @param src buffer pointing to the other Struct.\n     */\n    put(src: Structure<T>) {\n        let len = this.structLength();\n        let srcPos = 0;\n        while (len--) {\n            this.data[this.dataPosition++] = src.data[srcPos++];\n        }\n    }\n\n    /**\n     * Copies data from the source buffer into this buffer at its current position, increasing the position of both buffers.\n     * @param src the buffer to copy into this buffer.\n     * @param length the number of Structs to copy from the src buffer.\n     */\n    putBuffer(src: this, length = src.capacity() - src.position()) {\n        while (length--) {\n            let structLength = this.structLength();\n            while (structLength--) {\n                this.data[this.dataPosition++] = src.data[src.dataPosition++];\n            }\n        }\n    }\n\n    /**\n     * Checks if this buffer is exactly equal in every component to the other buffer.\n     * @param other the other buffer.\n     */\n    equals(other: this) {\n        // Check length\n        if (this.data.length !== other.data.length) return false;\n        // Check each component\n        for (let i = 0; i < this.data.length; i++) {\n            if (this.data[i] !== other.data[i]) {\n                return false; // Not all equal\n            }\n        }\n        // All equal\n        return true;\n    }\n\n    /**\n     * Checks if every component of this buffer is equal to the specified scalar.\n     * @param k the scalar.\n     */\n    equalsScalar(k: number) {\n        // Check each component\n        for (let i = 0; i < this.data.length; i++) {\n            if (this.data[i] !== k) {\n                return false; // Not all equal\n            }\n        }\n        // All equal\n        return true;\n    }\n\n    /**\n     * Checks if this buffer is approximately equal in every component to the other buffer.\n     * @param other the other buffer.\n     * @param epsilon the maximum difference allowable between each component.\n     */\n    epsilonEquals(other: this, epsilon: number) {\n        // Check length\n        if (this.data.length !== other.data.length) return false;\n        // Check each component\n        for (let i = 0; i < this.data.length; i++) {\n            if (Math.abs(this.data[i] - other.data[i]) > epsilon) {\n                return false; // Not all equal\n            }\n        }\n        // All equal\n        return true;\n    }\n\n    /**\n     * Checks if every component of this buffer is approximately equal to the specified scalar.\n     * @param k the scalar.\n     * @param epsilon the maximum difference allowable between each component.\n     */\n    epsilonEqualsScalar(other: this, k: number, epsilon: number) {\n        // Check each component\n        for (let i = 0; i < this.data.length; i++) {\n            if (Math.abs(this.data[i] - k) > epsilon) {\n                return false; // Not all equal\n            }\n        }\n        // All equal\n        return true;\n    }\n\n}\n\nexport default StructureBuffer;\n","import TypedArray from './typedarray'\n\n/**\n * Struct backed by a TypedArray.\n */\nexport default class Structure<T extends TypedArray> {\n    \n    /**\n     * The TypedArray backing this item.\n     */\n    public data: T;\n\n    /**\n     * Creates a struct backed by a TypedArray.\n     * @param data the backing array.\n     */\n    constructor(data: T) {\n        this.data = data;\n    }\n\n}\n"," /** Cubic coordinate (q,r,s), where q+r+s = 0. */\nexport class Cube {\n\n    /** Counts the number of cubes that must be traversed in order to go from c1 to c2. */\n    static distance(c1: Cube, c2: Cube) {\n        return Math.max(\n            Math.abs(c1.q - c2.q),\n            Math.abs(c1.r - c2.r),\n            Math.abs(c1.s - c2.s)\n        );\n    }\n\n    static create(q = 0, r = 0, out = new Cube) {\n        out.q = q;\n        out.r = r;\n        out.s = -q - r;\n        return out;\n    }\n\n    constructor(\n        /** This cube's position on the Q axis. */\n        public q = 0, \n        /** This cube's position on the R axis. */\n        public r = 0, \n        /** This cube's position on the S axis. */\n        public s = -q - r\n    ) {}\n\n    /**\n     * Gets a cube adjacent to this one, in the specified direction. \n     * @param direction index of the direction in the `Directions` array.\n     */\n    getNeighbor(direction: number, dst = new Cube) {\n        return this.add(Directions[direction], dst);\n    }\n\n    /**\n     * Finds the direction to a neighboring cube.\n     * @param neighbor a cube neighboring this cube.\n     * @returns the index of the direction in the `Directions` array, or -1 if the cube is not a neighbor.\n     */\n    getDirection(neighbor: Cube) {\n        let diff = neighbor.subtract(this, new Cube);\n        for (let i = 0; i < Directions.length; i++) {\n            if (Directions[i].equals(diff)) {\n                return i;\n            }\n        }\n        return -1; // Not a neighbor\n    }\n\n    /** Adds 2 cubes together componentwise. */\n    add(c: Cube, dst = <Cube> this) {\n        dst.q = this.q + c.q;\n        dst.r = this.r + c.r;\n        dst.s = this.s + c.s;\n        return dst;\n    }\n\n    /** Subtracts c2 from c1 componentwise. */\n    subtract(c: Cube, dst = <Cube> this) {\n        dst.q = this.q - c.q;\n        dst.r = this.r - c.r;\n        dst.s = this.s - c.s;\n        return dst;\n    }\n\n    /** Multiplies each component of this cube by k. */\n    scale(k: number, dst = <Cube> this) {\n        dst.q = this.q * k;\n        dst.r = this.r * k;\n        dst.s = this.s * k;\n        return dst;\n    }\n\n    /** Rounds the coordinates of this cube to integer values such that q+r+s = 0 */\n    round(dst = <Cube> this) {\n        // Copy the unrounded coordinates\n        let cq = this.q,\n            cr = this.r,\n            cs = this.s;\n\n        // Perform the rounding \n        dst.q = Math.round(cq);\n        dst.r = Math.round(cr);\n        dst.s = Math.round(cs);\n\n        // Compare rounded to unrounded\n        let q_diff = Math.abs(dst.q - cq),\n            r_diff = Math.abs(dst.r - cr),\n            s_diff = Math.abs(dst.s - cs);\n\n        // Adjust accordingly\n        if (q_diff > r_diff && q_diff > s_diff)\n            dst.q = -dst.r - dst.s;\n        else if (r_diff > s_diff)\n            dst.r = -dst.q - dst.s;\n        else\n            dst.s = -dst.q - dst.r;\n\n        return dst;\n    }\n\n    /** Checks if this cube has exactly the same coordinates as the other cube */\n    equals(c: Cube) {\n        return this.q === c.q && this.r === c.r && this.s === c.s;\n    }\n};\n\n/**\n * The six possible directions on a hexagonal grid, entered in CCW order.\n */\nexport const Directions = [\n    new Cube(1, -1, 0), new Cube(1, 0, -1),\n    new Cube(0, 1, -1), new Cube(-1, 1, 0),\n    new Cube(-1, 0, 1), new Cube(0, -1, 1)\n];\n\n","import { Cube, Directions } from './cube';\nimport { BinaryImage, createBitArray } from '../graphics/bit'      \nimport { Shape } from '../graphics/shape'\nimport { Ellipse } from '../graphics/ellipse'\nimport { Color, ColorBuffer, LineSegment, Point, Rect, Vec2Buffer } from '@wjheesen/glib';\n\n\n/**\n * The width of a pointy top hexel in model space.\n */\nexport const H_WIDTH = Math.sqrt(3);\n\n/**\n * The height of a pointy top hexel in model space.\n */\nexport const H_HEIGHT = 2;\n\n/**\n * The distance from the bottom left corner of a pointy top hexel the nearest vertex on the right.\n */\nexport const H_RIGHT = H_WIDTH / 2;\n\n/**\n * The distance from the bottom left corner of a pointy top hexel to the nearest vertex above.\n */\nexport const H_UP = H_HEIGHT / 4;\n\n/** A rectangular hexagon grid */\nexport class HexelGrid {\n\n    /** How many rows this grid has. */\n    public rows: number;\n\n    /** How many columns this grad has. */\n    public cols: number;\n\n    /** The boundaries of this grid in world space. */\n    public readonly bounds: Rect;\n\n    /** The color of each of the hexagons on this grid, beginning at the first row and first column. */\n    public hexels: ColorBuffer<Uint8ClampedArray>;\n\n    /** True if this grid has color changes that have not yet been applied */\n    public hasHexelChanges = true;\n\n    /** True if this grid has layout changes that have not yet been applied */\n    public hasLayoutChanges = true;\n\n    /** Whether or not this grid has a gradient. */\n    public hasGradient = true;\n\n    /**\n     * Creates a new hexagon grid with specified number of rows and columns.\n     * @param cols how many columns the grid should have.\n     * @param rows how many rows the grid should have.\n     * @param hexels the color of each of the hexagons.\n     */\n    constructor(cols: number, rows: number, hexels = new ColorBuffer(new Uint8ClampedArray(4*cols*rows))) {\n        this.cols = cols;\n        this.rows = rows;\n        this.hexels = hexels;\n        // Compute bounds, with first hexel centered at (0, height)\n        let width = H_WIDTH * (cols + 0.5);\n        let height = H_HEIGHT * (rows * 0.75 + 0.25);\n        let left = -H_WIDTH / 2;         // Left side of first hexel\n        let top = height + H_HEIGHT / 2; // Top of first hexel\n        this.bounds = Rect.dimensions(left, top, width, height);\n    }\n\n    /**\n     * Gets the cubic coordinate of the specified hexel.\n     * @param index the index of the hexel on this grid, where 0 <= index < this.size.\n     */\n    cubeAtIndex(index: number, out = new Cube) {\n        // Ex: index = 14 on 8x4 grid\n        let r = (index / this.cols) >> 0;       // 14/8 = 1\n        let q = (index % this.cols) - (r >> 1); // 14%8 - 1/2 = 5\n        return Cube.create(q, r, out);\n    }\n\n    /**\n     * Gets the point at the center of the specified hexel.\n     * @param index the index of the hexel on this grid.\n     */\n    pointAtIndex(index: number, pout = <Point.Like> {}, cout = new Cube) {\n        return this.pointAtCube(this.cubeAtIndex(index, cout), pout);\n    }\n\n    /**\n     * Finds the index of the hexel containing the specified point, or -1 if none found.\n     * @param p a point in this grid's model space.\n     */\n    indexAtPoint(p: Point.Like) {\n        // Convert point to fractal cubic coordinates\n        let cube = this.cubeAtPoint(p).round();\n        // Search for the index of the corresponding hexel\n        return this.indexAtCube(cube);\n    }\n\n    /**\n     * Finds the index of a cubic coordinate on this grid, or -1 if this grid does not contain the coordinate.\n     * @param c the cubic coordinates to search for.\n     */\n    indexAtCube(c: Cube) {\n        // If the row is inside this grid\n        if (0 <= c.r && c.r < this.rows) {\n            // Compute the row offset\n            let r_offset = c.r >> 1; // or Math.floor(r/2)\n            // If the column is inside this grid\n            if (-r_offset <= c.q && c.q < this.cols - r_offset) {\n                // Compute the index\n                return this.cols * c.r + c.q + r_offset;\n            }\n        }\n        // Not on grid\n        return -1;\n    }\n\n    /**\n     * Converts a hex to a point in this grid's model space.\n     * @param h the cubic position of a hexagon on the grid.\n     */\n    pointAtCube(h: Cube, out = <Point.Like> {}) {\n        // Map to grid space\n        out.x = H_WIDTH *  (h.q + h.r / 2); \n        out.y = H_HEIGHT * (h.r * 0.75);\n        // Map to world space by flipping Y axis\n        out.y = this.bounds.height - out.y; \n        return out;\n    }\n\n    /**\n      * Converts a point in world space to a cubic coordinate in grid space. \n      * @param p a point in world space.\n      */\n    cubeAtPoint(p: Point.Like, out = new Cube) {\n        // Map to grid space\n        let x = p.x;\n        let y = this.bounds.height - p.y; \n        // Map to cubic space\n        let q = (H_WIDTH * x - y) / 3;\n        let r = (H_HEIGHT * y) / 3;\n        // Return unrounded cube\n        return Cube.create(q, r, out);\n    }\n\n    hexelAtPoint(p: Point.Like): Color.Like | null {\n        let cube = this.cubeAtPoint(p).round();\n        let index = this.indexAtCube(cube);\n        return index === -1 ? null : this.hexels.at(index);\n    }\n\n    /*** Gets the point at the center of each hexel on this grid. */\n    points() { \n        let cube = new Cube;\n        let points = Vec2Buffer.withLength(this.hexels.length);\n        for (let i = 0; i < this.hexels.length; i++) {\n            this.pointAtIndex(i, points.at(i), cube);\n        }\n        return points;\n    }\n\n    /**\n     * Invokes the callback function on the cubic coordinate of each of the hexels on this grid.\n     * @param callback the callback function. \n     */\n    forEachCubicCoordinate(callback: (c: Cube) => void) {\n        for (let r = 0; r < this.rows; r++) {\n            let r_offset = r >> 1; // or Math.floor(r/2)\n            for (let q = -r_offset; q < this.cols - r_offset; q++) {\n                callback(new Cube(q, r));\n            }\n        }\n    }\n\n    /**\n     * Invokes the callback function on the offset coordinate of each of the hexels on this grid.\n     * @param callback the callback function. \n     */\n    forEachOffsetCoordinate(callback: (c: Point.Like) => void) {\n        // TODO: try reusing Float32Array?\n        for (let y = 0; y < this.rows; y++) {\n            for (let x = 0; x < this.cols; x++) {\n                callback({x: x, y: y});\n            }\n        }\n    }\n\n    /**\n     * Sets each of the hexels in this grid to the specified clear color.\n     * @param color the clear color.\n     */\n    clear(color: Color.Like) {\n        for (let i = 0; i < this.hexels.length; i++) {\n            Color.copy(color, this.hexels.at(i));\n        }\n    }\n\n    /**\n     * Maps data from a binary image onto this grid.\n     * @param img the image to map onto this grid.\n     */\n    addBinaryImage(img: BinaryImage) {\n        // if (img.color.isOpaque()) {\n        //     img.forEachSetBit(this.cols, (index) => {\n        //         if (this.hexels.moveToPosition(index)) {\n        //             this.hexels.$set(img.color);\n        //         }\n        //     })\n        // } else {\n        //     img.forEachSetBit(this.cols, (index) => {\n        //         if (this.hexels.moveToPosition(index)) {\n        //             this.hexels.$blend(img.color);\n        //         }\n        //     })\n        // }\n    }\n\n    /**\n     * Sets the color of each of the hexels in the specified line.\n     * @param line containing the hexels to set.\n     * @param thickness the thickness of the line in world space.\n     * @param color the color to use.\n     * @returns a record of every hexel that was changed.\n     */\n    addLine(line: LineSegment, thickness: number, color: Color.Like, record = this.bitArray()) {\n        // let radius = thickness * 0.5;\n\n        // this.forEachCenterVertex((x, y, i) => {\n        //     if (Line.contains$(line, x, y, radius) && this.hexels.moveToPosition(i)) {\n        //         this.hexels.$blend(color);\n        //         record.set(i);\n        //     }\n        // });\n\n        // return record;\n    }\n\n    /**\n     * Sets the color of each of the hexels in the specified ellipse\n     * @param ellipse the ellipse containing the hexels to set.\n     * @param color the color to use.\n     * @returns a record of every hexel that was changed.\n     */\n    addEllipse(ellipse: Ellipse, color: Color.Like, record = this.bitArray()) {\n\n        // this.forEachCenterVertex((x, y, i) => {\n        //     if (ellipse.contains$(x, y) && this.hexels.moveToPosition(i)) {\n        //         this.hexels.$blend(color);\n        //         record.set(i);\n        //     }\n        // });\n\n        // return record;\n    }\n\n    /**\n     * Sets the color of each of the hexels in the specified shape.\n     * @param shape the shape containing the hexels to set.\n     * @param color the color to use.\n     * @returns a record of every hexel that was changed.\n     */\n    addShape(shape: Shape, color: Color.Like, record = this.bitArray()) {\n\n        // this.forEachCenterVertex((x, y, i) => {\n        //     if (shape.contains$(x, y) && this.hexels.moveToPosition(i)) {\n        //         this.hexels.$blend(color);\n        //         record.set(i); \n        //     }\n        // });\n\n        // return record;\n    }\n\n    /**\n     * Invokes the specified callback function on each of the hexels within a specified range.\n     * @param center the cubic coordinate of the hexel at the center of the range\n     * @param radius the radius of the range out from the center.\n     * @param callback the callback to invoke with the index of each hexel.\n     */\n    forEachHexelInRange(center: Cube, radius: number, callback: (hexel: Color.Like) => void) {\n        let cube = new Cube();\n        // Moving from left to right\n        for (let q = -radius; q <= radius; q++) {\n            let lower = Math.max(-radius, -q - radius);\n            let upper = Math.min(radius, -q + radius);\n            cube.q = center.q + q;\n            // And from bottom to top\n            for (let r = lower; r <= upper; r++) {\n                cube.r = center.r + r;\n                // If grid contains hexel at this coordinate\n                let index = this.indexAtCube(cube);\n                if (index !== -1) {\n                    // Invoke callback on hexel index\n                    callback(this.hexels.at(index));\n                }\n            }\n        }\n    }\n\n    /**\n     * Invokes the specified callback function on each of the hexels within a specified ring.\n     * @param center the cubic coordinate of the hexel at the center of the range\n     * @param radius the distance of the ring from the center.\n     * @param callback the callback to invoke with the index of each hexel.\n     */\n    forEachHexelInRing(center: Cube, radius: number, callback: (index: number) => void) {\n\n        if (radius === 0) {\n            // Check center\n            let index = this.indexAtCube(center);\n            if (index !== -1) {\n                callback(index);\n            }\n        } else {\n            // Move to first cube on outer ring:\n            // cube = center + radius * direction \n            let cube = new Cube();\n            cube.add(Directions[4]);\n            cube.scale(radius)\n            cube.add(center);\n            // for each 0  i < 6: (CCW)\n            for (let i = 0; i < 6; i++) {\n                for (let j = 0; j < radius; j++) {\n                    // Check cube\n                    let index = this.indexAtCube(cube);\n                    if (index !== -1) {\n                        callback(index);\n                    }\n                    // Set cube to neighbor \n                    cube.getNeighbor(i, cube)\n                }\n            }\n        }\n    }\n\n    /**\n     * Invokes the callback function on each of the cubic coordinates of the specified line.\n     * @param start rounded cubic point where line begins.\n     * @param end rounded cubic point where line ends.\n     * @param callback the callback function.\n     */\n    forEachCubeInLine(start: Cube, end: Cube, callback: (c: Cube) => void) {\n        // Paramaterize line to start + bt, 0<=t<=1\n        let b = end.subtract(start, new Cube);\n        // Compute length of line (in terms of cubes traversed)\n        let length = Cube.distance(b, new Cube);\n        // Determine the length of each step\n        let step = 1.0 / Math.max(length, 1);\n        // Get cube at each step of line\n        for (let i = 0; i <= length; i++) {\n            let t = step * i;\n            let c = new Cube();\n            c.q = start.q + b.q * t;\n            c.r = start.r + b.r * t;\n            c.s = start.s + b.s * t;\n            callback(c.round());\n        }\n    }\n\n    /**\n     * Applies a scanline flood fill algorithm to this grid, beginning with the hexel at the specified index.\n     * @param index index of where to begin flood fill.\n     * @param color the flood fill color.\n     * @param record where to keep a record of changes.\n     * @returns a record of every hexel that was changed.\n     */\n    floodFill(index: number, color: Color.Like, record = this.bitArray()) {\n        // if (this.hexels.moveToPosition(index)) {\n        //     // Blend the color with the background hexel color\n        //     let background = this.hexels;\n        //     let blendedColor = new Color.Obj();\n        //     blendedColor.set(background);\n        //     blendedColor.blend(color);\n        //     // If the two colors are not already equal\n        //     if (!blendedColor.equals(background)) {\n        //         // Begin floodfill scanline algorithm\n        //         return this.floodFillScanLine(index, blendedColor.toRgbaInt(), background.$toRgbaInt(), record);\n        //     } \n        // }\n\n        // return record;\n    }\n\n    /**\n     * Non-recursive floodfill scanline algorithm.\n     * @param index index of where to begin flood fill.\n     * @param newColor flood fill color of the form 0xrrggbbaa.\n     * @param oldColor pre flood fill color of the form 0xrrggbbaa.\n     * @param record where to keep a record of changes.\n     * @returns a record of every hexel that was changed.\n     */\n    private floodFillScanLine(index: number, newColor: number, oldColor: number, record = this.bitArray()) {\n\n        // // Init variables\n        // let row: number,\n        //     rowAbove: number,\n        //     rowBelow: number,\n        //     spanAbove: boolean,\n        //     spanBelow: boolean,\n        //     w = this.cols,\n        //     h = this.rows,\n        //     colors = this.hexels.data,\n        //     stack: Point.Like[] = [],\n        //     seed = this.offsetAt(index),\n        //     x: number, y: number;\n\n        // // Add initial seed to stack\n        // stack.push(seed);\n\n        // // As long as the stack is not empty\n        // while (stack.length > 0) {  \n        //     // Get the next seed from stack\n        //     seed = stack.pop();\n        //     // Update variables to match seed\n        //     x = seed.x;\n        //     y = seed.y;\n        //     row = y * w;\n        //     rowAbove = row - w;\n        //     rowBelow = row + w;\n        //     spanAbove = false;\n        //     spanBelow = false;\n        //     // Go as far left as possible\n        //     while (x >= 0 && getRgba(colors, x + row) === oldColor) x--;\n        //     // HEXEL EDGE CASE: even row\n        //     if ((y & 1) == 0 && x >= 0) {\n        //         // Check hexel above and to the left (if it exists)\n        //         if (y > 0 && getRgba(colors, x + rowAbove) === oldColor) {\n        //             stack.push({x: x, y: y - 1});\n        //             spanAbove = true;\n        //         }\n        //         // Check hexel below and to the left (if it exists)\n        //         if (y < h - 1 && getRgba(colors, x + rowBelow) === oldColor) {\n        //             stack.push({x: x, y: y + 1});\n        //             spanBelow = true;\n        //         }\n        //     }\n        //     // Draw current scanline from far left to far right\n        //     for (x++; x < w && getRgba(colors, x + row) === oldColor; x++) {\n        //         let index = x + row;\n        //         setRgba(colors, index, newColor);\n        //         record.set(index);\n        //         // If there's another row above this one\n        //         if (y > 0) {\n        //             if (!spanAbove && getRgba(colors, x + rowAbove) === oldColor) {\n        //                 stack.push({x: x, y: y - 1});\n        //                 spanAbove = true;\n        //             }\n        //             else if (spanAbove && getRgba(colors, x + rowAbove) !== oldColor) {\n        //                 spanAbove = false;\n        //             }\n        //         }\n        //         // If there's another row below this one\n        //         if (y < h - 1) {\n        //             if (!spanBelow && getRgba(colors, x + rowBelow) === oldColor) {\n        //                 stack.push({x: x, y: y + 1});\n        //                 spanBelow = true;\n        //             }\n        //             else if (spanBelow && getRgba(colors, x + rowBelow) !== oldColor) {\n        //                 spanBelow = false;\n        //             }\n        //         }\n        //     }\n        //     // HEXEL EDGE CASE: odd row\n        //     if ((y & 1) && x < w) {\n        //         // Check hexel above and to the right (if it exists)\n        //         if (!spanAbove && y > 0 && getRgba(colors, x + rowAbove) === oldColor) {\n        //             stack.push({x: x, y: y - 1});\n        //         }\n        //         // Check hexel below and to the right (if it exists)\n        //         if (!spanBelow && y < h - 1 && getRgba(colors, x + rowBelow) === oldColor) {\n        //             stack.push({x: x, y: y + 1});\n        //         }\n        //     }\n        // }\n\n        // return record;\n    }\n\n    private bitArray() {\n        return createBitArray(this.hexels.length);\n    }\n};\n\nexport function copyPixelsToGrid(ctx: CanvasRenderingContext2D, {cols, rows, hexels}: HexelGrid) {\n    let data = ctx.getImageData(0, 0, cols, rows).data;\n    let pixels = new ColorBuffer(data);\n    let length = Math.min(pixels.length, hexels.length);\n    for (let i = 0; i < length; i++) {\n        let pixel = pixels.at(i);\n        let hexel = hexels.at(i);\n        if (!Color.isTransparent(pixel)) {\n            Color.blend(pixel, hexel, hexel);\n        }\n    }\n}\n\nexport function copyHexelsToCanvas({cols, rows, hexels}: HexelGrid, clearColor: Color.Like, canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\n    // Convert to pixels\n    let pixels = new ColorBuffer(new Uint8ClampedArray(hexels.data.length));\n    for (let i = 0; i < hexels.length; i++) {\n        let pixel = pixels.at(i);\n        let hexel = hexels.at(i);\n        if (!Color.equals(hexel, clearColor)) {\n            Color.copy(hexel, pixel);\n        }\n    }\n    // Pass pixels as image data to canvas\n    let imageData = new ImageData(pixels.data, cols, rows);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.putImageData(imageData, 0, 0);\n}\n\n\n","import { Drawable, FillProgram, Mat2dBuffer, PolygonModel, Renderer } from \"@wjheesen/glib\";\nimport { HexelProgram } from \"../program/hexel-program\";\nimport { HexelGrid } from \"./hexel-grid\";\n\nexport class Scene implements Drawable {\n\n    constructor(\n        private hexel: HexelProgram,\n        private grid: HexelGrid,\n    ) {}\n\n    hasRenderRequest() {\n        return this.grid.hasHexelChanges || this.grid.hasLayoutChanges;\n    }\n\n    draw(renderer: Renderer): void {\n        let { gl } = renderer;\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.enable(gl.CULL_FACE);\n        gl.cullFace(gl.BACK);\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n        this.hexel.draw(renderer);\n    }\n}","import { Camera,  Renderer, Surface, Rect, PolygonMesh, ProgramUtil, FillProgram, PolygonModel, Mat2dBuffer, ColorBuffer, Color, ColorF, Mat2d, WheelZoomTool, PointerEventDetector, PinchZoomTool, PanTool } from '@wjheesen/glib';\nimport { HexelGrid } from './hexel/hexel-grid';\nimport { Scene } from './hexel/scene';\nimport { HexelProgram } from './program/hexel-program';\nimport { Brush } from './tool/brush';\nimport { BrushSizeSlider } from './toolbar/brush-size-slider';\nimport { ColorPicker } from './toolbar/color-picker';\nimport { Settings } from './toolbar/settings';\nimport { ToolSelector } from './toolbar/tool-selector';\n\nlet canvasEl = <HTMLCanvasElement> document.getElementById('onscreen-canvas');\nlet gl = canvasEl.getContext('webgl');\nlet util = new ProgramUtil(gl);\n\nlet grid = new HexelGrid(128, 128);\ngrid.clear(Color.fromRgbInt(0xcdcdcd));\n\nlet hexMesh = PolygonMesh.regularPolygon(6);\nlet hexelProgram = HexelProgram.create(util, hexMesh, grid);\n\nlet camera = new Camera(grid.bounds, 1, Math.max(grid.rows, grid.cols));\nlet renderer = new Renderer(gl, camera);\nlet scene = new Scene(hexelProgram, grid);\nlet surface = new Surface(canvasEl, renderer, scene);\nsurface.startRenderLoop();\n\nlet settings = new Settings;\n\nlet wheelEvents = surface.startDetectingWheelEvents();\nwheelEvents.addListener(new WheelZoomTool(1.1));\n\nlet pointerEvents = surface.startDetectingPointerEvents();\npointerEvents.addListener(new PinchZoomTool);\n\nlet toolSelector = new ToolSelector(pointerEvents)\n    .addTool('brush', new Brush(grid, settings))\n    .addTool('pan-tool', new PanTool);\n\nsettings.initControls([\n    new ColorPicker(settings),\n    new BrushSizeSlider(settings),\n    toolSelector,\n])\n","import { PolygonMesh, Program, ProgramUtil, Renderer, Vec2, Vec2Buffer } from '@wjheesen/glib';\nimport { HexelGrid } from '../hexel/hexel-grid';\nimport * as Shader from './hexel-shader';\n\nexport class HexelProgram extends Program<Shader.Uniforms, Shader.Attributes> {\n\n    private hex: PolygonMesh;\n    private grid: HexelGrid;\n    private indexBuffer: WebGLBuffer;\n    private positionBuffer: WebGLBuffer;\n    private offsetBuffer: WebGLBuffer;\n    private colorBuffer: WebGLBuffer;\n    private gradientBuffer: WebGLBuffer;\n    \n    static create(util: ProgramUtil, hex: PolygonMesh, grid: HexelGrid) {\n        let program = new HexelProgram;\n        program.hex = hex;\n        program.grid = grid;\n        program.location = util.createProgramFromSources(Shader.vertex, Shader.fragment);\n        program.uniforms = util.getUniformLocationMap(program.location, Shader.uniformRenaming) as Shader.Uniforms;\n        program.attribs = util.getAttributeLocationMap(program.location, Shader.attributeRenaming) as Shader.Attributes;\n        program.indexBuffer = util.createIndexBuffer([hex]);\n        program.positionBuffer = util.createVertexBuffer([hex]);\n        program.offsetBuffer = util.createBuffer();\n        program.colorBuffer = util.createBuffer();\n        program.gradientBuffer = util.createArrayBuffer(this.getGradient());\n        return program;\n    }\n\n    private static getGradient() {\n        // Formula: 2*n^2, n=3,4,5\n        let g1 = 18 / 256, g2 = 32 / 256, g3 = 50 / 256;\n        return new Float32Array([g1, g2, g3, -g1, -g2, -g3]);\n    }\n\n    onAttach(renderer: Renderer) {\n        this.enableIndexBuffer(renderer);\n        this.enablePositionBuffer(renderer);\n        this.enableOffsetBuffer(renderer);\n        this.enableColorBuffer(renderer);\n        this.enableGradientBuffer(renderer);\n    }\n\n    private enableIndexBuffer({gl}: Renderer) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    }\n\n    private enablePositionBuffer({gl}: Renderer) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n        gl.enableVertexAttribArray(this.attribs.position);\n        gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 0, this.hex.vertexBufferOffset);\n    }\n\n    private enableOffsetBuffer({gl, angleExt}: Renderer) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.offsetBuffer);\n        gl.enableVertexAttribArray(this.attribs.offset);\n        gl.vertexAttribPointer(this.attribs.offset, 2, gl.FLOAT, false, 0, 0);\n        angleExt.vertexAttribDivisorANGLE(this.attribs.offset, 1); // Each hexel has its own offset\n    }\n\n    private enableColorBuffer({gl, angleExt}: Renderer) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n        gl.enableVertexAttribArray(this.attribs.hexelColor);\n        gl.vertexAttribPointer(this.attribs.hexelColor, 4, gl.UNSIGNED_BYTE, true, 0, 0);\n        angleExt.vertexAttribDivisorANGLE(this.attribs.hexelColor, 1);\n    }\n\n    private enableGradientBuffer({gl}: Renderer) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.gradientBuffer);\n        gl.enableVertexAttribArray(this.attribs.gradient);\n        gl.vertexAttribPointer(this.attribs.gradient, 1, gl.FLOAT, false, 0, 0);\n    }\n\n    onDetach({angleExt}: Renderer){\n        // Disable instancing (because it affects global state)\n        angleExt.vertexAttribDivisorANGLE(this.attribs.offset, 0);\n        angleExt.vertexAttribDivisorANGLE(this.attribs.color, 0);   \n    }\n\n    draw(renderer: Renderer) {\n        let {gl, angleExt} = renderer;\n        renderer.useProgram(this);\n        this.loadProjection(gl, renderer.camera.matrix);\n        if (this.grid.hasHexelChanges) this.loadHexels(gl);\n        if (this.grid.hasLayoutChanges) this.loadLayout(gl);\n        angleExt.drawElementsInstancedANGLE(gl.TRIANGLES, this.hex.indices.length, gl.UNSIGNED_SHORT, this.hex.indexBufferOffset, this.grid.hexels.length); \n        // angleExt.drawArraysInstancedANGLE(gl.TRIANGLE_STRIP, 0, vertices.length, matrices.length); // TODO: try\n    }\n\n    private loadProjection(gl: WebGLRenderingContext, projection: Float32Array) {\n        gl.uniformMatrix4fv(this.uniforms.projection, false, projection);\n    }\n\n    private loadLayout(gl: WebGLRenderingContext) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.offsetBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.grid.points().data, gl.STATIC_DRAW);\n        this.grid.hasLayoutChanges = false;\n    }\n\n    private loadHexels(gl: WebGLRenderingContext) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, this.grid.hexels.data, gl.DYNAMIC_DRAW);\n        this.grid.hasHexelChanges = false;\n    }\n}\n","export interface Uniforms {\n    readonly [name: string]: WebGLUniformLocation;\n    projection: WebGLUniformLocation;\n}\n\nexport interface Attributes {\n    readonly [name: string]: number;\n    hexelColor: number;\n    position: number;\n    offset: number;\n    gradient: number;\n}\n\nexport type Variables = Uniforms|Attributes;\n\nexport const vertex = \"precision mediump float;uniform mat4 c;attribute vec4 d;attribute vec2 e,f;attribute float b;varying vec4 a;void main(){gl_Position=c*vec4(e+f,1.,1.),a=d,a.r+=b,a.g+=b,a.b+=b,a.a=1.;}\", fragment = \"precision mediump float;varying vec4 a;void main(){gl_FragColor=a;}\", attributeRenaming = {\"hexelColor\":\"d\",\"position\":\"e\",\"offset\":\"f\",\"gradient\":\"b\"}, uniformRenaming = {\"projection\":\"c\"};\n","import { Color, Pointer, PointerEventListener } from \"@wjheesen/glib\";\nimport { Cube, Directions } from \"../hexel/cube\";\nimport { HexelGrid } from \"../hexel/hexel-grid\";\nimport { Settings } from \"../toolbar/settings\";\n\n/** TODO: add support for undo/redo */\nexport class Brush extends PointerEventListener {\n\n    private previous: Cube;\n\n    constructor(private grid: HexelGrid, private settings: Settings) { \n        super(); \n    }\n\n    wherePointer(p: Pointer) {\n        return p.isDown && p.activePointers.length === 1;\n    }\n\n    onPointerDown(p: Pointer) {\n        let cube = this.grid.cubeAtPoint(p.position).round();\n        let index = this.grid.indexAtCube(cube);\n        if (index !== -1) { \n            this.moveTo(cube);\n            this.previous = cube;\n            this.grid.hasHexelChanges = true;\n        }\n    }\n\n    private moveTo(start: Cube) {\n        this.grid.forEachHexelInRange(start, this.settings.brushRadius, hexel => {\n            Color.blend(this.settings.color, hexel, hexel);\n            this.grid.hasHexelChanges = true;\n        });\n    }\n\n    onPointerMove(p: Pointer) {\n        if (!this.previous) {\n            return this.onPointerDown(p);\n        }\n\n        let current = this.grid.cubeAtPoint(p.position).round();\n        if (!current.equals(this.previous)) {\n            this.lineTo(current);\n            this.previous = current;\n            this.grid.hasHexelChanges = true;\n        } \n    }\n\n    private lineTo(end: Cube) {\n        this.grid.forEachCubeInLine(this.previous, end, c => {\n            this.appendHexagon(this.previous, c);\n            this.previous = c;\n        });\n    }\n\n    private appendHexagon(last: Cube, center: Cube) {\n        let radius = this.settings.brushRadius;\n        if (radius === 0) {\n            // Check center\n            let index = this.grid.indexAtCube(center);\n            if (index !== -1 /* && !record.get(index) */) {\n                let hexel = this.grid.hexels.at(index);\n                Color.blend(this.settings.color, hexel, hexel);\n                // record.set(index);\n            }\n        } else {\n            // Get index d of direction(last, center)\n            const d = last.getDirection(center);\n            // Return if center is not a neighbor\n            if (d === -1) { \n                return; \n            }\n            // Move to first cube on outer ring:\n            // cube = center + radius * direction(d > 0 ? d - 1 : 5) //(CW 1)\n            let cube = new Cube();\n            cube.add(Directions[d > 0 ? d - 1 : 5]); \n            cube.scale(radius)\n            cube.add(center);\n            // Check initial cube\n            let index = this.grid.indexAtCube(cube);\n            if (index !== -1  /* && !record.get(index) && this.hexels.moveToPosition(index) */) {\n                let hexel = this.grid.hexels.at(index);\n                Color.blend(this.settings.color, hexel, hexel);\n            }\n            // for each d+1  i < d+3: (CCW 1)\n            for (let i = d + 1; i < d + 3; i++) {\n                for (let j = 0; j < radius; j++) {\n                    // Set cube to neighbor \n                    cube.getNeighbor(i % 6, cube) \n                    // Check cube\n                    let index = this.grid.indexAtCube(cube);\n                    if (index !== -1 /* && !record.get(index) && this.hexels.moveToPosition(index) */) {\n                        let hexel = this.grid.hexels.at(index);\n                        Color.blend(this.settings.color, hexel, hexel);\n                        // record.set(index);\n                    }\n                }\n            }\n        }\n    }\n\n    onPointerUp() {\n        // Add record to undo stack\n        // if(this.record) addToUndoStack(this.record);\n        // Release hold on previous point\n        this.previous = null;\n        // Release hold on record\n        // this.record = null\n    }\n}\n","import { PointerEventListener } from \"@wjheesen/glib\";\n\nexport class Tool  {\n\n    private btnEl: HTMLElement;\n\n    constructor(\n        public readonly id: string, \n        public readonly eventListener: PointerEventListener\n    ) {}\n\n    onInit() {\n        this.btnEl = document.getElementById(this.id);\n        this.btnEl.classList.add('btn', 'btn-light', 'btn-outline-secondary', 'p-2', 'tool');\n    }\n\n    addClickListener(listener: EventListenerOrEventListenerObject) {\n        this.btnEl.addEventListener('click', listener);\n    }\n\n    onSelect() {\n        this.btnEl.classList.add('tool--selected');\n        this.btnEl.setAttribute('aria-selected', 'true');\n    }\n\n    onDeselect() {\n        this.btnEl.classList.remove('tool--selected');\n        this.btnEl.removeAttribute('aria-selected');\n    }\n}","import { Control } from \"./control\";\nimport { Settings } from \"./settings\";\n\ndeclare var Slider: any;\n\nexport class BrushSizeSlider implements Control {\n\n    constructor(private settings: Settings) {}\n\n    onInit() {\n        let el = <HTMLInputElement> document.querySelector(\"input[name=brushRadius]\");\n        el.valueAsNumber = this.settings.brushRadius;\n\n        let slider = new Slider(el, {\n            min: el.min,\n            max: el.max,\n            step: el.step,\n            value: el.value,\n            tooltip: 'show'\n        });\n    \n        slider.on('slideStop', () => {\n            this.settings.brushRadius = slider.getValue();\n            // setTool(Brush, \"#brush\"); // TODO:\n        });\n    }\n}","import { Color } from \"@wjheesen/glib\";\nimport { Control } from \"./control\";\nimport { Settings } from \"./settings\";\n\nexport class ColorPicker implements Control {\n\n    private alpha: number;\n    private $picker: JQuery<HTMLElement>;\n\n    constructor(private settings: Settings) {}\n\n    onInit() {\n        this.resetAlpha();\n        this.initPicker();\n        this.initSlider();\n    }\n\n    private resetAlpha() {\n        this.alpha = this.settings.color.a / 0xff;\n    }\n\n    private initPicker() {\n        this.$picker = $(\"#color-picker\");\n\n        this.$picker.spectrum({\n            color: Color.toArgbString(this.settings.color),\n            flat: false,\n            showInput: false,\n            showInitial: false,\n            allowEmpty: false,\n            showAlpha: true,\n            disabled: false,\n            showPalette: true,\n            showPaletteOnly: true,\n            togglePaletteOnly: true,\n            showSelectionPalette: false,\n            clickoutFiresChange: true,\n            hideAfterPaletteSelect: true,\n            preferredFormat: \"rgb\",\n            palette: [\n                [\"#000\", \"#444\", \"#666\", \"#999\", \"#ccc\", \"#eee\", \"#f3f3f3\", \"#fff\"],\n                [\"#f00\", \"#f90\", \"#ff0\", \"#0f0\", \"#0ff\", \"#00f\", \"#90f\", \"#f0f\"],\n                [\"#ea9999\", \"#f9cb9c\", \"#ffe599\", \"#b6d7a8\", \"#a2c4c9\", \"#9fc5e8\", \"#b4a7d6\", \"#d5a6bd\"],\n                [\"#e06666\", \"#f6b26b\", \"#ffd966\", \"#93c47d\", \"#76a5af\", \"#6fa8dc\", \"#8e7cc3\", \"#c27ba0\"],\n                [\"#c00\", \"#e69138\", \"#f1c232\", \"#6aa84f\", \"#45818e\", \"#3d85c6\", \"#674ea7\", \"#a64d79\"],\n                [\"#900\", \"#b45f06\", \"#bf9000\", \"#38761d\", \"#134f5c\", \"#0b5394\", \"#351c75\", \"#741b47\"],\n                [\"#600\", \"#783f04\", \"#7f6000\", \"#274e13\", \"#0c343d\", \"#073763\", \"#20124d\", \"#4c1130\"]\n            ],\n            change: this.onChange,\n            hide: this.onHide,\n        });\n\n    }\n\n    private onChange = (tinycolor: tinycolor.Instance) => {\n        if (tinycolor) {\n            // Override alpha (in case of palette selection)\n            tinycolor.setAlpha(this.alpha);\n            // Convert to #aarrggbb string\n            let argb = tinycolor.toHex8String();\n            // Update UI component\n            $(this).spectrum(\"set\", argb);\n            // Update color\n            Color.fromArgbString(argb, this.settings.color);\n        }\n    }\n\n    private onHide = () => {\n        this.resetAlpha();\n    }\n\n    private initSlider() {\n        this.$picker.on(\"dragstop.spectrum\", (e, tinycolor) => {\n            this.alpha = tinycolor.getAlpha(); // Not applied until color is picked\n        });\n    }\n}","import { Color } from \"@wjheesen/glib\";\nimport { Control } from \"./control\";\n\nexport class Settings {\n    color = <Color.Like> {r: 39, g: 78, b: 19, a: 255};\n    brushRadius = 2;\n\n    initControls(controls: Control[]) {\n        controls.forEach(control => control.onInit());\n    }\n}","import { PointerEventDetector, PointerEventListener } from \"@wjheesen/glib\";\nimport { Tool } from \"../tool/tool\";\nimport { Control } from \"./control\";\n\nexport class ToolSelector implements Control {\n\n    private tools: Tool[] = [];    \n    private selectedTool?: Tool;\n\n    constructor(\n        private pointerEvents: PointerEventDetector, \n    ) {}\n\n    addTool(id: string, eventListener: PointerEventListener) {\n        this.tools.push(new Tool(id, eventListener));\n        return this;\n    }\n\n    onInit() {\n        this.tools.forEach(this.initTool);\n        this.select(this.tools[0]);\n    }\n\n    private initTool = (tool: Tool) => {\n        tool.onInit();\n        tool.addClickListener(() => this.setTool(tool));\n    }\n\n    private setTool(tool: Tool) {\n        this.deselect(this.selectedTool);\n        this.select(tool);\n    }\n\n    private deselect(tool: Tool) {\n        this.pointerEvents.removeListener(tool.eventListener);\n        this.selectedTool = null;\n        tool.onDeselect();\n    }\n\n    private select(tool: Tool) {\n        this.pointerEvents.addListener(tool.eventListener);\n        this.selectedTool = tool;\n        tool.onSelect();\n    }\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module\n__webpack_require__(4432);\n// This entry module used 'exports' so it can't be inlined\n"],"sourceRoot":""}