// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
import * as Point from "./point";
import Structure from "../structify/struct";
import StructureBuffer from "../structify/buf";

/**
 * The line from (x1,y1) to (x2,y2).
 */
interface Line {
    /**
     * The X coordinate of the point at the start of this Line.
     */
    x1: number;
    /**
     * The Y coordinate of the point at the start of this Line.
     */
    y1: number;
    /**
     * The X coordinate of the point at the end of this Line.
     */
    x2: number;
    /**
     * The Y coordinate of the point at the end of this Line.
     */
    y2: number;
}
export { Line as _};
/**
 * Sets each component of this Line to that of the other Line.
 */
export function set(_this: Line, other: Line) {
    _this.x1 = other.x1;
    _this.y1 = other.y1;
    _this.x2 = other.x2;
    _this.y2 = other.y2;
}

/**
 * Sets each component of this Line.
 */
export function set$(_this: Line, x1: number, y1: number, x2: number, y2: number) {
    _this.x1 = x1;
    _this.y1 = y1;
    _this.x2 = x2;
    _this.y2 = y2;
}

/**
 * Adds the other Line to this Line componentwise.
 */
export function add(_this: Line, other: Line) {
    _this.x1 += other.x1;
    _this.y1 += other.y1;
    _this.x2 += other.x2;
    _this.y2 += other.y2;
}

/**
 * Adds the specified values to this Line componentwise.
 */
export function add$(_this: Line, x1: number, y1: number, x2: number, y2: number) {
    _this.x1 += x1;
    _this.y1 += y1;
    _this.x2 += x2;
    _this.y2 += y2;
}

/**
 * Subtracts the other Line from this Line componentwise.
 */
export function subtract(_this: Line, other: Line) {
    _this.x1 -= other.x1;
    _this.y1 -= other.y1;
    _this.x2 -= other.x2;
    _this.y2 -= other.y2;
}

/**
 * Subtracts the specified values from this Line componentwise.
 */
export function subtract$(_this: Line, x1: number, y1: number, x2: number, y2: number) {
    _this.x1 -= x1;
    _this.y1 -= y1;
    _this.x2 -= x2;
    _this.y2 -= y2;
}

/**
 * Multiplies each component of this Line by the specified scalar.
 */
export function mulScalar(_this: Line, k: number) {
    _this.x1 *= k;
    _this.y1 *= k;
    _this.x2 *= k;
    _this.y2 *= k;
}

/**
 * Divides each component of this Line by the specified scalar.
 */
export function divScalar(_this: Line, k: number) {
    _this.x1 /= k;
    _this.y1 /= k;
    _this.x2 /= k;
    _this.y2 /= k;
}

/**
 * Checks if each component of this Line is equal to that of the other Line.
 */
export function equals(_this: Line, other: Line) {
    return _this.x1 === other.x1 && _this.y1 === other.y1 && _this.x2 === other.x2 && _this.y2 === other.y2;
}

/**
 * Checks if each component of this Line is equal to the specified scalar.
 */
export function equalsScalar(_this: Line, k: number) {
    return _this.x1 === k && _this.y1 === k && _this.x2 === k && _this.y2 === k;
}

/**
 * Checks if each component of this Line is approximately equal to that of the other Line.
 */
export function epsilonEquals(_this: Line, other: Line, e: number) {
    return Math.abs(_this.x1 - other.x1) <= e && Math.abs(_this.y1 - other.y1) <= e && Math.abs(_this.x2 - other.x2) <= e && Math.abs(_this.y2 - other.y2) <= e;
}

/**
 * Checks if each component of this Line is approximately equal to the specified scalar.
 */
export function epsilonEqualsScalar(_this: Line, k: number, e: number) {
    return Math.abs(_this.x1 - k) <= e && Math.abs(_this.y1 - k) <= e && Math.abs(_this.x2 - k) <= e && Math.abs(_this.y2 - k) <= e;
}

/**
 * Returns a string representation of this Line.
 */
export function toString(_this: Line) {
    return `{ x1: ${_this.x1}, y1: ${_this.y1}, x2: ${_this.x2}, y2: ${_this.y2} }`
}

/**
 * Sets this line to a line through the specified points.
 */
export function setThrough(_this: Line, p1: Point._, p2: Point._) {
    _this.x1 = p1.x;
    _this.y1 = p1.y;
    _this.x2 = p2.x;
    _this.y2 = p2.y;
}

/**
 * Checks if the distance from this line to the specified point is less than epsilon.
 */
export function contains(_this: Line, pt: Point._, epsilon: number) {
    return contains$(_this, pt.x, pt.y, epsilon);
}

/**
 * Checks if the distance from this line to (x,y) is less than epsilon.
 */
export function contains$(_this: Line, x: number, y: number, epsilon: number) {
    let ax = _this.x1,
                ay = _this.y1,
                bx = _this.x2 - ax,
                by = _this.y2 - ay,
                t = -1;
    let vx = x - ax, vy = y - ay;
    let dot = bx * vx + by * vy;
    let len2 = bx * bx + by * by;
    if (len2 != 0) { //in case of 0 length line
                t = dot / len2;
            }
    if (t < 0 || t > 1) {
                // Line does not contain point
                return false;
            }
    let projX = ax + t * bx;
    let projY = ay + t * by;
    let dx = x - projX;
    let dy = y - projY;
    let dist2 = dx * dx + dy * dy;
    return dist2 < (epsilon * epsilon);
}

/**
 * The line from (x1,y1) to (x2,y2).
 */
export class Obj {
    static create(other: Line) {
        let Line = new Obj();
        Line.set(other);
        return Line;
    }

    static create$(x1: number, y1: number, x2: number, y2: number) {
        let Line = new Obj();
        Line.set$(x1, y1, x2, y2);
        return Line;
    }

    static through(p1: Point._, p2: Point._) {
        let Line = new Obj();
        Line.setThrough(p1, p2);
        return Line;
    }

    /**
     * The X coordinate of the point at the start of this Line.
     */
    x1: number;
    /**
     * The Y coordinate of the point at the start of this Line.
     */
    y1: number;
    /**
     * The X coordinate of the point at the end of this Line.
     */
    x2: number;
    /**
     * The Y coordinate of the point at the end of this Line.
     */
    y2: number;

    /**
     * Sets each component of this Line to that of the other Line.
     */
    set(other: Line) {
        return set(this, other);
    }

    /**
     * Sets each component of this Line.
     */
    set$(x1: number, y1: number, x2: number, y2: number) {
        return set$(this, x1, y1, x2, y2);
    }

    /**
     * Adds the other Line to this Line componentwise.
     */
    add(other: Line) {
        return add(this, other);
    }

    /**
     * Adds the specified values to this Line componentwise.
     */
    add$(x1: number, y1: number, x2: number, y2: number) {
        return add$(this, x1, y1, x2, y2);
    }

    /**
     * Subtracts the other Line from this Line componentwise.
     */
    subtract(other: Line) {
        return subtract(this, other);
    }

    /**
     * Subtracts the specified values from this Line componentwise.
     */
    subtract$(x1: number, y1: number, x2: number, y2: number) {
        return subtract$(this, x1, y1, x2, y2);
    }

    /**
     * Multiplies each component of this Line by the specified scalar.
     */
    mulScalar(k: number) {
        return mulScalar(this, k);
    }

    /**
     * Divides each component of this Line by the specified scalar.
     */
    divScalar(k: number) {
        return divScalar(this, k);
    }

    /**
     * Checks if each component of this Line is equal to that of the other Line.
     */
    equals(other: Line) {
        return equals(this, other);
    }

    /**
     * Checks if each component of this Line is equal to the specified scalar.
     */
    equalsScalar(k: number) {
        return equalsScalar(this, k);
    }

    /**
     * Checks if each component of this Line is approximately equal to that of the other Line.
     */
    epsilonEquals(other: Line, e: number) {
        return epsilonEquals(this, other, e);
    }

    /**
     * Checks if each component of this Line is approximately equal to the specified scalar.
     */
    epsilonEqualsScalar(k: number, e: number) {
        return epsilonEqualsScalar(this, k, e);
    }

    /**
     * Returns a string representation of this Line.
     */
    toString() {
        return toString(this);
    }

    /**
     * Sets this line to a line through the specified points.
     */
    setThrough(p1: Point._, p2: Point._) {
        return setThrough(this, p1, p2);
    }

    /**
     * Checks if the distance from this line to the specified point is less than epsilon.
     */
    contains(pt: Point._, epsilon: number) {
        return contains(this, pt, epsilon);
    }

    /**
     * Checks if the distance from this line to (x,y) is less than epsilon.
     */
    contains$(x: number, y: number, epsilon: number) {
        return contains$(this, x, y, epsilon);
    }
}

/**
 * A Line backed by a Float32Array.
 */
export class Struct extends Structure<Float32Array> {
    static create(other: Line) {
        let Line = new Struct();
        Line.set(other);
        return Line;
    }

    static create$(x1: number, y1: number, x2: number, y2: number) {
        let Line = new Struct();
        Line.set$(x1, y1, x2, y2);
        return Line;
    }

    static through(p1: Point._, p2: Point._) {
        let Line = new Struct();
        Line.setThrough(p1, p2);
        return Line;
    }

    /**
     * Creates a Line struct.
     */
    constructor() {
        super(new Float32Array(4));
    }

    /**
     * The X coordinate of the point at the start of this Line.
     */
    get x1() {
        return this.data[0];
    }

    /**
     * The X coordinate of the point at the start of this Line.
     */
    set x1(value: number) {
        this.data[0] = value;
    }

    /**
     * The Y coordinate of the point at the start of this Line.
     */
    get y1() {
        return this.data[1];
    }

    /**
     * The Y coordinate of the point at the start of this Line.
     */
    set y1(value: number) {
        this.data[1] = value;
    }

    /**
     * The X coordinate of the point at the end of this Line.
     */
    get x2() {
        return this.data[2];
    }

    /**
     * The X coordinate of the point at the end of this Line.
     */
    set x2(value: number) {
        this.data[2] = value;
    }

    /**
     * The Y coordinate of the point at the end of this Line.
     */
    get y2() {
        return this.data[3];
    }

    /**
     * The Y coordinate of the point at the end of this Line.
     */
    set y2(value: number) {
        this.data[3] = value;
    }

    /**
     * Sets each component of this Line to that of the other Line.
     */
    set(other: Line) {
        return set(this, other);
    }

    /**
     * Sets each component of this Line.
     */
    set$(x1: number, y1: number, x2: number, y2: number) {
        return set$(this, x1, y1, x2, y2);
    }

    /**
     * Adds the other Line to this Line componentwise.
     */
    add(other: Line) {
        return add(this, other);
    }

    /**
     * Adds the specified values to this Line componentwise.
     */
    add$(x1: number, y1: number, x2: number, y2: number) {
        return add$(this, x1, y1, x2, y2);
    }

    /**
     * Subtracts the other Line from this Line componentwise.
     */
    subtract(other: Line) {
        return subtract(this, other);
    }

    /**
     * Subtracts the specified values from this Line componentwise.
     */
    subtract$(x1: number, y1: number, x2: number, y2: number) {
        return subtract$(this, x1, y1, x2, y2);
    }

    /**
     * Multiplies each component of this Line by the specified scalar.
     */
    mulScalar(k: number) {
        return mulScalar(this, k);
    }

    /**
     * Divides each component of this Line by the specified scalar.
     */
    divScalar(k: number) {
        return divScalar(this, k);
    }

    /**
     * Checks if each component of this Line is equal to that of the other Line.
     */
    equals(other: Line) {
        return equals(this, other);
    }

    /**
     * Checks if each component of this Line is equal to the specified scalar.
     */
    equalsScalar(k: number) {
        return equalsScalar(this, k);
    }

    /**
     * Checks if each component of this Line is approximately equal to that of the other Line.
     */
    epsilonEquals(other: Line, e: number) {
        return epsilonEquals(this, other, e);
    }

    /**
     * Checks if each component of this Line is approximately equal to the specified scalar.
     */
    epsilonEqualsScalar(k: number, e: number) {
        return epsilonEqualsScalar(this, k, e);
    }

    /**
     * Returns a string representation of this Line.
     */
    toString() {
        return toString(this);
    }

    /**
     * Sets this line to a line through the specified points.
     */
    setThrough(p1: Point._, p2: Point._) {
        return setThrough(this, p1, p2);
    }

    /**
     * Checks if the distance from this line to the specified point is less than epsilon.
     */
    contains(pt: Point._, epsilon: number) {
        return contains(this, pt, epsilon);
    }

    /**
     * Checks if the distance from this line to (x,y) is less than epsilon.
     */
    contains$(x: number, y: number, epsilon: number) {
        return contains$(this, x, y, epsilon);
    }
}

/**
 * A Line buffer backed by a Float32Array.
 */
export class Buf extends StructureBuffer<Float32Array> {
    /**
     * Creates an empty Line buffer with the specified Line capacity.
     */
    static create(capacity: number) {
        return new Buf(new Float32Array(capacity * 4));
    }

    /**
     * The X coordinate of the point at the start of the current Line.
     */
    get x1() {
        return this.data[this.dataPosition + 0];
    }

    /**
     * The X coordinate of the point at the start of the current Line.
     */
    set x1(value: number) {
        this.data[this.dataPosition + 0] = value;
    }

    /**
     * The Y coordinate of the point at the start of the current Line.
     */
    get y1() {
        return this.data[this.dataPosition + 1];
    }

    /**
     * The Y coordinate of the point at the start of the current Line.
     */
    set y1(value: number) {
        this.data[this.dataPosition + 1] = value;
    }

    /**
     * The X coordinate of the point at the end of the current Line.
     */
    get x2() {
        return this.data[this.dataPosition + 2];
    }

    /**
     * The X coordinate of the point at the end of the current Line.
     */
    set x2(value: number) {
        this.data[this.dataPosition + 2] = value;
    }

    /**
     * The Y coordinate of the point at the end of the current Line.
     */
    get y2() {
        return this.data[this.dataPosition + 3];
    }

    /**
     * The Y coordinate of the point at the end of the current Line.
     */
    set y2(value: number) {
        this.data[this.dataPosition + 3] = value;
    }

    /**
     * Gets the number of components in a Line, namely 4.
     */
    structLength() {
        return 4;
    }

    /**
     * Sets each component of the Line at the specified position.
     */
    set$(position: number, x1: number, y1: number, x2: number, y2: number) {
        let dataPos = position * this.structLength();
        this.data[dataPos++] = x1;
        this.data[dataPos++] = y1;
        this.data[dataPos++] = x2;
        this.data[dataPos++] = y2;
    }

    /**
     * Sets each component of the current Line, then moves to the next position of this buffer.
     */
    put$(x1: number, y1: number, x2: number, y2: number) {
        this.data[this.dataPosition++] = x1;
        this.data[this.dataPosition++] = y1;
        this.data[this.dataPosition++] = x2;
        this.data[this.dataPosition++] = y2;
    }

    /**
     * Sets each component of the current Line to that of the other Line.
     */
    $set(other: Line) {
        return set(this, other);
    }

    /**
     * Sets each component of the current Line.
     */
    $set$(x1: number, y1: number, x2: number, y2: number) {
        return set$(this, x1, y1, x2, y2);
    }

    /**
     * Adds the other Line to the current Line componentwise.
     */
    $add(other: Line) {
        return add(this, other);
    }

    /**
     * Adds the specified values to the current Line componentwise.
     */
    $add$(x1: number, y1: number, x2: number, y2: number) {
        return add$(this, x1, y1, x2, y2);
    }

    /**
     * Subtracts the other Line from the current Line componentwise.
     */
    $subtract(other: Line) {
        return subtract(this, other);
    }

    /**
     * Subtracts the specified values from the current Line componentwise.
     */
    $subtract$(x1: number, y1: number, x2: number, y2: number) {
        return subtract$(this, x1, y1, x2, y2);
    }

    /**
     * Multiplies each component of the current Line by the specified scalar.
     */
    $mulScalar(k: number) {
        return mulScalar(this, k);
    }

    /**
     * Divides each component of the current Line by the specified scalar.
     */
    $divScalar(k: number) {
        return divScalar(this, k);
    }

    /**
     * Checks if each component of the current Line is equal to that of the other Line.
     */
    $equals(other: Line) {
        return equals(this, other);
    }

    /**
     * Checks if each component of the current Line is equal to the specified scalar.
     */
    $equalsScalar(k: number) {
        return equalsScalar(this, k);
    }

    /**
     * Checks if each component of the current Line is approximately equal to that of the other Line.
     */
    $epsilonEquals(other: Line, e: number) {
        return epsilonEquals(this, other, e);
    }

    /**
     * Checks if each component of the current Line is approximately equal to the specified scalar.
     */
    $epsilonEqualsScalar(k: number, e: number) {
        return epsilonEqualsScalar(this, k, e);
    }

    /**
     * Returns a string representation of the current Line.
     */
    $toString() {
        return toString(this);
    }

    /**
     * Sets this line to a line through the specified points.
     */
    $setThrough(p1: Point._, p2: Point._) {
        return setThrough(this, p1, p2);
    }

    /**
     * Checks if the distance from this line to the specified point is less than epsilon.
     */
    $contains(pt: Point._, epsilon: number) {
        return contains(this, pt, epsilon);
    }

    /**
     * Checks if the distance from this line to (x,y) is less than epsilon.
     */
    $contains$(x: number, y: number, epsilon: number) {
        return contains$(this, x, y, epsilon);
    }
}
