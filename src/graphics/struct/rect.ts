// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
import * as Point from "./point";
import Structure from "../structify/struct";
import StructureBuffer from "../structify/buf";

/**
 * A rectangle with (left, top, right, bottom) boundaries.
 */
interface Rect {
    /**
     * The left boundary of this Rect.
     */
    left: number;
    /**
     * The top boundary of this Rect.
     */
    top: number;
    /**
     * The right boundary of this Rect.
     */
    right: number;
    /**
     * The bottom boundary of this Rect.
     */
    bottom: number;
}
export { Rect as _};
/**
 * Sets each component of this Rect to that of the other Rect.
 */
export function set(_this: Rect, other: Rect) {
    _this.left = other.left;
    _this.top = other.top;
    _this.right = other.right;
    _this.bottom = other.bottom;
}

/**
 * Sets each component of this Rect.
 */
export function set$(_this: Rect, left: number, top: number, right: number, bottom: number) {
    _this.left = left;
    _this.top = top;
    _this.right = right;
    _this.bottom = bottom;
}

/**
 * Adds the other Rect to this Rect componentwise.
 */
export function add(_this: Rect, other: Rect) {
    _this.left += other.left;
    _this.top += other.top;
    _this.right += other.right;
    _this.bottom += other.bottom;
}

/**
 * Adds the specified values to this Rect componentwise.
 */
export function add$(_this: Rect, left: number, top: number, right: number, bottom: number) {
    _this.left += left;
    _this.top += top;
    _this.right += right;
    _this.bottom += bottom;
}

/**
 * Subtracts the other Rect from this Rect componentwise.
 */
export function subtract(_this: Rect, other: Rect) {
    _this.left -= other.left;
    _this.top -= other.top;
    _this.right -= other.right;
    _this.bottom -= other.bottom;
}

/**
 * Subtracts the specified values from this Rect componentwise.
 */
export function subtract$(_this: Rect, left: number, top: number, right: number, bottom: number) {
    _this.left -= left;
    _this.top -= top;
    _this.right -= right;
    _this.bottom -= bottom;
}

/**
 * Multiplies each component of this Rect by the specified scalar.
 */
export function mulScalar(_this: Rect, k: number) {
    _this.left *= k;
    _this.top *= k;
    _this.right *= k;
    _this.bottom *= k;
}

/**
 * Divides each component of this Rect by the specified scalar.
 */
export function divScalar(_this: Rect, k: number) {
    _this.left /= k;
    _this.top /= k;
    _this.right /= k;
    _this.bottom /= k;
}

/**
 * Checks if each component of this Rect is equal to that of the other Rect.
 */
export function equals(_this: Rect, other: Rect) {
    return _this.left === other.left && _this.top === other.top && _this.right === other.right && _this.bottom === other.bottom;
}

/**
 * Checks if each component of this Rect is equal to the specified scalar.
 */
export function equalsScalar(_this: Rect, k: number) {
    return _this.left === k && _this.top === k && _this.right === k && _this.bottom === k;
}

/**
 * Checks if each component of this Rect is approximately equal to that of the other Rect.
 */
export function epsilonEquals(_this: Rect, other: Rect, e: number) {
    return Math.abs(_this.left - other.left) <= e && Math.abs(_this.top - other.top) <= e && Math.abs(_this.right - other.right) <= e && Math.abs(_this.bottom - other.bottom) <= e;
}

/**
 * Checks if each component of this Rect is approximately equal to the specified scalar.
 */
export function epsilonEqualsScalar(_this: Rect, k: number, e: number) {
    return Math.abs(_this.left - k) <= e && Math.abs(_this.top - k) <= e && Math.abs(_this.right - k) <= e && Math.abs(_this.bottom - k) <= e;
}

/**
 * Returns a string representation of this Rect.
 */
export function toString(_this: Rect) {
    return `{ left: ${_this.left}, top: ${_this.top}, right: ${_this.right}, bottom: ${_this.bottom} }`
}

/**
 * Sets the boundaries of this Rect in left-top-right-bottom order.
 */
export function setLtrb(_this: Rect, left: number, top: number, right: number, bottom: number) {
    _this.left = left;
    _this.top = top;
    _this.right = right;
    _this.bottom = bottom;
}

/**
 * Sets the boundaries of this Rect in left-bottom-right-top order.
 */
export function setLbrt(_this: Rect, left: number, bottom: number, right: number, top: number) {
    _this.left = left;
    _this.top = top;
    _this.right = right;
    _this.bottom = bottom;
}

/**
 * Sets the boundaries of this Rect in left-right-bottom-top order.
 */
export function setLrbt(_this: Rect, left: number, right: number, bottom: number, top: number) {
    _this.left = left;
    _this.top = top;
    _this.right = right;
    _this.bottom = bottom;
}

/**
 * Sets the dimensions of this rect in left-top-width-height order.
 */
export function setLtwh(_this: Rect, left: number, top: number, width: number, height: number) {
    _this.left = left;
    _this.top = top;
    _this.right = left + width;
    _this.bottom = top - height;
}

/**
 * Sets the dimensions of this rect in left-bottom-width-height order.
 */
export function setLbwh(_this: Rect, left: number, bottom: number, width: number, height: number) {
    _this.left = left;
    _this.top = bottom + height;
    _this.right = left + width;
    _this.bottom = bottom;
}

/**
 * Checks if this Rect is empty. True if left >= right or bottom >= top.
 */
export function isEmpty(_this: Rect) {
    return _this.left >= _this.right || _this.bottom >= _this.top;
}

/**
 * Checks if the boundaries of this Rect represent a valid rectangle. True if right >= left and top >= bottom.
 */
export function isValid(_this: Rect) {
    return _this.right >= _this.left && _this.top >= _this.bottom;
}

/**
 * Computes the width of this Rect.
 */
export function width(_this: Rect) {
    return _this.right - _this.left;
}

/**
 * Computes the height of this Rect.
 */
export function height(_this: Rect) {
    return _this.top - _this.bottom;
}

/**
 * Computes the area of this Rect.
 */
export function area(_this: Rect) {
    return width(_this, ) * height(_this, );
}

/**
 * Finds the x-coordinate of the point at the center of this Rect.
 */
export function centerX(_this: Rect) {
    return 0.5 * (_this.left + _this.right);
}

/**
 * Finds the y-coordinate of the point at the center of this Rect.
 */
export function centerY(_this: Rect) {
    return 0.5 * (_this.bottom + _this.top);
}

/**
 * Sets the specified point to the point at the center of this Rect
 */
export function center(_this: Rect, dst: Point._) {
    dst.x = centerX(_this, );
    dst.y = centerY(_this, );
    return dst;
}

/**
 * Sets the specified point to the point between the top left and top right corners of this Rect.
 */
export function centerTop(_this: Rect, dst: Point._) {
    dst.x = centerX(_this, );
    dst.y = _this.top;
    return dst;
}

/**
 *  Sets the specified point to the point between the bottom left and bottom right corners of this Rect.
 */
export function centerBottom(_this: Rect, dst: Point._) {
    dst.x = centerX(_this, );
    dst.y = _this.bottom;
    return dst;
}

/**
 * Sets the specified point to the point between the top and bottom left corners of this Rect.
 */
export function centerLeft(_this: Rect, dst: Point._) {
    dst.x = _this.left;
    dst.y = centerY(_this, );
    return dst;
}

/**
 * Sets the specified point to the point between the top and bottom right corners of this Rect.
 */
export function centerRight(_this: Rect, dst: Point._) {
    dst.x = _this.left;
    dst.y = centerY(_this, );
    return dst;
}

/**
 * Sets the specified point to the point at the bottom left corner of this Rect.
 */
export function bottomLeft(_this: Rect, dst: Point._) {
    dst.x = _this.left;
    dst.y = _this.bottom;
    return dst;
}

/**
 * Sets the specified point to the point at the bottom right corner of this Rect.
 */
export function bottomRight(_this: Rect, dst: Point._) {
    dst.x = _this.right;
    dst.y = _this.bottom;
    return dst;
}

/**
 * Sets the specified point to the point at the top left corner of this Rect.
 */
export function topLeft(_this: Rect, dst: Point._) {
    dst.x = _this.left;
    dst.y = _this.top;
    return dst;
}

/**
 * Sets the specified point to the point at the top right corner of this Rect.
 */
export function topRight(_this: Rect, dst: Point._) {
    dst.x = _this.right;
    dst.y = _this.top;
    return dst;
}

/**
 * Sets this Rect to the empty rect (0,0,0,0).
 */
export function empty(_this: Rect) {
    _this.left = 0;
    _this.top = 0;
    _this.right = 0;
    _this.bottom = 0;
}

/**
 * Sets this Rect to the smallest rectangle containing the two specified points.
 */
export function setUnionOfPoints(_this: Rect, points: Point._[], offset = 0, count = points.length) {
    _this.left = _this.right = points[offset].x;
    _this.top = _this.bottom = points[offset].y;
    unionPoints(_this, points, offset + 1, count - 1);
}

/**
 * Sets this Rect to the smallest rectangle containing a subset of points in the specified array.
 * @param points array of points entered as a series of (x,y) coordinates.
 * @param offset offset of the first point in the subset.
 * @param count number of points in the subset.
 */
export function setUnionOfPoints$(_this: Rect, points: Float32Array, offset = 0, count = points.length >> 1) {
    _this.left = _this.right = points[offset++];
    _this.top = _this.bottom = points[offset++];
    unionPoints$(_this, points, offset, count - 1);
}

/**
 * Checks if this Rect contains the other Rect.
 */
export function contains(_this: Rect, other: Rect) {
    return _this.left <= other.left && other.right <= _this.right &&
                _this.bottom <= other.bottom && other.top <= _this.top;
}

/**
 * Checks if this Rect contains the specified point.
 */
export function containsPoint(_this: Rect, p: Point._) {
    return containsPoint$(_this, p.x, p.y);
}

/**
 * Checks if this Rect contains the point (x,y).
 */
export function containsPoint$(_this: Rect, x: number, y: number) {
    return _this.left <= x && x <= _this.right && _this.bottom <= y && y <= _this.top;
}

/**
 * Checks if this Rect intersects the other Rect.
 */
export function intersects(_this: Rect, other: Rect) {
    return _this.right >= other.left && other.right >= _this.left
                && _this.top >= other.bottom && other.top >= _this.bottom;
}

/**
 * Sets this Rect to the intersection of itself with the other Rect.
 */
export function intersect(_this: Rect, other: Rect) {
    _this.left = Math.max(_this.left, other.left);
    _this.right = Math.min(_this.right, other.right);
    _this.bottom = Math.max(_this.bottom, other.bottom);
    _this.top = Math.min(_this.top, other.top);
}

/**
 * Expands this Rect to enclose the other Rect.
 */
export function union(_this: Rect, other: Rect) {
    _this.left = Math.max(_this.left, other.left);
    _this.right = Math.min(_this.right, other.right);
    _this.bottom = Math.max(_this.bottom, other.bottom);
    _this.top = Math.min(_this.top, other.top);
}

/**
 * Expands this Rect to enclose the specified point.
 */
export function unionPoint(_this: Rect, p: Point._) {
    unionPoint$(_this, p.x, p.y);
}

/**
 * Expands this Rect to enclose the point (x,y).
 */
export function unionPoint$(_this: Rect, x: number, y: number) {
    _this.left = Math.min(x, _this.left);
    _this.top = Math.max(y, _this.top);
    _this.right = Math.max(x, _this.right);
    _this.bottom = Math.min(y, _this.bottom);
}

/**
 * Expands this Rect to enclose the specified points
 * @param points array of points.
 * @param offset offset of the first point in the subset.
 * @param count number of points in the subset.
 */
export function unionPoints(_this: Rect, points: Point._[], offset = 0, count = points.length) {
    while (count-- > 0) {
                //Expand _this Rect to enclose the point
                unionPoint(_this, points[offset++]);
            }
}

/**
 * Expands this Rect to enclose the specified points
 * @param points array of points entered as a series of (x,y) coordinates.
 * @param offset offset of the first point in the subset.
 * @param count number of points in the subset.
 */
export function unionPoints$(_this: Rect, points: Float32Array, offset = 0, count = points.length >> 1) {
    while (count-- > 0) {
                //Expand _this Rect to enclose the point
                unionPoint$(_this, points[offset++], points[offset++]);
            }
}

/**
 * Insets the boundaries of this Rect by the vector (dx,dy).
 */
export function inset(_this: Rect, dx: number, dy: number) {
    _this.left += dx;
    _this.top -= dy;
    _this.right -= dx;
    _this.bottom += dy;
}

/**
 * Offsets the boundaries of this Rect by the vector (dx,dy).
 */
export function offset(_this: Rect, dx: number, dy: number) {
    _this.left += dx;
    _this.top += dy;
    _this.right += dx;
    _this.bottom += dy;
}

/**
 * Scales this Rect out from it's center by the specified (sx,sy) percentages.
 * @param r the Rect to scale.
 * @param sx the percentage by which to scale in the horizontal direction.
 * @param sy the percentage by which to scale in the vertical direction.
 */
export function scale(_this: Rect, sx: number, sy: number) {
    let cx = centerX(_this, );
    let cy = centerY(_this, );
    offset(_this, -cx, -cy);
    _this.left *= sx;
    _this.right *= sx;
    _this.bottom *= sy;
    _this.top *= sy;
    offset(_this, cx, cy);
}

/**
 * Stretches this Rect out from it's center by the specified ratio, maintaining aspect.
 * @param ratio the percentage by which to stretch in all directions.
 */
export function stretch(_this: Rect, ratio: number) {
    scale(_this, ratio, ratio);
}

/**
 * Shrinks this Rect to a square with the same center point.
 */
export function shrinkToSquare(_this: Rect) {
    let w = width(_this, ), h = height(_this, );
    if (h > w) {
                // Cut off top and bottom edges by scaling
                scale(_this, 1, w / h);
            }
            // Otherwise, if _this Rect is wider than it is tall
            else if (w > h) {
                // Cut off left and right edges by scaling
                scale(_this, h / w, 1);
            }
}

/**
 * Expands this Rect to a square with the same center point.
 */
export function expandToSquare(_this: Rect) {
    let w = width(_this, ), h = height(_this, );
    if (h > w) {
                // Scale left and right edges so width=height
                scale(_this, h / w, 1);
            }
            // Otherwise, if _this Rect is wider than it is tall
            else if (w > h) {
                // Scale top and bottom edges so width=height
                scale(_this, 1, w / h);
            }
}

/**
 * Swaps the top/bottom or left/right boundaries of this Rect if they are flipped, meaning left > right and/or top > bottom.
 */
export function sort(_this: Rect) {
    if (_this.bottom > _this.top) {
                //Swap top and bottom
                let topCopy = _this.top;
                _this.top = _this.bottom;
                _this.bottom = topCopy;
            }
    if (_this.left > _this.right) {
                //Swap left and right
                let rightCopy = _this.right;
                _this.right = _this.left;
                _this.left = rightCopy;
            }
}

/**
 * A rectangle with (left, top, right, bottom) boundaries.
 */
export class Obj {
    static create(other: Rect) {
        let Rect = new Obj();
        Rect.set(other);
        return Rect;
    }

    static create$(left: number, top: number, right: number, bottom: number) {
        let Rect = new Obj();
        Rect.set$(left, top, right, bottom);
        return Rect;
    }

    static ltrb(left: number, top: number, right: number, bottom: number) {
        let Rect = new Obj();
        Rect.setLtrb(left, top, right, bottom);
        return Rect;
    }

    static lbrt(left: number, bottom: number, right: number, top: number) {
        let Rect = new Obj();
        Rect.setLbrt(left, bottom, right, top);
        return Rect;
    }

    static lrbt(left: number, right: number, bottom: number, top: number) {
        let Rect = new Obj();
        Rect.setLrbt(left, right, bottom, top);
        return Rect;
    }

    static ltwh(left: number, top: number, width: number, height: number) {
        let Rect = new Obj();
        Rect.setLtwh(left, top, width, height);
        return Rect;
    }

    static lbwh(left: number, bottom: number, width: number, height: number) {
        let Rect = new Obj();
        Rect.setLbwh(left, bottom, width, height);
        return Rect;
    }

    static unionOfPoints(points: Point._[], offset = 0, count = points.length) {
        let Rect = new Obj();
        Rect.setUnionOfPoints(points, offset, count);
        return Rect;
    }

    static unionOfPoints$(points: Float32Array, offset = 0, count = points.length >> 1) {
        let Rect = new Obj();
        Rect.setUnionOfPoints$(points, offset, count);
        return Rect;
    }

    /**
     * The left boundary of this Rect.
     */
    left: number;
    /**
     * The top boundary of this Rect.
     */
    top: number;
    /**
     * The right boundary of this Rect.
     */
    right: number;
    /**
     * The bottom boundary of this Rect.
     */
    bottom: number;

    /**
     * Sets each component of this Rect to that of the other Rect.
     */
    set(other: Rect) {
        return set(this, other);
    }

    /**
     * Sets each component of this Rect.
     */
    set$(left: number, top: number, right: number, bottom: number) {
        return set$(this, left, top, right, bottom);
    }

    /**
     * Adds the other Rect to this Rect componentwise.
     */
    add(other: Rect) {
        return add(this, other);
    }

    /**
     * Adds the specified values to this Rect componentwise.
     */
    add$(left: number, top: number, right: number, bottom: number) {
        return add$(this, left, top, right, bottom);
    }

    /**
     * Subtracts the other Rect from this Rect componentwise.
     */
    subtract(other: Rect) {
        return subtract(this, other);
    }

    /**
     * Subtracts the specified values from this Rect componentwise.
     */
    subtract$(left: number, top: number, right: number, bottom: number) {
        return subtract$(this, left, top, right, bottom);
    }

    /**
     * Multiplies each component of this Rect by the specified scalar.
     */
    mulScalar(k: number) {
        return mulScalar(this, k);
    }

    /**
     * Divides each component of this Rect by the specified scalar.
     */
    divScalar(k: number) {
        return divScalar(this, k);
    }

    /**
     * Checks if each component of this Rect is equal to that of the other Rect.
     */
    equals(other: Rect) {
        return equals(this, other);
    }

    /**
     * Checks if each component of this Rect is equal to the specified scalar.
     */
    equalsScalar(k: number) {
        return equalsScalar(this, k);
    }

    /**
     * Checks if each component of this Rect is approximately equal to that of the other Rect.
     */
    epsilonEquals(other: Rect, e: number) {
        return epsilonEquals(this, other, e);
    }

    /**
     * Checks if each component of this Rect is approximately equal to the specified scalar.
     */
    epsilonEqualsScalar(k: number, e: number) {
        return epsilonEqualsScalar(this, k, e);
    }

    /**
     * Returns a string representation of this Rect.
     */
    toString() {
        return toString(this);
    }

    /**
     * Sets the boundaries of this Rect in left-top-right-bottom order.
     */
    setLtrb(left: number, top: number, right: number, bottom: number) {
        return setLtrb(this, left, top, right, bottom);
    }

    /**
     * Sets the boundaries of this Rect in left-bottom-right-top order.
     */
    setLbrt(left: number, bottom: number, right: number, top: number) {
        return setLbrt(this, left, bottom, right, top);
    }

    /**
     * Sets the boundaries of this Rect in left-right-bottom-top order.
     */
    setLrbt(left: number, right: number, bottom: number, top: number) {
        return setLrbt(this, left, right, bottom, top);
    }

    /**
     * Sets the dimensions of this rect in left-top-width-height order.
     */
    setLtwh(left: number, top: number, width: number, height: number) {
        return setLtwh(this, left, top, width, height);
    }

    /**
     * Sets the dimensions of this rect in left-bottom-width-height order.
     */
    setLbwh(left: number, bottom: number, width: number, height: number) {
        return setLbwh(this, left, bottom, width, height);
    }

    /**
     * Checks if this Rect is empty. True if left >= right or bottom >= top.
     */
    isEmpty() {
        return isEmpty(this);
    }

    /**
     * Checks if the boundaries of this Rect represent a valid rectangle. True if right >= left and top >= bottom.
     */
    isValid() {
        return isValid(this);
    }

    /**
     * Computes the width of this Rect.
     */
    width() {
        return width(this);
    }

    /**
     * Computes the height of this Rect.
     */
    height() {
        return height(this);
    }

    /**
     * Computes the area of this Rect.
     */
    area() {
        return area(this);
    }

    /**
     * Finds the x-coordinate of the point at the center of this Rect.
     */
    centerX() {
        return centerX(this);
    }

    /**
     * Finds the y-coordinate of the point at the center of this Rect.
     */
    centerY() {
        return centerY(this);
    }

    /**
     * Sets the specified point to the point at the center of this Rect
     */
    center(dst: Point._) {
        return center(this, dst);
    }

    /**
     * Sets the specified point to the point between the top left and top right corners of this Rect.
     */
    centerTop(dst: Point._) {
        return centerTop(this, dst);
    }

    /**
     *  Sets the specified point to the point between the bottom left and bottom right corners of this Rect.
     */
    centerBottom(dst: Point._) {
        return centerBottom(this, dst);
    }

    /**
     * Sets the specified point to the point between the top and bottom left corners of this Rect.
     */
    centerLeft(dst: Point._) {
        return centerLeft(this, dst);
    }

    /**
     * Sets the specified point to the point between the top and bottom right corners of this Rect.
     */
    centerRight(dst: Point._) {
        return centerRight(this, dst);
    }

    /**
     * Sets the specified point to the point at the bottom left corner of this Rect.
     */
    bottomLeft(dst: Point._) {
        return bottomLeft(this, dst);
    }

    /**
     * Sets the specified point to the point at the bottom right corner of this Rect.
     */
    bottomRight(dst: Point._) {
        return bottomRight(this, dst);
    }

    /**
     * Sets the specified point to the point at the top left corner of this Rect.
     */
    topLeft(dst: Point._) {
        return topLeft(this, dst);
    }

    /**
     * Sets the specified point to the point at the top right corner of this Rect.
     */
    topRight(dst: Point._) {
        return topRight(this, dst);
    }

    /**
     * Sets this Rect to the empty rect (0,0,0,0).
     */
    empty() {
        return empty(this);
    }

    /**
     * Sets this Rect to the smallest rectangle containing the two specified points.
     */
    setUnionOfPoints(points: Point._[], offset = 0, count = points.length) {
        return setUnionOfPoints(this, points, offset, count);
    }

    /**
     * Sets this Rect to the smallest rectangle containing a subset of points in the specified array.
     * @param points array of points entered as a series of (x,y) coordinates.
     * @param offset offset of the first point in the subset.
     * @param count number of points in the subset.
     */
    setUnionOfPoints$(points: Float32Array, offset = 0, count = points.length >> 1) {
        return setUnionOfPoints$(this, points, offset, count);
    }

    /**
     * Checks if this Rect contains the other Rect.
     */
    contains(other: Rect) {
        return contains(this, other);
    }

    /**
     * Checks if this Rect contains the specified point.
     */
    containsPoint(p: Point._) {
        return containsPoint(this, p);
    }

    /**
     * Checks if this Rect contains the point (x,y).
     */
    containsPoint$(x: number, y: number) {
        return containsPoint$(this, x, y);
    }

    /**
     * Checks if this Rect intersects the other Rect.
     */
    intersects(other: Rect) {
        return intersects(this, other);
    }

    /**
     * Sets this Rect to the intersection of itself with the other Rect.
     */
    intersect(other: Rect) {
        return intersect(this, other);
    }

    /**
     * Expands this Rect to enclose the other Rect.
     */
    union(other: Rect) {
        return union(this, other);
    }

    /**
     * Expands this Rect to enclose the specified point.
     */
    unionPoint(p: Point._) {
        return unionPoint(this, p);
    }

    /**
     * Expands this Rect to enclose the point (x,y).
     */
    unionPoint$(x: number, y: number) {
        return unionPoint$(this, x, y);
    }

    /**
     * Expands this Rect to enclose the specified points
     * @param points array of points.
     * @param offset offset of the first point in the subset.
     * @param count number of points in the subset.
     */
    unionPoints(points: Point._[], offset = 0, count = points.length) {
        return unionPoints(this, points, offset, count);
    }

    /**
     * Expands this Rect to enclose the specified points
     * @param points array of points entered as a series of (x,y) coordinates.
     * @param offset offset of the first point in the subset.
     * @param count number of points in the subset.
     */
    unionPoints$(points: Float32Array, offset = 0, count = points.length >> 1) {
        return unionPoints$(this, points, offset, count);
    }

    /**
     * Insets the boundaries of this Rect by the vector (dx,dy).
     */
    inset(dx: number, dy: number) {
        return inset(this, dx, dy);
    }

    /**
     * Offsets the boundaries of this Rect by the vector (dx,dy).
     */
    offset(dx: number, dy: number) {
        return offset(this, dx, dy);
    }

    /**
     * Scales this Rect out from it's center by the specified (sx,sy) percentages.
     * @param r the Rect to scale.
     * @param sx the percentage by which to scale in the horizontal direction.
     * @param sy the percentage by which to scale in the vertical direction.
     */
    scale(sx: number, sy: number) {
        return scale(this, sx, sy);
    }

    /**
     * Stretches this Rect out from it's center by the specified ratio, maintaining aspect.
     * @param ratio the percentage by which to stretch in all directions.
     */
    stretch(ratio: number) {
        return stretch(this, ratio);
    }

    /**
     * Shrinks this Rect to a square with the same center point.
     */
    shrinkToSquare() {
        return shrinkToSquare(this);
    }

    /**
     * Expands this Rect to a square with the same center point.
     */
    expandToSquare() {
        return expandToSquare(this);
    }

    /**
     * Swaps the top/bottom or left/right boundaries of this Rect if they are flipped, meaning left > right and/or top > bottom.
     */
    sort() {
        return sort(this);
    }
}

/**
 * A Rect backed by a Float32Array.
 */
export class Struct extends Structure<Float32Array> {
    static create(other: Rect) {
        let Rect = new Struct();
        Rect.set(other);
        return Rect;
    }

    static create$(left: number, top: number, right: number, bottom: number) {
        let Rect = new Struct();
        Rect.set$(left, top, right, bottom);
        return Rect;
    }

    static ltrb(left: number, top: number, right: number, bottom: number) {
        let Rect = new Struct();
        Rect.setLtrb(left, top, right, bottom);
        return Rect;
    }

    static lbrt(left: number, bottom: number, right: number, top: number) {
        let Rect = new Struct();
        Rect.setLbrt(left, bottom, right, top);
        return Rect;
    }

    static lrbt(left: number, right: number, bottom: number, top: number) {
        let Rect = new Struct();
        Rect.setLrbt(left, right, bottom, top);
        return Rect;
    }

    static ltwh(left: number, top: number, width: number, height: number) {
        let Rect = new Struct();
        Rect.setLtwh(left, top, width, height);
        return Rect;
    }

    static lbwh(left: number, bottom: number, width: number, height: number) {
        let Rect = new Struct();
        Rect.setLbwh(left, bottom, width, height);
        return Rect;
    }

    static unionOfPoints(points: Point._[], offset = 0, count = points.length) {
        let Rect = new Struct();
        Rect.setUnionOfPoints(points, offset, count);
        return Rect;
    }

    static unionOfPoints$(points: Float32Array, offset = 0, count = points.length >> 1) {
        let Rect = new Struct();
        Rect.setUnionOfPoints$(points, offset, count);
        return Rect;
    }

    /**
     * Creates a Rect struct.
     */
    constructor() {
        super(new Float32Array(4));
    }

    /**
     * The left boundary of this Rect.
     */
    get left() {
        return this.data[0];
    }

    /**
     * The left boundary of this Rect.
     */
    set left(value: number) {
        this.data[0] = value;
    }

    /**
     * The top boundary of this Rect.
     */
    get top() {
        return this.data[1];
    }

    /**
     * The top boundary of this Rect.
     */
    set top(value: number) {
        this.data[1] = value;
    }

    /**
     * The right boundary of this Rect.
     */
    get right() {
        return this.data[2];
    }

    /**
     * The right boundary of this Rect.
     */
    set right(value: number) {
        this.data[2] = value;
    }

    /**
     * The bottom boundary of this Rect.
     */
    get bottom() {
        return this.data[3];
    }

    /**
     * The bottom boundary of this Rect.
     */
    set bottom(value: number) {
        this.data[3] = value;
    }

    /**
     * Sets each component of this Rect to that of the other Rect.
     */
    set(other: Rect) {
        return set(this, other);
    }

    /**
     * Sets each component of this Rect.
     */
    set$(left: number, top: number, right: number, bottom: number) {
        return set$(this, left, top, right, bottom);
    }

    /**
     * Adds the other Rect to this Rect componentwise.
     */
    add(other: Rect) {
        return add(this, other);
    }

    /**
     * Adds the specified values to this Rect componentwise.
     */
    add$(left: number, top: number, right: number, bottom: number) {
        return add$(this, left, top, right, bottom);
    }

    /**
     * Subtracts the other Rect from this Rect componentwise.
     */
    subtract(other: Rect) {
        return subtract(this, other);
    }

    /**
     * Subtracts the specified values from this Rect componentwise.
     */
    subtract$(left: number, top: number, right: number, bottom: number) {
        return subtract$(this, left, top, right, bottom);
    }

    /**
     * Multiplies each component of this Rect by the specified scalar.
     */
    mulScalar(k: number) {
        return mulScalar(this, k);
    }

    /**
     * Divides each component of this Rect by the specified scalar.
     */
    divScalar(k: number) {
        return divScalar(this, k);
    }

    /**
     * Checks if each component of this Rect is equal to that of the other Rect.
     */
    equals(other: Rect) {
        return equals(this, other);
    }

    /**
     * Checks if each component of this Rect is equal to the specified scalar.
     */
    equalsScalar(k: number) {
        return equalsScalar(this, k);
    }

    /**
     * Checks if each component of this Rect is approximately equal to that of the other Rect.
     */
    epsilonEquals(other: Rect, e: number) {
        return epsilonEquals(this, other, e);
    }

    /**
     * Checks if each component of this Rect is approximately equal to the specified scalar.
     */
    epsilonEqualsScalar(k: number, e: number) {
        return epsilonEqualsScalar(this, k, e);
    }

    /**
     * Returns a string representation of this Rect.
     */
    toString() {
        return toString(this);
    }

    /**
     * Sets the boundaries of this Rect in left-top-right-bottom order.
     */
    setLtrb(left: number, top: number, right: number, bottom: number) {
        return setLtrb(this, left, top, right, bottom);
    }

    /**
     * Sets the boundaries of this Rect in left-bottom-right-top order.
     */
    setLbrt(left: number, bottom: number, right: number, top: number) {
        return setLbrt(this, left, bottom, right, top);
    }

    /**
     * Sets the boundaries of this Rect in left-right-bottom-top order.
     */
    setLrbt(left: number, right: number, bottom: number, top: number) {
        return setLrbt(this, left, right, bottom, top);
    }

    /**
     * Sets the dimensions of this rect in left-top-width-height order.
     */
    setLtwh(left: number, top: number, width: number, height: number) {
        return setLtwh(this, left, top, width, height);
    }

    /**
     * Sets the dimensions of this rect in left-bottom-width-height order.
     */
    setLbwh(left: number, bottom: number, width: number, height: number) {
        return setLbwh(this, left, bottom, width, height);
    }

    /**
     * Checks if this Rect is empty. True if left >= right or bottom >= top.
     */
    isEmpty() {
        return isEmpty(this);
    }

    /**
     * Checks if the boundaries of this Rect represent a valid rectangle. True if right >= left and top >= bottom.
     */
    isValid() {
        return isValid(this);
    }

    /**
     * Computes the width of this Rect.
     */
    width() {
        return width(this);
    }

    /**
     * Computes the height of this Rect.
     */
    height() {
        return height(this);
    }

    /**
     * Computes the area of this Rect.
     */
    area() {
        return area(this);
    }

    /**
     * Finds the x-coordinate of the point at the center of this Rect.
     */
    centerX() {
        return centerX(this);
    }

    /**
     * Finds the y-coordinate of the point at the center of this Rect.
     */
    centerY() {
        return centerY(this);
    }

    /**
     * Sets the specified point to the point at the center of this Rect
     */
    center(dst: Point._) {
        return center(this, dst);
    }

    /**
     * Sets the specified point to the point between the top left and top right corners of this Rect.
     */
    centerTop(dst: Point._) {
        return centerTop(this, dst);
    }

    /**
     *  Sets the specified point to the point between the bottom left and bottom right corners of this Rect.
     */
    centerBottom(dst: Point._) {
        return centerBottom(this, dst);
    }

    /**
     * Sets the specified point to the point between the top and bottom left corners of this Rect.
     */
    centerLeft(dst: Point._) {
        return centerLeft(this, dst);
    }

    /**
     * Sets the specified point to the point between the top and bottom right corners of this Rect.
     */
    centerRight(dst: Point._) {
        return centerRight(this, dst);
    }

    /**
     * Sets the specified point to the point at the bottom left corner of this Rect.
     */
    bottomLeft(dst: Point._) {
        return bottomLeft(this, dst);
    }

    /**
     * Sets the specified point to the point at the bottom right corner of this Rect.
     */
    bottomRight(dst: Point._) {
        return bottomRight(this, dst);
    }

    /**
     * Sets the specified point to the point at the top left corner of this Rect.
     */
    topLeft(dst: Point._) {
        return topLeft(this, dst);
    }

    /**
     * Sets the specified point to the point at the top right corner of this Rect.
     */
    topRight(dst: Point._) {
        return topRight(this, dst);
    }

    /**
     * Sets this Rect to the empty rect (0,0,0,0).
     */
    empty() {
        return empty(this);
    }

    /**
     * Sets this Rect to the smallest rectangle containing the two specified points.
     */
    setUnionOfPoints(points: Point._[], offset = 0, count = points.length) {
        return setUnionOfPoints(this, points, offset, count);
    }

    /**
     * Sets this Rect to the smallest rectangle containing a subset of points in the specified array.
     * @param points array of points entered as a series of (x,y) coordinates.
     * @param offset offset of the first point in the subset.
     * @param count number of points in the subset.
     */
    setUnionOfPoints$(points: Float32Array, offset = 0, count = points.length >> 1) {
        return setUnionOfPoints$(this, points, offset, count);
    }

    /**
     * Checks if this Rect contains the other Rect.
     */
    contains(other: Rect) {
        return contains(this, other);
    }

    /**
     * Checks if this Rect contains the specified point.
     */
    containsPoint(p: Point._) {
        return containsPoint(this, p);
    }

    /**
     * Checks if this Rect contains the point (x,y).
     */
    containsPoint$(x: number, y: number) {
        return containsPoint$(this, x, y);
    }

    /**
     * Checks if this Rect intersects the other Rect.
     */
    intersects(other: Rect) {
        return intersects(this, other);
    }

    /**
     * Sets this Rect to the intersection of itself with the other Rect.
     */
    intersect(other: Rect) {
        return intersect(this, other);
    }

    /**
     * Expands this Rect to enclose the other Rect.
     */
    union(other: Rect) {
        return union(this, other);
    }

    /**
     * Expands this Rect to enclose the specified point.
     */
    unionPoint(p: Point._) {
        return unionPoint(this, p);
    }

    /**
     * Expands this Rect to enclose the point (x,y).
     */
    unionPoint$(x: number, y: number) {
        return unionPoint$(this, x, y);
    }

    /**
     * Expands this Rect to enclose the specified points
     * @param points array of points.
     * @param offset offset of the first point in the subset.
     * @param count number of points in the subset.
     */
    unionPoints(points: Point._[], offset = 0, count = points.length) {
        return unionPoints(this, points, offset, count);
    }

    /**
     * Expands this Rect to enclose the specified points
     * @param points array of points entered as a series of (x,y) coordinates.
     * @param offset offset of the first point in the subset.
     * @param count number of points in the subset.
     */
    unionPoints$(points: Float32Array, offset = 0, count = points.length >> 1) {
        return unionPoints$(this, points, offset, count);
    }

    /**
     * Insets the boundaries of this Rect by the vector (dx,dy).
     */
    inset(dx: number, dy: number) {
        return inset(this, dx, dy);
    }

    /**
     * Offsets the boundaries of this Rect by the vector (dx,dy).
     */
    offset(dx: number, dy: number) {
        return offset(this, dx, dy);
    }

    /**
     * Scales this Rect out from it's center by the specified (sx,sy) percentages.
     * @param r the Rect to scale.
     * @param sx the percentage by which to scale in the horizontal direction.
     * @param sy the percentage by which to scale in the vertical direction.
     */
    scale(sx: number, sy: number) {
        return scale(this, sx, sy);
    }

    /**
     * Stretches this Rect out from it's center by the specified ratio, maintaining aspect.
     * @param ratio the percentage by which to stretch in all directions.
     */
    stretch(ratio: number) {
        return stretch(this, ratio);
    }

    /**
     * Shrinks this Rect to a square with the same center point.
     */
    shrinkToSquare() {
        return shrinkToSquare(this);
    }

    /**
     * Expands this Rect to a square with the same center point.
     */
    expandToSquare() {
        return expandToSquare(this);
    }

    /**
     * Swaps the top/bottom or left/right boundaries of this Rect if they are flipped, meaning left > right and/or top > bottom.
     */
    sort() {
        return sort(this);
    }
}

/**
 * A Rect buffer backed by a Float32Array.
 */
export class Buf extends StructureBuffer<Float32Array> {
    /**
     * Creates an empty Rect buffer with the specified Rect capacity.
     */
    static create(capacity: number) {
        return new Buf(new Float32Array(capacity * 4));
    }

    /**
     * The left boundary of the current Rect.
     */
    get left() {
        return this.data[this.dataPosition + 0];
    }

    /**
     * The left boundary of the current Rect.
     */
    set left(value: number) {
        this.data[this.dataPosition + 0] = value;
    }

    /**
     * The top boundary of the current Rect.
     */
    get top() {
        return this.data[this.dataPosition + 1];
    }

    /**
     * The top boundary of the current Rect.
     */
    set top(value: number) {
        this.data[this.dataPosition + 1] = value;
    }

    /**
     * The right boundary of the current Rect.
     */
    get right() {
        return this.data[this.dataPosition + 2];
    }

    /**
     * The right boundary of the current Rect.
     */
    set right(value: number) {
        this.data[this.dataPosition + 2] = value;
    }

    /**
     * The bottom boundary of the current Rect.
     */
    get bottom() {
        return this.data[this.dataPosition + 3];
    }

    /**
     * The bottom boundary of the current Rect.
     */
    set bottom(value: number) {
        this.data[this.dataPosition + 3] = value;
    }

    /**
     * Gets the number of components in a Rect, namely 4.
     */
    structLength() {
        return 4;
    }

    /**
     * Sets each component of the Rect at the specified position.
     */
    set$(position: number, left: number, top: number, right: number, bottom: number) {
        let dataPos = position * this.structLength();
        this.data[dataPos++] = left;
        this.data[dataPos++] = top;
        this.data[dataPos++] = right;
        this.data[dataPos++] = bottom;
    }

    /**
     * Sets each component of the current Rect, then moves to the next position of this buffer.
     */
    put$(left: number, top: number, right: number, bottom: number) {
        this.data[this.dataPosition++] = left;
        this.data[this.dataPosition++] = top;
        this.data[this.dataPosition++] = right;
        this.data[this.dataPosition++] = bottom;
    }

    /**
     * Sets each component of the current Rect to that of the other Rect.
     */
    $set(other: Rect) {
        return set(this, other);
    }

    /**
     * Sets each component of the current Rect.
     */
    $set$(left: number, top: number, right: number, bottom: number) {
        return set$(this, left, top, right, bottom);
    }

    /**
     * Adds the other Rect to the current Rect componentwise.
     */
    $add(other: Rect) {
        return add(this, other);
    }

    /**
     * Adds the specified values to the current Rect componentwise.
     */
    $add$(left: number, top: number, right: number, bottom: number) {
        return add$(this, left, top, right, bottom);
    }

    /**
     * Subtracts the other Rect from the current Rect componentwise.
     */
    $subtract(other: Rect) {
        return subtract(this, other);
    }

    /**
     * Subtracts the specified values from the current Rect componentwise.
     */
    $subtract$(left: number, top: number, right: number, bottom: number) {
        return subtract$(this, left, top, right, bottom);
    }

    /**
     * Multiplies each component of the current Rect by the specified scalar.
     */
    $mulScalar(k: number) {
        return mulScalar(this, k);
    }

    /**
     * Divides each component of the current Rect by the specified scalar.
     */
    $divScalar(k: number) {
        return divScalar(this, k);
    }

    /**
     * Checks if each component of the current Rect is equal to that of the other Rect.
     */
    $equals(other: Rect) {
        return equals(this, other);
    }

    /**
     * Checks if each component of the current Rect is equal to the specified scalar.
     */
    $equalsScalar(k: number) {
        return equalsScalar(this, k);
    }

    /**
     * Checks if each component of the current Rect is approximately equal to that of the other Rect.
     */
    $epsilonEquals(other: Rect, e: number) {
        return epsilonEquals(this, other, e);
    }

    /**
     * Checks if each component of the current Rect is approximately equal to the specified scalar.
     */
    $epsilonEqualsScalar(k: number, e: number) {
        return epsilonEqualsScalar(this, k, e);
    }

    /**
     * Returns a string representation of the current Rect.
     */
    $toString() {
        return toString(this);
    }

    /**
     * Sets the boundaries of the current Rect in left-top-right-bottom order.
     */
    $setLtrb(left: number, top: number, right: number, bottom: number) {
        return setLtrb(this, left, top, right, bottom);
    }

    /**
     * Sets the boundaries of the current Rect in left-bottom-right-top order.
     */
    $setLbrt(left: number, bottom: number, right: number, top: number) {
        return setLbrt(this, left, bottom, right, top);
    }

    /**
     * Sets the boundaries of the current Rect in left-right-bottom-top order.
     */
    $setLrbt(left: number, right: number, bottom: number, top: number) {
        return setLrbt(this, left, right, bottom, top);
    }

    /**
     * Sets the dimensions of this rect in left-top-width-height order.
     */
    $setLtwh(left: number, top: number, width: number, height: number) {
        return setLtwh(this, left, top, width, height);
    }

    /**
     * Sets the dimensions of this rect in left-bottom-width-height order.
     */
    $setLbwh(left: number, bottom: number, width: number, height: number) {
        return setLbwh(this, left, bottom, width, height);
    }

    /**
     * Checks if the current Rect is empty. True if left >= right or bottom >= top.
     */
    $isEmpty() {
        return isEmpty(this);
    }

    /**
     * Checks if the boundaries of the current Rect represent a valid rectangle. True if right >= left and top >= bottom.
     */
    $isValid() {
        return isValid(this);
    }

    /**
     * Computes the width of the current Rect.
     */
    $width() {
        return width(this);
    }

    /**
     * Computes the height of the current Rect.
     */
    $height() {
        return height(this);
    }

    /**
     * Computes the area of the current Rect.
     */
    $area() {
        return area(this);
    }

    /**
     * Finds the x-coordinate of the point at the center of the current Rect.
     */
    $centerX() {
        return centerX(this);
    }

    /**
     * Finds the y-coordinate of the point at the center of the current Rect.
     */
    $centerY() {
        return centerY(this);
    }

    /**
     * Sets the specified point to the point at the center of the current Rect
     */
    $center(dst: Point._) {
        return center(this, dst);
    }

    /**
     * Sets the specified point to the point between the top left and top right corners of the current Rect.
     */
    $centerTop(dst: Point._) {
        return centerTop(this, dst);
    }

    /**
     *  Sets the specified point to the point between the bottom left and bottom right corners of the current Rect.
     */
    $centerBottom(dst: Point._) {
        return centerBottom(this, dst);
    }

    /**
     * Sets the specified point to the point between the top and bottom left corners of the current Rect.
     */
    $centerLeft(dst: Point._) {
        return centerLeft(this, dst);
    }

    /**
     * Sets the specified point to the point between the top and bottom right corners of the current Rect.
     */
    $centerRight(dst: Point._) {
        return centerRight(this, dst);
    }

    /**
     * Sets the specified point to the point at the bottom left corner of the current Rect.
     */
    $bottomLeft(dst: Point._) {
        return bottomLeft(this, dst);
    }

    /**
     * Sets the specified point to the point at the bottom right corner of the current Rect.
     */
    $bottomRight(dst: Point._) {
        return bottomRight(this, dst);
    }

    /**
     * Sets the specified point to the point at the top left corner of the current Rect.
     */
    $topLeft(dst: Point._) {
        return topLeft(this, dst);
    }

    /**
     * Sets the specified point to the point at the top right corner of the current Rect.
     */
    $topRight(dst: Point._) {
        return topRight(this, dst);
    }

    /**
     * Sets the current Rect to the empty rect (0,0,0,0).
     */
    $empty() {
        return empty(this);
    }

    /**
     * Sets the current Rect to the smallest rectangle containing the two specified points.
     */
    $setUnionOfPoints(points: Point._[], offset: number, count: number) {
        return setUnionOfPoints(this, points, offset, count);
    }

    /**
     * Sets the current Rect to the smallest rectangle containing a subset of points in the specified array.
     * @param points array of points entered as a series of (x,y) coordinates.
     * @param offset offset of the first point in the subset.
     * @param count number of points in the subset.
     */
    $setUnionOfPoints$(points: Float32Array, offset: number, count: number) {
        return setUnionOfPoints$(this, points, offset, count);
    }

    /**
     * Checks if the current Rect contains the other Rect.
     */
    $contains(other: Rect) {
        return contains(this, other);
    }

    /**
     * Checks if the current Rect contains the specified point.
     */
    $containsPoint(p: Point._) {
        return containsPoint(this, p);
    }

    /**
     * Checks if the current Rect contains the point (x,y).
     */
    $containsPoint$(x: number, y: number) {
        return containsPoint$(this, x, y);
    }

    /**
     * Checks if the current Rect intersects the other Rect.
     */
    $intersects(other: Rect) {
        return intersects(this, other);
    }

    /**
     * Sets the current Rect to the intersection of itself with the other Rect.
     */
    $intersect(other: Rect) {
        return intersect(this, other);
    }

    /**
     * Expands the current Rect to enclose the other Rect.
     */
    $union(other: Rect) {
        return union(this, other);
    }

    /**
     * Expands the current Rect to enclose the specified point.
     */
    $unionPoint(p: Point._) {
        return unionPoint(this, p);
    }

    /**
     * Expands the current Rect to enclose the point (x,y).
     */
    $unionPoint$(x: number, y: number) {
        return unionPoint$(this, x, y);
    }

    /**
     * Expands the current Rect to enclose the specified points
     * @param points array of points.
     * @param offset offset of the first point in the subset.
     * @param count number of points in the subset.
     */
    $unionPoints(points: Point._[], offset: number, count: number) {
        return unionPoints(this, points, offset, count);
    }

    /**
     * Expands the current Rect to enclose the specified points
     * @param points array of points entered as a series of (x,y) coordinates.
     * @param offset offset of the first point in the subset.
     * @param count number of points in the subset.
     */
    $unionPoints$(points: Float32Array, offset: number, count: number) {
        return unionPoints$(this, points, offset, count);
    }

    /**
     * Insets the boundaries of the current Rect by the vector (dx,dy).
     */
    $inset(dx: number, dy: number) {
        return inset(this, dx, dy);
    }

    /**
     * Offsets the boundaries of the current Rect by the vector (dx,dy).
     */
    $offset(dx: number, dy: number) {
        return offset(this, dx, dy);
    }

    /**
     * Scales the current Rect out from it's center by the specified (sx,sy) percentages.
     * @param r the Rect to scale.
     * @param sx the percentage by which to scale in the horizontal direction.
     * @param sy the percentage by which to scale in the vertical direction.
     */
    $scale(sx: number, sy: number) {
        return scale(this, sx, sy);
    }

    /**
     * Stretches the current Rect out from it's center by the specified ratio, maintaining aspect.
     * @param ratio the percentage by which to stretch in all directions.
     */
    $stretch(ratio: number) {
        return stretch(this, ratio);
    }

    /**
     * Shrinks the current Rect to a square with the same center point.
     */
    $shrinkToSquare() {
        return shrinkToSquare(this);
    }

    /**
     * Expands the current Rect to a square with the same center point.
     */
    $expandToSquare() {
        return expandToSquare(this);
    }

    /**
     * Swaps the top/bottom or left/right boundaries of the current Rect if they are flipped, meaning left > right and/or top > bottom.
     */
    $sort() {
        return sort(this);
    }
}
