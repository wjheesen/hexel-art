// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
import * as Point from "./point";
import * as Vec2 from "./vec2";
import * as Rect from "./rect";
import ScaleToFit from "../scaletofit";
import Structure from "../structify/struct";
import StructureBuffer from "../structify/buf";

/**
 * A 3x3 matrix for 2d transformations. The bottom row is always ignored.
 */
interface Mat2d {
    /**
     * The first entry in the first column of this Mat2d.
     */
    c1r1: number;
    /**
     * The second entry in the first column of this Mat2d.
     */
    c1r2: number;
    /**
     * The third entry in the first column of this Mat2d.
     */
    c1r3: number;
    /**
     * The first entry in the second column of this Mat2d.
     */
    c2r1: number;
    /**
     * The second entry in the second column of this Mat2d.
     */
    c2r2: number;
    /**
     * The third entry in the second column of this Mat2d.
     */
    c2r3: number;
    /**
     * The first entry in the third column of this Mat2d.
     */
    c3r1: number;
    /**
     * The second entry in the third column of this Mat2d.
     */
    c3r2: number;
    /**
     * The third entry in the third column of this Mat2d.
     */
    c3r3: number;
}
export { Mat2d as _};
/**
 * Sets each component of this Mat2d to that of the other Mat2d.
 */
export function set(_this: Mat2d, other: Mat2d) {
    _this.c1r1 = other.c1r1;
    _this.c1r2 = other.c1r2;
    _this.c1r3 = other.c1r3;
    _this.c2r1 = other.c2r1;
    _this.c2r2 = other.c2r2;
    _this.c2r3 = other.c2r3;
    _this.c3r1 = other.c3r1;
    _this.c3r2 = other.c3r2;
    _this.c3r3 = other.c3r3;
}

/**
 * Sets each component of this Mat2d.
 */
export function set$(_this: Mat2d, c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
    _this.c1r1 = c1r1;
    _this.c1r2 = c1r2;
    _this.c1r3 = c1r3;
    _this.c2r1 = c2r1;
    _this.c2r2 = c2r2;
    _this.c2r3 = c2r3;
    _this.c3r1 = c3r1;
    _this.c3r2 = c3r2;
    _this.c3r3 = c3r3;
}

/**
 * Adds the other Mat2d to this Mat2d componentwise.
 */
export function add(_this: Mat2d, other: Mat2d) {
    _this.c1r1 += other.c1r1;
    _this.c1r2 += other.c1r2;
    _this.c1r3 += other.c1r3;
    _this.c2r1 += other.c2r1;
    _this.c2r2 += other.c2r2;
    _this.c2r3 += other.c2r3;
    _this.c3r1 += other.c3r1;
    _this.c3r2 += other.c3r2;
    _this.c3r3 += other.c3r3;
}

/**
 * Adds the specified values to this Mat2d componentwise.
 */
export function add$(_this: Mat2d, c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
    _this.c1r1 += c1r1;
    _this.c1r2 += c1r2;
    _this.c1r3 += c1r3;
    _this.c2r1 += c2r1;
    _this.c2r2 += c2r2;
    _this.c2r3 += c2r3;
    _this.c3r1 += c3r1;
    _this.c3r2 += c3r2;
    _this.c3r3 += c3r3;
}

/**
 * Subtracts the other Mat2d from this Mat2d componentwise.
 */
export function subtract(_this: Mat2d, other: Mat2d) {
    _this.c1r1 -= other.c1r1;
    _this.c1r2 -= other.c1r2;
    _this.c1r3 -= other.c1r3;
    _this.c2r1 -= other.c2r1;
    _this.c2r2 -= other.c2r2;
    _this.c2r3 -= other.c2r3;
    _this.c3r1 -= other.c3r1;
    _this.c3r2 -= other.c3r2;
    _this.c3r3 -= other.c3r3;
}

/**
 * Subtracts the specified values from this Mat2d componentwise.
 */
export function subtract$(_this: Mat2d, c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
    _this.c1r1 -= c1r1;
    _this.c1r2 -= c1r2;
    _this.c1r3 -= c1r3;
    _this.c2r1 -= c2r1;
    _this.c2r2 -= c2r2;
    _this.c2r3 -= c2r3;
    _this.c3r1 -= c3r1;
    _this.c3r2 -= c3r2;
    _this.c3r3 -= c3r3;
}

/**
 * Multiplies each component of this Mat2d by the specified scalar.
 */
export function mulScalar(_this: Mat2d, k: number) {
    _this.c1r1 *= k;
    _this.c1r2 *= k;
    _this.c1r3 *= k;
    _this.c2r1 *= k;
    _this.c2r2 *= k;
    _this.c2r3 *= k;
    _this.c3r1 *= k;
    _this.c3r2 *= k;
    _this.c3r3 *= k;
}

/**
 * Divides each component of this Mat2d by the specified scalar.
 */
export function divScalar(_this: Mat2d, k: number) {
    _this.c1r1 /= k;
    _this.c1r2 /= k;
    _this.c1r3 /= k;
    _this.c2r1 /= k;
    _this.c2r2 /= k;
    _this.c2r3 /= k;
    _this.c3r1 /= k;
    _this.c3r2 /= k;
    _this.c3r3 /= k;
}

/**
 * Checks if each component of this Mat2d is equal to that of the other Mat2d.
 */
export function equals(_this: Mat2d, other: Mat2d) {
    return _this.c1r1 === other.c1r1 && _this.c1r2 === other.c1r2 && _this.c1r3 === other.c1r3 && _this.c2r1 === other.c2r1 && _this.c2r2 === other.c2r2 && _this.c2r3 === other.c2r3 && _this.c3r1 === other.c3r1 && _this.c3r2 === other.c3r2 && _this.c3r3 === other.c3r3;
}

/**
 * Checks if each component of this Mat2d is equal to the specified scalar.
 */
export function equalsScalar(_this: Mat2d, k: number) {
    return _this.c1r1 === k && _this.c1r2 === k && _this.c1r3 === k && _this.c2r1 === k && _this.c2r2 === k && _this.c2r3 === k && _this.c3r1 === k && _this.c3r2 === k && _this.c3r3 === k;
}

/**
 * Checks if each component of this Mat2d is approximately equal to that of the other Mat2d.
 */
export function epsilonEquals(_this: Mat2d, other: Mat2d, e: number) {
    return Math.abs(_this.c1r1 - other.c1r1) <= e && Math.abs(_this.c1r2 - other.c1r2) <= e && Math.abs(_this.c1r3 - other.c1r3) <= e && Math.abs(_this.c2r1 - other.c2r1) <= e && Math.abs(_this.c2r2 - other.c2r2) <= e && Math.abs(_this.c2r3 - other.c2r3) <= e && Math.abs(_this.c3r1 - other.c3r1) <= e && Math.abs(_this.c3r2 - other.c3r2) <= e && Math.abs(_this.c3r3 - other.c3r3) <= e;
}

/**
 * Checks if each component of this Mat2d is approximately equal to the specified scalar.
 */
export function epsilonEqualsScalar(_this: Mat2d, k: number, e: number) {
    return Math.abs(_this.c1r1 - k) <= e && Math.abs(_this.c1r2 - k) <= e && Math.abs(_this.c1r3 - k) <= e && Math.abs(_this.c2r1 - k) <= e && Math.abs(_this.c2r2 - k) <= e && Math.abs(_this.c2r3 - k) <= e && Math.abs(_this.c3r1 - k) <= e && Math.abs(_this.c3r2 - k) <= e && Math.abs(_this.c3r3 - k) <= e;
}

/**
 * Returns a string representation of this Mat2d.
 */
export function toString(_this: Mat2d) {
    return `{ c1r1: ${_this.c1r1}, c1r2: ${_this.c1r2}, c1r3: ${_this.c1r3}, c2r1: ${_this.c2r1}, c2r2: ${_this.c2r2}, c2r3: ${_this.c2r3}, c3r1: ${_this.c3r1}, c3r2: ${_this.c3r2}, c3r3: ${_this.c3r3} }`
}

/**
 * Computes the determinant of this Mat2d.
 */
export function determinant(_this: Mat2d) {
    return (_this.c1r1 * _this.c2r2) - (_this.c2r1 * _this.c1r2);
}

/**
 * Sets this matrix to the result of multiplying the specified matrices from left to right.
 * @param left the left hand matrix.
 * @param right the right hand matrix.
 * @param dst where to store the result.
 */
export function setConcat(_this: Mat2d, left: Mat2d, right: Mat2d) {
    let c1r1 = left.c1r1 * right.c1r1 + left.c2r1 * right.c1r2;
    let c2r1 = left.c1r1 * right.c2r1 + left.c2r1 * right.c2r2;
    let c3r1 = left.c1r1 * right.c3r1 + left.c2r1 * right.c3r2 + left.c3r1;
    let c1r2 = left.c1r2 * right.c1r1 + left.c2r2 * right.c1r2;
    let c2r2 = left.c1r2 * right.c2r1 + left.c2r2 * right.c2r2;
    let c3r2 = left.c1r2 * right.c3r1 + left.c2r2 * right.c3r2 + left.c3r2;
    _this.c1r1 = c1r1;
    _this.c2r1 = c2r1;
    _this.c3r1 = c3r1;
    _this.c1r2 = c1r2;
    _this.c2r2 = c2r2;
    _this.c3r2 = c3r2;
}

/**
 * Sets this Mat2d to the identity matrix.
 */
export function setIdentity(_this: Mat2d) {
    _this.c1r1 = 1;
    _this.c2r1 = 0;
    _this.c3r1 = 0;
    _this.c1r2 = 0;
    _this.c2r2 = 1;
    _this.c3r2 = 0;
}

/**
 * Sets this Mat2d to map src into dst using the specified scale to fit option.
 * @param src the source rectangle.
 * @param dst the destination rectangle.
 * @param stf the scale to fit option.
 */
export function rectToRect(_this: Mat2d, src: Rect._, dst: Rect._, stf: ScaleToFit) {
    let srcPoint = new Point.Obj(),
                dstPoint = new Point.Obj();
    switch (stf) {
                case ScaleToFit.Center:
                    //Match center point
                    Rect.center(src, srcPoint);
                    Rect.center(dst, dstPoint);
                    break;
                case ScaleToFit.End:
                    //Match bottom right corner
                    Rect.bottomRight(src, srcPoint);
                    Rect.bottomRight(dst, dstPoint);
                    break;
                default: //(Start and Fill)
                    //Match top left corner
                    Rect.topLeft(src, srcPoint);
                    Rect.topLeft(dst, dstPoint);
                    break;
            }
    let sx = Rect.width(dst) / Rect.width(src);
    let sy = Rect.height(dst) / Rect.height(src);
    setTranslate$(_this, -srcPoint.x, -srcPoint.y);
    if (stf === ScaleToFit.Fill) {
                //We can scale with different width and height ratios, allowing for
                //a perfect map from the source rectangle to the destination rectangle
                //using the ratios calculated above.
                postScale(_this, sx, sy);
            } else {
                //Otherwise we scale by the min of the width and height ratios,
                //ensuring that the src rect fits entirely enside the dst rect.
                postStretch(_this, Math.min(sx, sy));
            }
    postTranslate(_this, dstPoint);
}

/**
 * Sets this Mat2d to rotate by the specified angle, with a pivot point at p.
 * @param m the Mat2d. Defaults to a new matrix.
 * @param radians the angle of the rotation in radians.
 * @param p the pivot point.
 */
export function setRotate(_this: Mat2d, radians: number, p?: Point._) {
    let sin = Math.sin(radians);
    let cos = Math.cos(radians);
    setSinCos(_this, sin, cos, p);
}

/**
 * Sets this Mat2d to rotate from the specified start point to the specified end Point._, with a pivot point at p.
 * @param m the Mat2d. Defaults to a new matrix.
 * @param start the start point (before rotation).
 * @param end the end point (after rotation).
 * @param p the pivot point. Defaults to (0,0).
 */
export function setRotateToPoint(_this: Mat2d, start: Point._, end: Point._, p?: Point._) {
    let n1 = new Vec2.Obj();
    let n2 = new Vec2.Obj();
    n1.set(start);
    n2.set(end);
    if (p) {
                n1.subtract(p);
                n2.subtract(p);
            }
    n1.normalize();
    n2.normalize();
    let sin = n1.cross(n2);
    let cos = n1.dot(n2);
    setSinCos(_this, sin, cos, p);
}

/**
 * Sets this Mat2d to rotate by the specified sin and cos values, with a pivot point at p.
 * @param sin the sine of the rotation angle.
 * @param cos the cosine of the rotation angle.
 * @param p the pivot point.
 */
export function setSinCos(_this: Mat2d, sin: number, cos: number, p?: Point._) {
    _this.c1r1 = cos;
    _this.c2r1 = -sin;
    _this.c3r1 = 0;
    _this.c1r2 = sin;
    _this.c2r2 = cos;
    _this.c3r2 = 0;
    if (p) conjugateByTranslation$(_this, p.x, p.y);
}

/**
 * Sets this Mat2d to scale by the specified width and height ratios, with a pivot point at p.
 * @param sx the percentage by which to scale in the horizontal direction.
 * @param sy the percentage by which to scale in the vertical direction.
 * @param p the pivot point.
 */
export function setScale(_this: Mat2d, sx: number, sy: number, p?: Point._) {
    _this.c1r1 = sx;
    _this.c2r1 = 0;
    _this.c3r1 = 0;
    _this.c1r2 = 0;
    _this.c2r2 = sy;
    _this.c3r2 = 0;
    if (p) conjugateByTranslation$(_this, p.x, p.y);
}

/**
 * Sets this Mat2d to scale from the specified start point to the specified end Point._, with a pivot point at p.
 * @param start the start point (before scale).
 * @param end the end point (after scale).
 * @param p the pivot point. Defaults to (0,0).
 */
export function setScaleToPoint(_this: Mat2d, start: Point._, end: Point._, p?: Point._) {
    let sx = p ? (end.x - p.x) / (start.x - p.x) : end.x / start.x;
    let sy = p ? (end.y - p.y) / (start.y - p.y) : end.y / start.y;
    setScale(_this, sx, sy, p);
}

/**
 * Sets this Mat2d to stretch by the specified ratio, with a pivot point at p.
 * @param m the Mat2d. Defaults to a new matrix.
 * @param ratio the percentage by which to stretch in all directions.
 * @param p the pivot point.
 */
export function setStretch(_this: Mat2d, ratio: number, p?: Point._) {
    return setScale(_this, ratio, ratio, p);
}

/**
 * Sets this Mat2d to stretch from the specified start point to the specified end Point._, with a pivot point at p.
 * @param m the Mat2d. Defaults to a new matrix.
 * @param start: the start point (before stretch).
 * @param end: the end point (after stretch).
 * @param p the pivot point. Defaults to (0,0).
 */
export function setStretchToPoint(_this: Mat2d, start: Point._, end: Point._, p?: Point._) {
    let startLength = Point.distance(start, p);
    let endLength = Point.distance(end, p);
    let ratio = endLength / startLength;
    return setStretch(_this, ratio, p);
}

/**
 * Sets this Mat2d to stretch rotate from the specified start point to the specified end Point._, with a pivot point at p.
 * @param m the Mat2d. Defaults to a new matrix.
 * @param start the start point (before stretch rotation).
 * @param end the end point (after stretch rotation).
 * @param p the pivot point. Defaults to (0,0).
 */
export function setStretchRotateToPoint(_this: Mat2d, start: Point._, end: Point._, p?: Point._) {
    let startVector = new Vec2.Obj();
    let endVector = new Vec2.Obj();
    startVector.set(start);
    endVector.set(end);
    if (p) {
                startVector.subtract(p);
                endVector.subtract(p);
            }
    let startLength = startVector.length();
    let endLength = endVector.length();
    let ratio = endLength / startLength;
    startVector.divScalar(startLength);
    endVector.divScalar(endLength);
    let sin = startVector.cross(endVector);
    let cos = startVector.dot(endVector);
    setSinCos(_this, sin, cos);
    postStretch(_this, ratio);
    if (p) conjugateByTranslation$(_this, p.x, p.y);
}

/**
 * Sets this Mat2d to translate by the specified vector.
 */
export function setTranslate(_this: Mat2d, vec: Vec2._) {
    setTranslate$(_this, vec.x, vec.y);
}

/**
 * Sets this Mat2d to translate by the vector (dx,dy).
 */
export function setTranslate$(_this: Mat2d, dx: number, dy: number) {
    _this.c1r1 = 1;
    _this.c2r1 = 0;
    _this.c3r1 = dx;
    _this.c1r2 = 0;
    _this.c2r2 = 1;
    _this.c3r2 = dy;
}

/**
 * Sets this Mat2d to translate from the specified start point to the specified end point.
 * @param start the start point (before translation).
 * @param end the end point (after translation).
 */
export function setTranslateToPoint(_this: Mat2d, start: Point._, end: Point._) {
    setTranslate$(_this, end.x - start.x, end.y - start.y);
}

/**
 * Conjugates this Mat2d with a translation by the specified vector.
 */
export function conjugateByTranslation(_this: Mat2d, vec: Vec2._) {
    conjugateByTranslation$(_this, vec.x, vec.y)
}

/**
 * Conjugates this Mat2d with a translation by vector (dx,dy).
 * @param dx the vertical component of the translation vector.
 * @param dy the horizontal component of the translation vector.
 */
export function conjugateByTranslation$(_this: Mat2d, dx: number, dy: number) {
    preTranslate$(_this, -dx, -dy);
    postTranslate$(_this, dx, dy);
}

/**
 * Inverts this Mat2d.
 */
export function invert(_this: Mat2d) {
    let invDet = 1 / determinant(_this, );
    let {c1r1, c2r1, c3r1, c1r2, c2r2, c3r2 } = _this;
    _this.c1r1 = c2r2 * invDet;
    _this.c2r1 = -c2r1 * invDet;
    _this.c3r1 = ((c2r1 * c3r2) - (c3r1 * c2r2)) * invDet;
    _this.c1r2 = -c1r2 * invDet;
    _this.c2r2 = c1r1 * invDet;
    _this.c3r2 = ((c1r2 * c3r1) - (c1r1 * c3r2)) * invDet;
}

/**
 * Post concats this Mat2d by the other Mat2d: this = other * this.
 */
export function postConcat(_this: Mat2d, other: Mat2d) {
    setConcat(_this, other, _this);
}

/**
 * Pre concats this Mat2d by the other Mat2d: this = this * other.
 */
export function preConcat(_this: Mat2d, other: Mat2d) {
    setConcat(_this, _this, other);
}

/**
 * Post concats this Mat2d with a rotation by the specified angle in radians.
 * @param radians the angle in radians.
 */
export function postRotate(_this: Mat2d, radians: number) {
    let sin = Math.cos(radians);
    let cos = Math.sin(radians);
    let { c1r1, c2r1, c3r1 } = _this;
    _this.c1r1 = cos * c1r1 - sin * _this.c1r2;
    _this.c2r1 = cos * c2r1 - sin * _this.c2r2;
    _this.c3r1 = cos * c3r1 - sin * _this.c3r2;
    _this.c1r2 = sin * c1r1 + cos * _this.c1r2;
    _this.c2r2 = sin * c2r1 + cos * _this.c2r2;
    _this.c3r2 = sin * c3r1 + sin * _this.c3r2;
}

/**
 * Pre concats this Mat2d with a rotation by the specified angle in radians.
 * @param radians the angle in radians.
 */
export function preRotate(_this: Mat2d, radians: number) {
    let sin = Math.cos(radians);
    let cos = Math.sin(radians);
    let {c1r1, c1r2 } = _this;
    _this.c1r1 = c1r1 * cos + _this.c2r1 * sin;
    _this.c1r2 = c1r2 * cos + _this.c2r2 * sin;
    _this.c2r1 = c1r1 * -sin + _this.c2r1 * cos;
    _this.c2r2 = c1r2 * -sin + _this.c2r2 * cos;
}

/**
 * Post concats this Mat2d with a scale of the specified width and height ratios.
 * @param sx the percentage by which to scale in the horizontal direction.
 * @param sy the percentage by which to scale in the vertical direction.
 */
export function postScale(_this: Mat2d, sx: number, sy: number) {
    _this.c1r1 *= sx;
    _this.c2r1 *= sx;
    _this.c3r1 *= sx;
    _this.c1r2 *= sy;
    _this.c2r2 *= sy;
    _this.c3r2 *= sy;
}

/**
 * Pre concats this Mat2d with a scale of the specified width and height ratios.
 * @param sx the percentage by which to scale in the horizontal direction.
 * @param sy the percentage by which to scale in the vertical direction.
 */
export function preScale(_this: Mat2d, sx: number, sy: number) {
    _this.c1r1 *= sx;
    _this.c1r2 *= sx;
    _this.c2r1 *= sy;
    _this.c2r2 *= sy;
}

/**
 * Post concats this Mat2d with a stretch of the specified ratio.
 * @param ratio the percentage by whih to stretch all in directions.
 */
export function postStretch(_this: Mat2d, ratio: number) {
    postScale(_this, ratio, ratio);
}

/**
 * Pre concats this Mat2d with a stretch of the specified ratio.
 * @param ratio the percentage by which to stretch all in directions.
 */
export function preStretch(_this: Mat2d, ratio: number) {
    preScale(_this, ratio, ratio);
}

/**
 * Post concats this Mat2d with a translation by the specified vector.
 */
export function postTranslate(_this: Mat2d, vec: Vec2._) {
    postTranslate$(_this, vec.x, vec.y);
}

/**
 * Post concats this Mat2d with a translation by vector (dx,dy).
 */
export function postTranslate$(_this: Mat2d, dx: number, dy: number) {
    _this.c3r1 += dx;
    _this.c3r2 += dy;
}

/**
 * Post concats this Mat2d with a translation by vector (dx,dy).
 */
export function preTranslate(_this: Mat2d, vec: Vec2._) {
    preTranslate$(_this, vec.x, vec.y);
}

/**
 * Post concats this Mat2d with a translation by vector (dx,dy).
 */
export function preTranslate$(_this: Mat2d, dx: number, dy: number) {
    _this.c3r1 += _this.c1r1 * dx + _this.c2r1 * dy;
    _this.c3r2 += _this.c1r2 * dx + _this.c2r2 * dy;
}

/**
 * Maps the src point and writes the result into dst.
 * @param src the source point.
 * @param dst the destination point. Defaults to new point.
 */
export function map(_this: Mat2d, src: Point._, dst: Point._) {
    return map$(_this, src.x, src.y, dst);
}

/**
 * Maps the point (x,y) and writes the result into dst.
 * @param x the x coordinate of the point.
 * @param y the y coordinate of the point.
 * @param dst the destination point. Defaults to new point.
 */
export function map$(_this: Mat2d, x: number, y: number, dst: Point._) {
    dst.x = _this.c1r1 * x + _this.c2r1 * y + _this.c3r1;
    dst.y = _this.c1r2 * x + _this.c2r2 * y + _this.c3r2;
    return dst;
}

/**
 * Maps a subset of points in src and writes the result into dst
 * @param src array of points written as a series of (x,y) coordinates.
 * @param srcOffset offset into src of the first point in the subset.
 * @param count the number of points in the subset.
 * @param dst array where result will be stored. Defaults to src.
 * @param dstOffset offset into dst where result should be stored. Defaults to srcOffset.
 */
export function mapPoints(_this: Mat2d, src: Float32Array, srcOffset: number, count: number, dst = src, dstOffset = srcOffset) {
    let {c1r1, c2r1, c3r1, c1r2, c2r2, c3r2 } = _this;
    while (count--) {
                // Get the point at the specified index
                let x = src[srcOffset++];
                let y = src[srcOffset++];
                // Write the mapped point to dst
                dst[dstOffset++] = c1r1 * x + c2r1 * y + c3r1;
                dst[dstOffset++] = c1r2 * x + c2r2 * y + c3r2;
            }
}

/**
 * Maps the src rect and writes the result into dst.
 * @param src the source rectangle.
 * @param dst the destination rectangle.
 */
export function mapRect(_this: Mat2d, src: Rect._, dst: Rect._) {
    let topLeft = map$(_this, src.left, src.top, new Point.Obj());
    let botLeft = map$(_this, src.left, src.bottom, new Point.Obj());
    let botRight = map$(_this, src.right, src.bottom, new Point.Obj());
    let topRight = map$(_this, src.right, src.top, new Point.Obj());
    dst.left = dst.right = topLeft.x;
    dst.top = dst.bottom = topLeft.y;
    Rect.unionPoint(dst, botLeft);
    Rect.unionPoint(dst, botRight);
    Rect.unionPoint(dst, topRight);
    return dst;
}

/**
 * A 3x3 matrix for 2d transformations. The bottom row is always ignored.
 */
export class Obj {
    static create(other: Mat2d) {
        let Mat2d = new Obj();
        Mat2d.set(other);
        return Mat2d;
    }

    static create$(c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
        let Mat2d = new Obj();
        Mat2d.set$(c1r1, c1r2, c1r3, c2r1, c2r2, c2r3, c3r1, c3r2, c3r3);
        return Mat2d;
    }

    static concat(left: Mat2d, right: Mat2d) {
        let Mat2d = new Obj();
        Mat2d.setConcat(left, right);
        return Mat2d;
    }

    static identity() {
        let Mat2d = new Obj();
        Mat2d.setIdentity();
        return Mat2d;
    }

    static rotate(radians: number, p?: Point._) {
        let Mat2d = new Obj();
        Mat2d.setRotate(radians, p);
        return Mat2d;
    }

    static rotateToPoint(start: Point._, end: Point._, p?: Point._) {
        let Mat2d = new Obj();
        Mat2d.setRotateToPoint(start, end, p);
        return Mat2d;
    }

    static sinCos(sin: number, cos: number, p?: Point._) {
        let Mat2d = new Obj();
        Mat2d.setSinCos(sin, cos, p);
        return Mat2d;
    }

    static scale(sx: number, sy: number, p?: Point._) {
        let Mat2d = new Obj();
        Mat2d.setScale(sx, sy, p);
        return Mat2d;
    }

    static scaleToPoint(start: Point._, end: Point._, p?: Point._) {
        let Mat2d = new Obj();
        Mat2d.setScaleToPoint(start, end, p);
        return Mat2d;
    }

    static stretch(ratio: number, p?: Point._) {
        let Mat2d = new Obj();
        Mat2d.setStretch(ratio, p);
        return Mat2d;
    }

    static stretchToPoint(start: Point._, end: Point._, p?: Point._) {
        let Mat2d = new Obj();
        Mat2d.setStretchToPoint(start, end, p);
        return Mat2d;
    }

    static stretchRotateToPoint(start: Point._, end: Point._, p?: Point._) {
        let Mat2d = new Obj();
        Mat2d.setStretchRotateToPoint(start, end, p);
        return Mat2d;
    }

    static translate(vec: Vec2._) {
        let Mat2d = new Obj();
        Mat2d.setTranslate(vec);
        return Mat2d;
    }

    static translate$(dx: number, dy: number) {
        let Mat2d = new Obj();
        Mat2d.setTranslate$(dx, dy);
        return Mat2d;
    }

    static translateToPoint(start: Point._, end: Point._) {
        let Mat2d = new Obj();
        Mat2d.setTranslateToPoint(start, end);
        return Mat2d;
    }

    /**
     * The first entry in the first column of this Mat2d.
     */
    c1r1: number;
    /**
     * The second entry in the first column of this Mat2d.
     */
    c1r2: number;
    /**
     * The third entry in the first column of this Mat2d.
     */
    c1r3: number;
    /**
     * The first entry in the second column of this Mat2d.
     */
    c2r1: number;
    /**
     * The second entry in the second column of this Mat2d.
     */
    c2r2: number;
    /**
     * The third entry in the second column of this Mat2d.
     */
    c2r3: number;
    /**
     * The first entry in the third column of this Mat2d.
     */
    c3r1: number;
    /**
     * The second entry in the third column of this Mat2d.
     */
    c3r2: number;
    /**
     * The third entry in the third column of this Mat2d.
     */
    c3r3: number;

    /**
     * Sets each component of this Mat2d to that of the other Mat2d.
     */
    set(other: Mat2d) {
        return set(this, other);
    }

    /**
     * Sets each component of this Mat2d.
     */
    set$(c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
        return set$(this, c1r1, c1r2, c1r3, c2r1, c2r2, c2r3, c3r1, c3r2, c3r3);
    }

    /**
     * Adds the other Mat2d to this Mat2d componentwise.
     */
    add(other: Mat2d) {
        return add(this, other);
    }

    /**
     * Adds the specified values to this Mat2d componentwise.
     */
    add$(c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
        return add$(this, c1r1, c1r2, c1r3, c2r1, c2r2, c2r3, c3r1, c3r2, c3r3);
    }

    /**
     * Subtracts the other Mat2d from this Mat2d componentwise.
     */
    subtract(other: Mat2d) {
        return subtract(this, other);
    }

    /**
     * Subtracts the specified values from this Mat2d componentwise.
     */
    subtract$(c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
        return subtract$(this, c1r1, c1r2, c1r3, c2r1, c2r2, c2r3, c3r1, c3r2, c3r3);
    }

    /**
     * Multiplies each component of this Mat2d by the specified scalar.
     */
    mulScalar(k: number) {
        return mulScalar(this, k);
    }

    /**
     * Divides each component of this Mat2d by the specified scalar.
     */
    divScalar(k: number) {
        return divScalar(this, k);
    }

    /**
     * Checks if each component of this Mat2d is equal to that of the other Mat2d.
     */
    equals(other: Mat2d) {
        return equals(this, other);
    }

    /**
     * Checks if each component of this Mat2d is equal to the specified scalar.
     */
    equalsScalar(k: number) {
        return equalsScalar(this, k);
    }

    /**
     * Checks if each component of this Mat2d is approximately equal to that of the other Mat2d.
     */
    epsilonEquals(other: Mat2d, e: number) {
        return epsilonEquals(this, other, e);
    }

    /**
     * Checks if each component of this Mat2d is approximately equal to the specified scalar.
     */
    epsilonEqualsScalar(k: number, e: number) {
        return epsilonEqualsScalar(this, k, e);
    }

    /**
     * Returns a string representation of this Mat2d.
     */
    toString() {
        return toString(this);
    }

    /**
     * Computes the determinant of this Mat2d.
     */
    determinant() {
        return determinant(this);
    }

    /**
     * Sets this matrix to the result of multiplying the specified matrices from left to right.
     * @param left the left hand matrix.
     * @param right the right hand matrix.
     * @param dst where to store the result.
     */
    setConcat(left: Mat2d, right: Mat2d) {
        return setConcat(this, left, right);
    }

    /**
     * Sets this Mat2d to the identity matrix.
     */
    setIdentity() {
        return setIdentity(this);
    }

    /**
     * Sets this Mat2d to map src into dst using the specified scale to fit option.
     * @param src the source rectangle.
     * @param dst the destination rectangle.
     * @param stf the scale to fit option.
     */
    rectToRect(src: Rect._, dst: Rect._, stf: ScaleToFit) {
        return rectToRect(this, src, dst, stf);
    }

    /**
     * Sets this Mat2d to rotate by the specified angle, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param radians the angle of the rotation in radians.
     * @param p the pivot point.
     */
    setRotate(radians: number, p?: Point._) {
        return setRotate(this, radians, p);
    }

    /**
     * Sets this Mat2d to rotate from the specified start point to the specified end Point._, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param start the start point (before rotation).
     * @param end the end point (after rotation).
     * @param p the pivot point. Defaults to (0,0).
     */
    setRotateToPoint(start: Point._, end: Point._, p?: Point._) {
        return setRotateToPoint(this, start, end, p);
    }

    /**
     * Sets this Mat2d to rotate by the specified sin and cos values, with a pivot point at p.
     * @param sin the sine of the rotation angle.
     * @param cos the cosine of the rotation angle.
     * @param p the pivot point.
     */
    setSinCos(sin: number, cos: number, p?: Point._) {
        return setSinCos(this, sin, cos, p);
    }

    /**
     * Sets this Mat2d to scale by the specified width and height ratios, with a pivot point at p.
     * @param sx the percentage by which to scale in the horizontal direction.
     * @param sy the percentage by which to scale in the vertical direction.
     * @param p the pivot point.
     */
    setScale(sx: number, sy: number, p?: Point._) {
        return setScale(this, sx, sy, p);
    }

    /**
     * Sets this Mat2d to scale from the specified start point to the specified end Point._, with a pivot point at p.
     * @param start the start point (before scale).
     * @param end the end point (after scale).
     * @param p the pivot point. Defaults to (0,0).
     */
    setScaleToPoint(start: Point._, end: Point._, p?: Point._) {
        return setScaleToPoint(this, start, end, p);
    }

    /**
     * Sets this Mat2d to stretch by the specified ratio, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param ratio the percentage by which to stretch in all directions.
     * @param p the pivot point.
     */
    setStretch(ratio: number, p?: Point._) {
        return setStretch(this, ratio, p);
    }

    /**
     * Sets this Mat2d to stretch from the specified start point to the specified end Point._, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param start: the start point (before stretch).
     * @param end: the end point (after stretch).
     * @param p the pivot point. Defaults to (0,0).
     */
    setStretchToPoint(start: Point._, end: Point._, p?: Point._) {
        return setStretchToPoint(this, start, end, p);
    }

    /**
     * Sets this Mat2d to stretch rotate from the specified start point to the specified end Point._, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param start the start point (before stretch rotation).
     * @param end the end point (after stretch rotation).
     * @param p the pivot point. Defaults to (0,0).
     */
    setStretchRotateToPoint(start: Point._, end: Point._, p?: Point._) {
        return setStretchRotateToPoint(this, start, end, p);
    }

    /**
     * Sets this Mat2d to translate by the specified vector.
     */
    setTranslate(vec: Vec2._) {
        return setTranslate(this, vec);
    }

    /**
     * Sets this Mat2d to translate by the vector (dx,dy).
     */
    setTranslate$(dx: number, dy: number) {
        return setTranslate$(this, dx, dy);
    }

    /**
     * Sets this Mat2d to translate from the specified start point to the specified end point.
     * @param start the start point (before translation).
     * @param end the end point (after translation).
     */
    setTranslateToPoint(start: Point._, end: Point._) {
        return setTranslateToPoint(this, start, end);
    }

    /**
     * Conjugates this Mat2d with a translation by the specified vector.
     */
    conjugateByTranslation(vec: Vec2._) {
        return conjugateByTranslation(this, vec);
    }

    /**
     * Conjugates this Mat2d with a translation by vector (dx,dy).
     * @param dx the vertical component of the translation vector.
     * @param dy the horizontal component of the translation vector.
     */
    conjugateByTranslation$(dx: number, dy: number) {
        return conjugateByTranslation$(this, dx, dy);
    }

    /**
     * Inverts this Mat2d.
     */
    invert() {
        return invert(this);
    }

    /**
     * Post concats this Mat2d by the other Mat2d: this = other * this.
     */
    postConcat(other: Mat2d) {
        return postConcat(this, other);
    }

    /**
     * Pre concats this Mat2d by the other Mat2d: this = this * other.
     */
    preConcat(other: Mat2d) {
        return preConcat(this, other);
    }

    /**
     * Post concats this Mat2d with a rotation by the specified angle in radians.
     * @param radians the angle in radians.
     */
    postRotate(radians: number) {
        return postRotate(this, radians);
    }

    /**
     * Pre concats this Mat2d with a rotation by the specified angle in radians.
     * @param radians the angle in radians.
     */
    preRotate(radians: number) {
        return preRotate(this, radians);
    }

    /**
     * Post concats this Mat2d with a scale of the specified width and height ratios.
     * @param sx the percentage by which to scale in the horizontal direction.
     * @param sy the percentage by which to scale in the vertical direction.
     */
    postScale(sx: number, sy: number) {
        return postScale(this, sx, sy);
    }

    /**
     * Pre concats this Mat2d with a scale of the specified width and height ratios.
     * @param sx the percentage by which to scale in the horizontal direction.
     * @param sy the percentage by which to scale in the vertical direction.
     */
    preScale(sx: number, sy: number) {
        return preScale(this, sx, sy);
    }

    /**
     * Post concats this Mat2d with a stretch of the specified ratio.
     * @param ratio the percentage by whih to stretch all in directions.
     */
    postStretch(ratio: number) {
        return postStretch(this, ratio);
    }

    /**
     * Pre concats this Mat2d with a stretch of the specified ratio.
     * @param ratio the percentage by which to stretch all in directions.
     */
    preStretch(ratio: number) {
        return preStretch(this, ratio);
    }

    /**
     * Post concats this Mat2d with a translation by the specified vector.
     */
    postTranslate(vec: Vec2._) {
        return postTranslate(this, vec);
    }

    /**
     * Post concats this Mat2d with a translation by vector (dx,dy).
     */
    postTranslate$(dx: number, dy: number) {
        return postTranslate$(this, dx, dy);
    }

    /**
     * Post concats this Mat2d with a translation by vector (dx,dy).
     */
    preTranslate(vec: Vec2._) {
        return preTranslate(this, vec);
    }

    /**
     * Post concats this Mat2d with a translation by vector (dx,dy).
     */
    preTranslate$(dx: number, dy: number) {
        return preTranslate$(this, dx, dy);
    }

    /**
     * Maps the src point and writes the result into dst.
     * @param src the source point.
     * @param dst the destination point. Defaults to new point.
     */
    map(src: Point._, dst: Point._) {
        return map(this, src, dst);
    }

    /**
     * Maps the point (x,y) and writes the result into dst.
     * @param x the x coordinate of the point.
     * @param y the y coordinate of the point.
     * @param dst the destination point. Defaults to new point.
     */
    map$(x: number, y: number, dst: Point._) {
        return map$(this, x, y, dst);
    }

    /**
     * Maps a subset of points in src and writes the result into dst
     * @param src array of points written as a series of (x,y) coordinates.
     * @param srcOffset offset into src of the first point in the subset.
     * @param count the number of points in the subset.
     * @param dst array where result will be stored. Defaults to src.
     * @param dstOffset offset into dst where result should be stored. Defaults to srcOffset.
     */
    mapPoints(src: Float32Array, srcOffset: number, count: number, dst = src, dstOffset = srcOffset) {
        return mapPoints(this, src, srcOffset, count, dst, dstOffset);
    }

    /**
     * Maps the src rect and writes the result into dst.
     * @param src the source rectangle.
     * @param dst the destination rectangle.
     */
    mapRect(src: Rect._, dst: Rect._) {
        return mapRect(this, src, dst);
    }
}

/**
 * A Mat2d backed by a Float32Array.
 */
export class Struct extends Structure<Float32Array> {
    static create(other: Mat2d) {
        let Mat2d = new Struct();
        Mat2d.set(other);
        return Mat2d;
    }

    static create$(c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
        let Mat2d = new Struct();
        Mat2d.set$(c1r1, c1r2, c1r3, c2r1, c2r2, c2r3, c3r1, c3r2, c3r3);
        return Mat2d;
    }

    static concat(left: Mat2d, right: Mat2d) {
        let Mat2d = new Struct();
        Mat2d.setConcat(left, right);
        return Mat2d;
    }

    static identity() {
        let Mat2d = new Struct();
        Mat2d.setIdentity();
        return Mat2d;
    }

    static rotate(radians: number, p?: Point._) {
        let Mat2d = new Struct();
        Mat2d.setRotate(radians, p);
        return Mat2d;
    }

    static rotateToPoint(start: Point._, end: Point._, p?: Point._) {
        let Mat2d = new Struct();
        Mat2d.setRotateToPoint(start, end, p);
        return Mat2d;
    }

    static sinCos(sin: number, cos: number, p?: Point._) {
        let Mat2d = new Struct();
        Mat2d.setSinCos(sin, cos, p);
        return Mat2d;
    }

    static scale(sx: number, sy: number, p?: Point._) {
        let Mat2d = new Struct();
        Mat2d.setScale(sx, sy, p);
        return Mat2d;
    }

    static scaleToPoint(start: Point._, end: Point._, p?: Point._) {
        let Mat2d = new Struct();
        Mat2d.setScaleToPoint(start, end, p);
        return Mat2d;
    }

    static stretch(ratio: number, p?: Point._) {
        let Mat2d = new Struct();
        Mat2d.setStretch(ratio, p);
        return Mat2d;
    }

    static stretchToPoint(start: Point._, end: Point._, p?: Point._) {
        let Mat2d = new Struct();
        Mat2d.setStretchToPoint(start, end, p);
        return Mat2d;
    }

    static stretchRotateToPoint(start: Point._, end: Point._, p?: Point._) {
        let Mat2d = new Struct();
        Mat2d.setStretchRotateToPoint(start, end, p);
        return Mat2d;
    }

    static translate(vec: Vec2._) {
        let Mat2d = new Struct();
        Mat2d.setTranslate(vec);
        return Mat2d;
    }

    static translate$(dx: number, dy: number) {
        let Mat2d = new Struct();
        Mat2d.setTranslate$(dx, dy);
        return Mat2d;
    }

    static translateToPoint(start: Point._, end: Point._) {
        let Mat2d = new Struct();
        Mat2d.setTranslateToPoint(start, end);
        return Mat2d;
    }

    /**
     * Creates a Mat2d struct.
     */
    constructor() {
        super(new Float32Array(9));
    }

    /**
     * The first entry in the first column of this Mat2d.
     */
    get c1r1() {
        return this.data[0];
    }

    /**
     * The first entry in the first column of this Mat2d.
     */
    set c1r1(value: number) {
        this.data[0] = value;
    }

    /**
     * The second entry in the first column of this Mat2d.
     */
    get c1r2() {
        return this.data[1];
    }

    /**
     * The second entry in the first column of this Mat2d.
     */
    set c1r2(value: number) {
        this.data[1] = value;
    }

    /**
     * The third entry in the first column of this Mat2d.
     */
    get c1r3() {
        return this.data[2];
    }

    /**
     * The third entry in the first column of this Mat2d.
     */
    set c1r3(value: number) {
        this.data[2] = value;
    }

    /**
     * The first entry in the second column of this Mat2d.
     */
    get c2r1() {
        return this.data[3];
    }

    /**
     * The first entry in the second column of this Mat2d.
     */
    set c2r1(value: number) {
        this.data[3] = value;
    }

    /**
     * The second entry in the second column of this Mat2d.
     */
    get c2r2() {
        return this.data[4];
    }

    /**
     * The second entry in the second column of this Mat2d.
     */
    set c2r2(value: number) {
        this.data[4] = value;
    }

    /**
     * The third entry in the second column of this Mat2d.
     */
    get c2r3() {
        return this.data[5];
    }

    /**
     * The third entry in the second column of this Mat2d.
     */
    set c2r3(value: number) {
        this.data[5] = value;
    }

    /**
     * The first entry in the third column of this Mat2d.
     */
    get c3r1() {
        return this.data[6];
    }

    /**
     * The first entry in the third column of this Mat2d.
     */
    set c3r1(value: number) {
        this.data[6] = value;
    }

    /**
     * The second entry in the third column of this Mat2d.
     */
    get c3r2() {
        return this.data[7];
    }

    /**
     * The second entry in the third column of this Mat2d.
     */
    set c3r2(value: number) {
        this.data[7] = value;
    }

    /**
     * The third entry in the third column of this Mat2d.
     */
    get c3r3() {
        return this.data[8];
    }

    /**
     * The third entry in the third column of this Mat2d.
     */
    set c3r3(value: number) {
        this.data[8] = value;
    }

    /**
     * Sets each component of this Mat2d to that of the other Mat2d.
     */
    set(other: Mat2d) {
        return set(this, other);
    }

    /**
     * Sets each component of this Mat2d.
     */
    set$(c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
        return set$(this, c1r1, c1r2, c1r3, c2r1, c2r2, c2r3, c3r1, c3r2, c3r3);
    }

    /**
     * Adds the other Mat2d to this Mat2d componentwise.
     */
    add(other: Mat2d) {
        return add(this, other);
    }

    /**
     * Adds the specified values to this Mat2d componentwise.
     */
    add$(c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
        return add$(this, c1r1, c1r2, c1r3, c2r1, c2r2, c2r3, c3r1, c3r2, c3r3);
    }

    /**
     * Subtracts the other Mat2d from this Mat2d componentwise.
     */
    subtract(other: Mat2d) {
        return subtract(this, other);
    }

    /**
     * Subtracts the specified values from this Mat2d componentwise.
     */
    subtract$(c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
        return subtract$(this, c1r1, c1r2, c1r3, c2r1, c2r2, c2r3, c3r1, c3r2, c3r3);
    }

    /**
     * Multiplies each component of this Mat2d by the specified scalar.
     */
    mulScalar(k: number) {
        return mulScalar(this, k);
    }

    /**
     * Divides each component of this Mat2d by the specified scalar.
     */
    divScalar(k: number) {
        return divScalar(this, k);
    }

    /**
     * Checks if each component of this Mat2d is equal to that of the other Mat2d.
     */
    equals(other: Mat2d) {
        return equals(this, other);
    }

    /**
     * Checks if each component of this Mat2d is equal to the specified scalar.
     */
    equalsScalar(k: number) {
        return equalsScalar(this, k);
    }

    /**
     * Checks if each component of this Mat2d is approximately equal to that of the other Mat2d.
     */
    epsilonEquals(other: Mat2d, e: number) {
        return epsilonEquals(this, other, e);
    }

    /**
     * Checks if each component of this Mat2d is approximately equal to the specified scalar.
     */
    epsilonEqualsScalar(k: number, e: number) {
        return epsilonEqualsScalar(this, k, e);
    }

    /**
     * Returns a string representation of this Mat2d.
     */
    toString() {
        return toString(this);
    }

    /**
     * Computes the determinant of this Mat2d.
     */
    determinant() {
        return determinant(this);
    }

    /**
     * Sets this matrix to the result of multiplying the specified matrices from left to right.
     * @param left the left hand matrix.
     * @param right the right hand matrix.
     * @param dst where to store the result.
     */
    setConcat(left: Mat2d, right: Mat2d) {
        return setConcat(this, left, right);
    }

    /**
     * Sets this Mat2d to the identity matrix.
     */
    setIdentity() {
        return setIdentity(this);
    }

    /**
     * Sets this Mat2d to map src into dst using the specified scale to fit option.
     * @param src the source rectangle.
     * @param dst the destination rectangle.
     * @param stf the scale to fit option.
     */
    rectToRect(src: Rect._, dst: Rect._, stf: ScaleToFit) {
        return rectToRect(this, src, dst, stf);
    }

    /**
     * Sets this Mat2d to rotate by the specified angle, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param radians the angle of the rotation in radians.
     * @param p the pivot point.
     */
    setRotate(radians: number, p?: Point._) {
        return setRotate(this, radians, p);
    }

    /**
     * Sets this Mat2d to rotate from the specified start point to the specified end Point._, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param start the start point (before rotation).
     * @param end the end point (after rotation).
     * @param p the pivot point. Defaults to (0,0).
     */
    setRotateToPoint(start: Point._, end: Point._, p?: Point._) {
        return setRotateToPoint(this, start, end, p);
    }

    /**
     * Sets this Mat2d to rotate by the specified sin and cos values, with a pivot point at p.
     * @param sin the sine of the rotation angle.
     * @param cos the cosine of the rotation angle.
     * @param p the pivot point.
     */
    setSinCos(sin: number, cos: number, p?: Point._) {
        return setSinCos(this, sin, cos, p);
    }

    /**
     * Sets this Mat2d to scale by the specified width and height ratios, with a pivot point at p.
     * @param sx the percentage by which to scale in the horizontal direction.
     * @param sy the percentage by which to scale in the vertical direction.
     * @param p the pivot point.
     */
    setScale(sx: number, sy: number, p?: Point._) {
        return setScale(this, sx, sy, p);
    }

    /**
     * Sets this Mat2d to scale from the specified start point to the specified end Point._, with a pivot point at p.
     * @param start the start point (before scale).
     * @param end the end point (after scale).
     * @param p the pivot point. Defaults to (0,0).
     */
    setScaleToPoint(start: Point._, end: Point._, p?: Point._) {
        return setScaleToPoint(this, start, end, p);
    }

    /**
     * Sets this Mat2d to stretch by the specified ratio, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param ratio the percentage by which to stretch in all directions.
     * @param p the pivot point.
     */
    setStretch(ratio: number, p?: Point._) {
        return setStretch(this, ratio, p);
    }

    /**
     * Sets this Mat2d to stretch from the specified start point to the specified end Point._, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param start: the start point (before stretch).
     * @param end: the end point (after stretch).
     * @param p the pivot point. Defaults to (0,0).
     */
    setStretchToPoint(start: Point._, end: Point._, p?: Point._) {
        return setStretchToPoint(this, start, end, p);
    }

    /**
     * Sets this Mat2d to stretch rotate from the specified start point to the specified end Point._, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param start the start point (before stretch rotation).
     * @param end the end point (after stretch rotation).
     * @param p the pivot point. Defaults to (0,0).
     */
    setStretchRotateToPoint(start: Point._, end: Point._, p?: Point._) {
        return setStretchRotateToPoint(this, start, end, p);
    }

    /**
     * Sets this Mat2d to translate by the specified vector.
     */
    setTranslate(vec: Vec2._) {
        return setTranslate(this, vec);
    }

    /**
     * Sets this Mat2d to translate by the vector (dx,dy).
     */
    setTranslate$(dx: number, dy: number) {
        return setTranslate$(this, dx, dy);
    }

    /**
     * Sets this Mat2d to translate from the specified start point to the specified end point.
     * @param start the start point (before translation).
     * @param end the end point (after translation).
     */
    setTranslateToPoint(start: Point._, end: Point._) {
        return setTranslateToPoint(this, start, end);
    }

    /**
     * Conjugates this Mat2d with a translation by the specified vector.
     */
    conjugateByTranslation(vec: Vec2._) {
        return conjugateByTranslation(this, vec);
    }

    /**
     * Conjugates this Mat2d with a translation by vector (dx,dy).
     * @param dx the vertical component of the translation vector.
     * @param dy the horizontal component of the translation vector.
     */
    conjugateByTranslation$(dx: number, dy: number) {
        return conjugateByTranslation$(this, dx, dy);
    }

    /**
     * Inverts this Mat2d.
     */
    invert() {
        return invert(this);
    }

    /**
     * Post concats this Mat2d by the other Mat2d: this = other * this.
     */
    postConcat(other: Mat2d) {
        return postConcat(this, other);
    }

    /**
     * Pre concats this Mat2d by the other Mat2d: this = this * other.
     */
    preConcat(other: Mat2d) {
        return preConcat(this, other);
    }

    /**
     * Post concats this Mat2d with a rotation by the specified angle in radians.
     * @param radians the angle in radians.
     */
    postRotate(radians: number) {
        return postRotate(this, radians);
    }

    /**
     * Pre concats this Mat2d with a rotation by the specified angle in radians.
     * @param radians the angle in radians.
     */
    preRotate(radians: number) {
        return preRotate(this, radians);
    }

    /**
     * Post concats this Mat2d with a scale of the specified width and height ratios.
     * @param sx the percentage by which to scale in the horizontal direction.
     * @param sy the percentage by which to scale in the vertical direction.
     */
    postScale(sx: number, sy: number) {
        return postScale(this, sx, sy);
    }

    /**
     * Pre concats this Mat2d with a scale of the specified width and height ratios.
     * @param sx the percentage by which to scale in the horizontal direction.
     * @param sy the percentage by which to scale in the vertical direction.
     */
    preScale(sx: number, sy: number) {
        return preScale(this, sx, sy);
    }

    /**
     * Post concats this Mat2d with a stretch of the specified ratio.
     * @param ratio the percentage by whih to stretch all in directions.
     */
    postStretch(ratio: number) {
        return postStretch(this, ratio);
    }

    /**
     * Pre concats this Mat2d with a stretch of the specified ratio.
     * @param ratio the percentage by which to stretch all in directions.
     */
    preStretch(ratio: number) {
        return preStretch(this, ratio);
    }

    /**
     * Post concats this Mat2d with a translation by the specified vector.
     */
    postTranslate(vec: Vec2._) {
        return postTranslate(this, vec);
    }

    /**
     * Post concats this Mat2d with a translation by vector (dx,dy).
     */
    postTranslate$(dx: number, dy: number) {
        return postTranslate$(this, dx, dy);
    }

    /**
     * Post concats this Mat2d with a translation by vector (dx,dy).
     */
    preTranslate(vec: Vec2._) {
        return preTranslate(this, vec);
    }

    /**
     * Post concats this Mat2d with a translation by vector (dx,dy).
     */
    preTranslate$(dx: number, dy: number) {
        return preTranslate$(this, dx, dy);
    }

    /**
     * Maps the src point and writes the result into dst.
     * @param src the source point.
     * @param dst the destination point. Defaults to new point.
     */
    map(src: Point._, dst: Point._) {
        return map(this, src, dst);
    }

    /**
     * Maps the point (x,y) and writes the result into dst.
     * @param x the x coordinate of the point.
     * @param y the y coordinate of the point.
     * @param dst the destination point. Defaults to new point.
     */
    map$(x: number, y: number, dst: Point._) {
        return map$(this, x, y, dst);
    }

    /**
     * Maps a subset of points in src and writes the result into dst
     * @param src array of points written as a series of (x,y) coordinates.
     * @param srcOffset offset into src of the first point in the subset.
     * @param count the number of points in the subset.
     * @param dst array where result will be stored. Defaults to src.
     * @param dstOffset offset into dst where result should be stored. Defaults to srcOffset.
     */
    mapPoints(src: Float32Array, srcOffset: number, count: number, dst = src, dstOffset = srcOffset) {
        return mapPoints(this, src, srcOffset, count, dst, dstOffset);
    }

    /**
     * Maps the src rect and writes the result into dst.
     * @param src the source rectangle.
     * @param dst the destination rectangle.
     */
    mapRect(src: Rect._, dst: Rect._) {
        return mapRect(this, src, dst);
    }
}

/**
 * A Mat2d buffer backed by a Float32Array.
 */
export class Buf extends StructureBuffer<Float32Array> {
    /**
     * Creates an empty Mat2d buffer with the specified Mat2d capacity.
     */
    static create(capacity: number) {
        return new Buf(new Float32Array(capacity * 9));
    }

    /**
     * The first entry in the first column of the current Mat2d.
     */
    get c1r1() {
        return this.data[this.dataPosition + 0];
    }

    /**
     * The first entry in the first column of the current Mat2d.
     */
    set c1r1(value: number) {
        this.data[this.dataPosition + 0] = value;
    }

    /**
     * The second entry in the first column of the current Mat2d.
     */
    get c1r2() {
        return this.data[this.dataPosition + 1];
    }

    /**
     * The second entry in the first column of the current Mat2d.
     */
    set c1r2(value: number) {
        this.data[this.dataPosition + 1] = value;
    }

    /**
     * The third entry in the first column of the current Mat2d.
     */
    get c1r3() {
        return this.data[this.dataPosition + 2];
    }

    /**
     * The third entry in the first column of the current Mat2d.
     */
    set c1r3(value: number) {
        this.data[this.dataPosition + 2] = value;
    }

    /**
     * The first entry in the second column of the current Mat2d.
     */
    get c2r1() {
        return this.data[this.dataPosition + 3];
    }

    /**
     * The first entry in the second column of the current Mat2d.
     */
    set c2r1(value: number) {
        this.data[this.dataPosition + 3] = value;
    }

    /**
     * The second entry in the second column of the current Mat2d.
     */
    get c2r2() {
        return this.data[this.dataPosition + 4];
    }

    /**
     * The second entry in the second column of the current Mat2d.
     */
    set c2r2(value: number) {
        this.data[this.dataPosition + 4] = value;
    }

    /**
     * The third entry in the second column of the current Mat2d.
     */
    get c2r3() {
        return this.data[this.dataPosition + 5];
    }

    /**
     * The third entry in the second column of the current Mat2d.
     */
    set c2r3(value: number) {
        this.data[this.dataPosition + 5] = value;
    }

    /**
     * The first entry in the third column of the current Mat2d.
     */
    get c3r1() {
        return this.data[this.dataPosition + 6];
    }

    /**
     * The first entry in the third column of the current Mat2d.
     */
    set c3r1(value: number) {
        this.data[this.dataPosition + 6] = value;
    }

    /**
     * The second entry in the third column of the current Mat2d.
     */
    get c3r2() {
        return this.data[this.dataPosition + 7];
    }

    /**
     * The second entry in the third column of the current Mat2d.
     */
    set c3r2(value: number) {
        this.data[this.dataPosition + 7] = value;
    }

    /**
     * The third entry in the third column of the current Mat2d.
     */
    get c3r3() {
        return this.data[this.dataPosition + 8];
    }

    /**
     * The third entry in the third column of the current Mat2d.
     */
    set c3r3(value: number) {
        this.data[this.dataPosition + 8] = value;
    }

    /**
     * Gets the number of components in a Mat2d, namely 9.
     */
    structLength() {
        return 9;
    }

    /**
     * Sets each component of the Mat2d at the specified position.
     */
    set$(position: number, c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
        let dataPos = position * this.structLength();
        this.data[dataPos++] = c1r1;
        this.data[dataPos++] = c1r2;
        this.data[dataPos++] = c1r3;
        this.data[dataPos++] = c2r1;
        this.data[dataPos++] = c2r2;
        this.data[dataPos++] = c2r3;
        this.data[dataPos++] = c3r1;
        this.data[dataPos++] = c3r2;
        this.data[dataPos++] = c3r3;
    }

    /**
     * Sets each component of the current Mat2d, then moves to the next position of this buffer.
     */
    put$(c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
        this.data[this.dataPosition++] = c1r1;
        this.data[this.dataPosition++] = c1r2;
        this.data[this.dataPosition++] = c1r3;
        this.data[this.dataPosition++] = c2r1;
        this.data[this.dataPosition++] = c2r2;
        this.data[this.dataPosition++] = c2r3;
        this.data[this.dataPosition++] = c3r1;
        this.data[this.dataPosition++] = c3r2;
        this.data[this.dataPosition++] = c3r3;
    }

    /**
     * Sets each component of the current Mat2d to that of the other Mat2d.
     */
    $set(other: Mat2d) {
        return set(this, other);
    }

    /**
     * Sets each component of the current Mat2d.
     */
    $set$(c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
        return set$(this, c1r1, c1r2, c1r3, c2r1, c2r2, c2r3, c3r1, c3r2, c3r3);
    }

    /**
     * Adds the other Mat2d to the current Mat2d componentwise.
     */
    $add(other: Mat2d) {
        return add(this, other);
    }

    /**
     * Adds the specified values to the current Mat2d componentwise.
     */
    $add$(c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
        return add$(this, c1r1, c1r2, c1r3, c2r1, c2r2, c2r3, c3r1, c3r2, c3r3);
    }

    /**
     * Subtracts the other Mat2d from the current Mat2d componentwise.
     */
    $subtract(other: Mat2d) {
        return subtract(this, other);
    }

    /**
     * Subtracts the specified values from the current Mat2d componentwise.
     */
    $subtract$(c1r1: number, c1r2: number, c1r3: number, c2r1: number, c2r2: number, c2r3: number, c3r1: number, c3r2: number, c3r3: number) {
        return subtract$(this, c1r1, c1r2, c1r3, c2r1, c2r2, c2r3, c3r1, c3r2, c3r3);
    }

    /**
     * Multiplies each component of the current Mat2d by the specified scalar.
     */
    $mulScalar(k: number) {
        return mulScalar(this, k);
    }

    /**
     * Divides each component of the current Mat2d by the specified scalar.
     */
    $divScalar(k: number) {
        return divScalar(this, k);
    }

    /**
     * Checks if each component of the current Mat2d is equal to that of the other Mat2d.
     */
    $equals(other: Mat2d) {
        return equals(this, other);
    }

    /**
     * Checks if each component of the current Mat2d is equal to the specified scalar.
     */
    $equalsScalar(k: number) {
        return equalsScalar(this, k);
    }

    /**
     * Checks if each component of the current Mat2d is approximately equal to that of the other Mat2d.
     */
    $epsilonEquals(other: Mat2d, e: number) {
        return epsilonEquals(this, other, e);
    }

    /**
     * Checks if each component of the current Mat2d is approximately equal to the specified scalar.
     */
    $epsilonEqualsScalar(k: number, e: number) {
        return epsilonEqualsScalar(this, k, e);
    }

    /**
     * Returns a string representation of the current Mat2d.
     */
    $toString() {
        return toString(this);
    }

    /**
     * Computes the determinant of the current Mat2d.
     */
    $determinant() {
        return determinant(this);
    }

    /**
     * Sets this matrix to the result of multiplying the specified matrices from left to right.
     * @param left the left hand matrix.
     * @param right the right hand matrix.
     * @param dst where to store the result.
     */
    $setConcat(left: Mat2d, right: Mat2d) {
        return setConcat(this, left, right);
    }

    /**
     * Sets the current Mat2d to the identity matrix.
     */
    $setIdentity() {
        return setIdentity(this);
    }

    /**
     * Sets the current Mat2d to map src into dst using the specified scale to fit option.
     * @param src the source rectangle.
     * @param dst the destination rectangle.
     * @param stf the scale to fit option.
     */
    $rectToRect(src: Rect._, dst: Rect._, stf: ScaleToFit) {
        return rectToRect(this, src, dst, stf);
    }

    /**
     * Sets the current Mat2d to rotate by the specified angle, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param radians the angle of the rotation in radians.
     * @param p the pivot point.
     */
    $setRotate(radians: number, p: Point._) {
        return setRotate(this, radians, p);
    }

    /**
     * Sets the current Mat2d to rotate from the specified start point to the specified end Point._, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param start the start point (before rotation).
     * @param end the end point (after rotation).
     * @param p the pivot point. Defaults to (0,0).
     */
    $setRotateToPoint(start: Point._, end: Point._, p: Point._) {
        return setRotateToPoint(this, start, end, p);
    }

    /**
     * Sets the current Mat2d to rotate by the specified sin and cos values, with a pivot point at p.
     * @param sin the sine of the rotation angle.
     * @param cos the cosine of the rotation angle.
     * @param p the pivot point.
     */
    $setSinCos(sin: number, cos: number, p: Point._) {
        return setSinCos(this, sin, cos, p);
    }

    /**
     * Sets the current Mat2d to scale by the specified width and height ratios, with a pivot point at p.
     * @param sx the percentage by which to scale in the horizontal direction.
     * @param sy the percentage by which to scale in the vertical direction.
     * @param p the pivot point.
     */
    $setScale(sx: number, sy: number, p: Point._) {
        return setScale(this, sx, sy, p);
    }

    /**
     * Sets the current Mat2d to scale from the specified start point to the specified end Point._, with a pivot point at p.
     * @param start the start point (before scale).
     * @param end the end point (after scale).
     * @param p the pivot point. Defaults to (0,0).
     */
    $setScaleToPoint(start: Point._, end: Point._, p: Point._) {
        return setScaleToPoint(this, start, end, p);
    }

    /**
     * Sets the current Mat2d to stretch by the specified ratio, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param ratio the percentage by which to stretch in all directions.
     * @param p the pivot point.
     */
    $setStretch(ratio: number, p: Point._) {
        return setStretch(this, ratio, p);
    }

    /**
     * Sets the current Mat2d to stretch from the specified start point to the specified end Point._, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param start: the start point (before stretch).
     * @param end: the end point (after stretch).
     * @param p the pivot point. Defaults to (0,0).
     */
    $setStretchToPoint(start: Point._, end: Point._, p: Point._) {
        return setStretchToPoint(this, start, end, p);
    }

    /**
     * Sets the current Mat2d to stretch rotate from the specified start point to the specified end Point._, with a pivot point at p.
     * @param m the Mat2d. Defaults to a new matrix.
     * @param start the start point (before stretch rotation).
     * @param end the end point (after stretch rotation).
     * @param p the pivot point. Defaults to (0,0).
     */
    $setStretchRotateToPoint(start: Point._, end: Point._, p: Point._) {
        return setStretchRotateToPoint(this, start, end, p);
    }

    /**
     * Sets the current Mat2d to translate by the specified vector.
     */
    $setTranslate(vec: Vec2._) {
        return setTranslate(this, vec);
    }

    /**
     * Sets the current Mat2d to translate by the vector (dx,dy).
     */
    $setTranslate$(dx: number, dy: number) {
        return setTranslate$(this, dx, dy);
    }

    /**
     * Sets the current Mat2d to translate from the specified start point to the specified end point.
     * @param start the start point (before translation).
     * @param end the end point (after translation).
     */
    $setTranslateToPoint(start: Point._, end: Point._) {
        return setTranslateToPoint(this, start, end);
    }

    /**
     * Conjugates the current Mat2d with a translation by the specified vector.
     */
    $conjugateByTranslation(vec: Vec2._) {
        return conjugateByTranslation(this, vec);
    }

    /**
     * Conjugates the current Mat2d with a translation by vector (dx,dy).
     * @param dx the vertical component of the translation vector.
     * @param dy the horizontal component of the translation vector.
     */
    $conjugateByTranslation$(dx: number, dy: number) {
        return conjugateByTranslation$(this, dx, dy);
    }

    /**
     * Inverts the current Mat2d.
     */
    $invert() {
        return invert(this);
    }

    /**
     * Post concats the current Mat2d by the other Mat2d: this = other * this.
     */
    $postConcat(other: Mat2d) {
        return postConcat(this, other);
    }

    /**
     * Pre concats the current Mat2d by the other Mat2d: this = this * other.
     */
    $preConcat(other: Mat2d) {
        return preConcat(this, other);
    }

    /**
     * Post concats the current Mat2d with a rotation by the specified angle in radians.
     * @param radians the angle in radians.
     */
    $postRotate(radians: number) {
        return postRotate(this, radians);
    }

    /**
     * Pre concats the current Mat2d with a rotation by the specified angle in radians.
     * @param radians the angle in radians.
     */
    $preRotate(radians: number) {
        return preRotate(this, radians);
    }

    /**
     * Post concats the current Mat2d with a scale of the specified width and height ratios.
     * @param sx the percentage by which to scale in the horizontal direction.
     * @param sy the percentage by which to scale in the vertical direction.
     */
    $postScale(sx: number, sy: number) {
        return postScale(this, sx, sy);
    }

    /**
     * Pre concats the current Mat2d with a scale of the specified width and height ratios.
     * @param sx the percentage by which to scale in the horizontal direction.
     * @param sy the percentage by which to scale in the vertical direction.
     */
    $preScale(sx: number, sy: number) {
        return preScale(this, sx, sy);
    }

    /**
     * Post concats the current Mat2d with a stretch of the specified ratio.
     * @param ratio the percentage by whih to stretch all in directions.
     */
    $postStretch(ratio: number) {
        return postStretch(this, ratio);
    }

    /**
     * Pre concats the current Mat2d with a stretch of the specified ratio.
     * @param ratio the percentage by which to stretch all in directions.
     */
    $preStretch(ratio: number) {
        return preStretch(this, ratio);
    }

    /**
     * Post concats the current Mat2d with a translation by the specified vector.
     */
    $postTranslate(vec: Vec2._) {
        return postTranslate(this, vec);
    }

    /**
     * Post concats the current Mat2d with a translation by vector (dx,dy).
     */
    $postTranslate$(dx: number, dy: number) {
        return postTranslate$(this, dx, dy);
    }

    /**
     * Post concats the current Mat2d with a translation by vector (dx,dy).
     */
    $preTranslate(vec: Vec2._) {
        return preTranslate(this, vec);
    }

    /**
     * Post concats the current Mat2d with a translation by vector (dx,dy).
     */
    $preTranslate$(dx: number, dy: number) {
        return preTranslate$(this, dx, dy);
    }

    /**
     * Maps the src point and writes the result into dst.
     * @param src the source point.
     * @param dst the destination point. Defaults to new point.
     */
    $map(src: Point._, dst: Point._) {
        return map(this, src, dst);
    }

    /**
     * Maps the point (x,y) and writes the result into dst.
     * @param x the x coordinate of the point.
     * @param y the y coordinate of the point.
     * @param dst the destination point. Defaults to new point.
     */
    $map$(x: number, y: number, dst: Point._) {
        return map$(this, x, y, dst);
    }

    /**
     * Maps a subset of points in src and writes the result into dst
     * @param src array of points written as a series of (x,y) coordinates.
     * @param srcOffset offset into src of the first point in the subset.
     * @param count the number of points in the subset.
     * @param dst array where result will be stored. Defaults to src.
     * @param dstOffset offset into dst where result should be stored. Defaults to srcOffset.
     */
    $mapPoints(src: Float32Array, srcOffset: number, count: number, dst: Float32Array, dstOffset: number) {
        return mapPoints(this, src, srcOffset, count, dst, dstOffset);
    }

    /**
     * Maps the src rect and writes the result into dst.
     * @param src the source rectangle.
     * @param dst the destination rectangle.
     */
    $mapRect(src: Rect._, dst: Rect._) {
        return mapRect(this, src, dst);
    }
}
